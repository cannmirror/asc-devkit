/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file rmsnorm.asc
 * \brief
 */

#include "acl/acl.h"
#include "data_utils.h"
#include "kernel_operator.h"
#include "tiling/tiling_api.h"

namespace test_rms_norm {
constexpr uint32_t ONE_BLK_FLOAT_NUM = 8;
constexpr uint32_t FLOAT_SIZE_IN_BYTE = 4;
constexpr uint32_t HALF_SIZE_IN_BYTE = 2;
constexpr uint32_t BASIC_BLK_HLENGTH = 64;
constexpr uint32_t BASIC_BLK_BSLENGTH = 8;
constexpr uint32_t BASIC_BLOCK_SIZE = BASIC_BLK_HLENGTH * BASIC_BLK_BSLENGTH;
constexpr uint32_t MAX_REPEAT = 255;

inline __aicore__ uint32_t AlignToBlock(const uint32_t inputValue, const uint32_t typeSize)
{
    uint32_t alignUnit = AscendC::ONE_BLK_SIZE / typeSize;
    return (inputValue + alignUnit - 1) / alignUnit * alignUnit;
}

inline __aicore__ uint32_t GetRmsNormMaxTmpSize(const uint32_t bLength, const uint32_t sLength, const uint32_t hLength,
                                                const uint32_t typeSize, const bool isBasicBlock = false)
{
    const uint32_t inputLength = bLength * sLength * hLength;
    const uint32_t bsLength = AlignToBlock(bLength * sLength, typeSize);

    uint32_t maxSize = inputLength;
    if (typeSize == HALF_SIZE_IN_BYTE) {
        constexpr uint32_t halfCoeff = 2;
        maxSize = maxSize * halfCoeff + bsLength;
    } else {
        maxSize = maxSize + bsLength;
    }

    return maxSize * FLOAT_SIZE_IN_BYTE;
}

inline __aicore__ uint32_t GetRmsNormMinTmpSize(const uint32_t bLength, const uint32_t sLength, const uint32_t hLength,
                                                const uint32_t typeSize, const bool isBasicBlock = false)
{
    uint32_t bsLength = ONE_BLK_FLOAT_NUM;
    uint32_t minSize = hLength;

    if (typeSize == HALF_SIZE_IN_BYTE) {
        constexpr uint32_t bufferCoeff = 2;
        minSize = minSize * bufferCoeff + bsLength;
    } else {
        minSize = minSize + bsLength;
    }

    return minSize * FLOAT_SIZE_IN_BYTE;
}

inline __aicore__ bool GetRmsNormMaxMinTmpSize(const uint32_t bLength, const uint32_t sLength, const uint32_t hLength,
                                               const uint32_t typeSize, uint32_t& maxValue, uint32_t& minValue,
                                               const bool isBasicBlock)
{
    if (isBasicBlock && (hLength % BASIC_BLK_HLENGTH != 0 || bLength * sLength % BASIC_BLK_BSLENGTH != 0)) {
        return false;
    }

    maxValue = GetRmsNormMaxTmpSize(bLength, sLength, hLength, typeSize, isBasicBlock);
    minValue = GetRmsNormMinTmpSize(bLength, sLength, hLength, typeSize, isBasicBlock);
    return true;
}

inline __aicore__ bool GetRmsNormTilingInfo(const AscendC::ShapeInfo& srcShape, const uint32_t stackBufferByteSize,
                                            const uint32_t typeSize, const bool isBasicBlock, RmsNormTiling& tiling)
{
    tiling.bLength = srcShape.shape[0];
    tiling.sLength = srcShape.shape[1];
    tiling.hLength = srcShape.shape[2];

    tiling.originalHLength = srcShape.originalShape[2];
    tiling.reciprocalOfHLength = 1.0f / tiling.originalHLength;

    uint32_t oneTmpSize = stackBufferByteSize / sizeof(float);
    uint32_t alignBsLength = ONE_BLK_FLOAT_NUM;
    uint32_t halfCoeff = (typeSize == sizeof(float) ? 1u : 2u);
    while (oneTmpSize > alignBsLength * tiling.hLength * halfCoeff + alignBsLength) {
        alignBsLength += ONE_BLK_FLOAT_NUM;
    }
    alignBsLength = alignBsLength == ONE_BLK_FLOAT_NUM ? ONE_BLK_FLOAT_NUM : alignBsLength - ONE_BLK_FLOAT_NUM;
    oneTmpSize =
        (typeSize == HALF_SIZE_IN_BYTE) ? (oneTmpSize - alignBsLength) / halfCoeff : (oneTmpSize - alignBsLength);

    const uint32_t inputXSize = tiling.bLength * tiling.sLength * tiling.hLength;
    if (oneTmpSize > inputXSize) {
        oneTmpSize = inputXSize;
    }
    uint32_t bsLength = oneTmpSize / tiling.hLength;
    if (isBasicBlock) {
        bsLength = bsLength < BASIC_BLK_BSLENGTH ? 1 : bsLength / BASIC_BLK_BSLENGTH * BASIC_BLK_BSLENGTH;
    } else if (bsLength > MAX_REPEAT) {
        bsLength = MAX_REPEAT;
    }
    oneTmpSize = bsLength * tiling.hLength;

    tiling.mainBshLength = oneTmpSize;
    tiling.mainBsLength = oneTmpSize / tiling.hLength;
    tiling.mainBsLengthAlign = AlignToBlock(oneTmpSize / tiling.hLength, sizeof(float));
    tiling.loopRound = inputXSize / oneTmpSize;
    const uint32_t inputTailSize = inputXSize % oneTmpSize;
    tiling.tailBshLength = inputTailSize;
    tiling.inputTailPos = inputXSize - inputTailSize;
    tiling.tailBsLength = inputTailSize / tiling.hLength;
    return true;
}

template <typename T, bool isBasicBlock = false>
class KernelRmsnorm {
public:
    __aicore__ inline KernelRmsnorm() {}
    __aicore__ inline void Init(GM_ADDR srcGm, GM_ADDR gammaGm, GM_ADDR dstGm, uint32_t bLength, uint32_t sLength,
                                uint32_t inHLength, T inEpsilon, uint8_t memMode, AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;
        hLength = AlignToBlock(inHLength, sizeof(T));
        epsilon = inEpsilon;
        bshLength = bLength * sLength * hLength;

        inputGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(srcGm), bshLength);
        gammaGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(gammaGm), hLength);
        outputGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(dstGm), bshLength);
        constexpr uint32_t typeSize = sizeof(T);

        pipe->InitBuffer(inQueue, 1, bshLength * typeSize);
        pipe->InitBuffer(inQueueGamma, 1, hLength * typeSize);
        pipe->InitBuffer(outQueue, 1, bshLength * typeSize);

        uint32_t minValue = 0;
        uint32_t maxValue = 0;
        bool res = GetRmsNormMaxMinTmpSize(bLength, sLength, hLength, typeSize, maxValue, minValue, isBasicBlock);
        minValue /= FLOAT_SIZE_IN_BYTE;
        maxValue /= FLOAT_SIZE_IN_BYTE;
        res = AscendC::PopStackBuffer<uint8_t, AscendC::TPosition::LCM>(stackBuffer);
        uint32_t stackSize = UINT32_MAX;
        if (memMode == 0) {
            stackSize = minValue;
        } else if (memMode == 1) {
            stackSize = maxValue;
        } else if (memMode == 2) {
            stackSize = (minValue + maxValue) / 2;
        } else {
            stackSize = stackBuffer.GetSize() / FLOAT_SIZE_IN_BYTE;
        }
        uint32_t inputShape[3] = {bLength, sLength, hLength};
        uint32_t originShape[3] = {bLength, sLength, inHLength};

        uint32_t gammaShape[1] = {hLength};
        uint32_t originGammaShape[1] = {inHLength};

        bshShapeInfo = {3, inputShape, 3, originShape, AscendC::DataFormat::ND};
        bsShapeInfo = {1, gammaShape, 1, originGammaShape, AscendC::DataFormat::ND};

        GetRmsNormTilingInfo(bshShapeInfo, stackSize * sizeof(float), typeSize, isBasicBlock, tiling);
        stackBuffer.SetSize(stackSize * sizeof(float));
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        Compute();
        CopyOut();
    }

private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<T> inputLocal = inQueue.AllocTensor<T>();
        AscendC::DataCopy(inputLocal, inputGlobal, bshLength);
        inQueue.EnQue(inputLocal);

        AscendC::LocalTensor<T> gammaLocal = inQueueGamma.AllocTensor<T>();
        AscendC::DataCopy(gammaLocal, gammaGlobal, hLength);
        inQueueGamma.EnQue(gammaLocal);
    }
    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<T> inputLocal = inQueue.DeQue<T>();
        AscendC::LocalTensor<T> gammaLocal = inQueueGamma.DeQue<T>();
        AscendC::LocalTensor<T> outputLocal = outQueue.AllocTensor<T>();

        inputLocal.SetShapeInfo(bshShapeInfo);
        outputLocal.SetShapeInfo(bshShapeInfo);
        gammaLocal.SetShapeInfo(bsShapeInfo);
        AscendC::PipeBarrier<PIPE_MTE2>();
        AscendC::RmsNorm<T, isBasicBlock>(outputLocal, inputLocal, gammaLocal, stackBuffer, epsilon, tiling);
        AscendC::PipeBarrier<PIPE_V>();
        inQueue.FreeTensor(inputLocal);
        inQueueGamma.FreeTensor(gammaLocal);
        outQueue.EnQue(outputLocal);
    }
    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<T> outputLocal = outQueue.DeQue<T>();
        AscendC::DataCopy(outputGlobal, outputLocal, bshLength);
        outQueue.FreeTensor(outputLocal);
    }

private:
    AscendC::GlobalTensor<T> inputGlobal;
    AscendC::GlobalTensor<T> gammaGlobal;
    AscendC::GlobalTensor<T> outputGlobal;
    AscendC::LocalTensor<uint8_t> stackBuffer;

    AscendC::TPipe* pipe;
    AscendC::TQue<AscendC::QuePosition::VECIN, 1> inQueue;
    AscendC::TQue<AscendC::QuePosition::VECIN, 1> inQueueGamma;
    AscendC::TQue<AscendC::QuePosition::VECOUT, 1> outQueue;

    RmsNormTiling tiling;
    uint32_t hLength;
    T epsilon;
    uint32_t bshLength;
    AscendC::ShapeInfo bshShapeInfo;
    AscendC::ShapeInfo bsShapeInfo;
};
} // namespace test_rms_norm

__vector__ __global__ void rmsnorm_custom(GM_ADDR srcGm, GM_ADDR gammaGm, GM_ADDR dstGm)
{
    AscendC::TPipe pipe;
    uint32_t bLength = 1;
    uint32_t sLength = 1;
    uint32_t hLength = 16;
    float epsilon = 5e-05;
    uint8_t memMode = 3;
    test_rms_norm::KernelRmsnorm<float, false> op;
    op.Init(srcGm, gammaGm, dstGm, bLength, sLength, hLength, epsilon, memMode, &pipe);
    op.Process();
}

static bool CompareResult(const void* outputData, uint32_t outSize)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden.bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden.bin success!\n");
    } else {
        printf("test failed!\n");
        return false;
    }
    constexpr float EPS = 1e-4;
    int64_t wrongNum = 0;

    for (size_t i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult golden.bin failed output is %lf, golden is %lf\n", a, b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    if (wrongNum != 0) {
        printf("wrongNum: %ld\n", wrongNum);
        return false;
    } else {
        printf("CompareResult golden.bin success!\n");
        return true;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    size_t param1FileSize = 16 * sizeof(float);
    size_t param2FileSize = 16 * sizeof(float);
    size_t param3FileSize = 16 * sizeof(float);
    size_t param4FileSize = 3 * sizeof(uint32_t);
    uint32_t blockDim = 1;

    aclInit(nullptr);
    aclrtContext context;
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtCreateContext(&context, deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t* param1Host;
    uint8_t* param1Device;
    aclrtMallocHost((void**)(&param1Host), param1FileSize);
    aclrtMalloc((void**)&param1Device, param1FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_inputX.bin", param1FileSize, param1Host, param1FileSize);
    aclrtMemcpy(param1Device, param1FileSize, param1Host, param1FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param2Host;
    uint8_t* param2Device;
    aclrtMallocHost((void**)(&param2Host), param2FileSize);
    aclrtMalloc((void**)&param2Device, param2FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_gamma.bin", param2FileSize, param2Host, param2FileSize);
    aclrtMemcpy(param2Device, param2FileSize, param2Host, param2FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param3Host;
    uint8_t* param3Device;
    aclrtMallocHost((void**)(&param3Host), param3FileSize);
    aclrtMalloc((void**)&param3Device, param3FileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    uint8_t* param4Host;
    uint8_t* param4Device;
    aclrtMallocHost((void**)(&param4Host), param4FileSize);
    aclrtMalloc((void**)&param4Device, param4FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_tiling.bin", param4FileSize, param4Host, param4FileSize);
    aclrtMemcpy(param4Device, param4FileSize, param4Host, param4FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    rmsnorm_custom<<<blockDim, nullptr, stream>>>(param1Device, param2Device, param3Device);

    aclrtSynchronizeStream(stream);

    aclrtFree(param1Device);
    aclrtFreeHost(param1Host);
    aclrtFree(param2Device);
    aclrtFreeHost(param2Host);

    aclrtMemcpy(param3Host, param3FileSize, param3Device, param3FileSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", param3Host, param3FileSize);

    bool goldenResult = true;
    goldenResult = CompareResult(param3Host, param3FileSize);

    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }

    aclrtFree(param3Device);
    aclrtFreeHost(param3Host);
    aclrtFree(param4Device);
    aclrtFreeHost(param4Host);

    aclrtDestroyStream(stream);
    aclrtDestroyContext(context);
    aclrtResetDevice(deviceId);
    aclFinalize();

    return 0;
}