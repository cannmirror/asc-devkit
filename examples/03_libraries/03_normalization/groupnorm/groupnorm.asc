/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file groupnorm.asc
 * \brief
 */

#include "acl/acl.h"
#include "data_utils.h"
#include "kernel_operator.h"
#include "tiling/tiling_api.h"

struct InputParams {
    InputParams() {}
    uint32_t nLength;
    uint32_t cLength;
    uint32_t hLength;
    uint32_t wLength;
    uint32_t typeSize;
    uint32_t groupNum;
};

namespace optiling {
BEGIN_TILING_DATA_DEF(GroupnormCustomTilingData)
TILING_DATA_FIELD_DEF_STRUCT(GroupNormTiling, GroupNormTilingData);
TILING_DATA_FIELD_DEF(uint32_t, groupNum);
TILING_DATA_FIELD_DEF(float, epsilon);
END_TILING_DATA_DEF;

REGISTER_TILING_DATA_CLASS(GroupnormCustom, GroupnormCustomTilingData)
} // namespace optiling

void ComputeTiling(InputParams& params, optiling::GroupnormCustomTilingData& tiling)
{
    uint32_t n = params.nLength;
    uint32_t c = params.cLength;
    uint32_t h = params.hLength;
    uint32_t w = params.wLength;
    uint32_t g = params.groupNum;
    uint32_t typeSize = params.typeSize;

    std::vector<int64_t> shapeVec = {n, c, h, w};
    ge::Shape srcShape(shapeVec);

    uint32_t maxSize = 0;
    uint32_t minSize = 0;
    bool isReuseSource = false;
    AscendC::GetGroupNormMaxMinTmpSize(srcShape, typeSize, isReuseSource, g, maxSize, minSize);

    /**
        if use minSize, split NCHW into n * g unit and each unit has shape {1, c/g, h, w}
        each core compute one unit data

        uint32_t k = 1;
        std::vector<int64_t> minShapeVec = {1, k * c / g, h, w};
        ge::Shape minShape(minShapeVec);
        AscendC::GetGroupNormNDTilingInfo(minShape, k * minSize, typeSize, isReuseSource, k,
       tiling.GroupNormTilingData);
    */

    /**
        if use maxSize, compute all data in one core
        enough UB size should be reserved
    */

    std::vector<int64_t> maxShapeVec = {n, c, h, w};
    ge::Shape maxShape(maxShapeVec);
    AscendC::GetGroupNormNDTilingInfo(maxShape, maxSize, typeSize, isReuseSource, g, tiling.GroupNormTilingData);

    tiling.set_groupNum(g);

    const float groupNormEpsilon = 0.00001;
    tiling.set_epsilon(groupNormEpsilon); // set epsilon = 0.00001
}

uint8_t* GetTilingBuf(optiling::GroupnormCustomTilingData* tilingData)
{
    uint32_t tilingSize = sizeof(optiling::GroupnormCustomTilingData);
    uint8_t* buf = (uint8_t*)malloc(tilingSize);
    tilingData->SaveToBuffer(buf, tilingSize);
    return buf;
}

uint8_t* GenerateTiling(InputParams& params)
{
    optiling::GroupnormCustomTilingData tiling;
    ComputeTiling(params, tiling);
    return GetTilingBuf(&tiling);
}

namespace MyCustomKernel {
struct VecTiling {
    GroupNormTiling groupnormTilingData;
    uint32_t groupNum = 0;
    float epsilon = 0;
};

template <bool isReuseSource = false>
class KernelGroupnorm {
public:
    __aicore__ inline KernelGroupnorm() {}
    __aicore__ inline void Init(GM_ADDR inputXGm, GM_ADDR gammGm, GM_ADDR betaGm, GM_ADDR outputGm, GM_ADDR meanGm,
                                GM_ADDR varGm, VecTiling tilingData, AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;
        this->epsilon = tilingData.epsilon;
        tiling_ = tilingData.groupnormTilingData;
        this->n = tiling_.n;
        this->c = tiling_.c;
        this->hw = tiling_.hw;
        this->g = tiling_.g;
        this->nchwLength = n * c * this->hw;
        uint32_t groupNum = tilingData.groupNum;

        inputXGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(inputXGm), this->nchwLength);
        gammGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(gammGm), c);
        betaGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(betaGm), c);
        outputGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(outputGm), this->nchwLength);
        outputMeanGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(meanGm), n * g);
        outputVarianceGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(varGm), n * g);

        this->hwAlignSize = (sizeof(float) * this->hw + AscendC::ONE_BLK_SIZE - 1) / AscendC::ONE_BLK_SIZE
                            * AscendC::ONE_BLK_SIZE / sizeof(float);
        this->cAlignSize = (sizeof(float) * c + AscendC::ONE_BLK_SIZE - 1) / AscendC::ONE_BLK_SIZE
                           * AscendC::ONE_BLK_SIZE / sizeof(float);
        this->gAlignSize =
            (n * g + AscendC::ONE_BLK_SIZE - 1) / AscendC::ONE_BLK_SIZE * AscendC::ONE_BLK_SIZE / sizeof(float);

        pipe->InitBuffer(inQueueX, 1, sizeof(float) * n * c * this->hwAlignSize);
        pipe->InitBuffer(inQueueGamma, 1, sizeof(float) * this->cAlignSize);
        pipe->InitBuffer(inQueueBeta, 1, sizeof(float) * this->cAlignSize);
        pipe->InitBuffer(outQueue, 1, sizeof(float) * n * c * this->hwAlignSize);
        pipe->InitBuffer(outQueueMean, 1, sizeof(float) * this->gAlignSize);
        pipe->InitBuffer(outQueueVariance, 1, sizeof(float) * this->gAlignSize);
    }

    __aicore__ inline void Process()
    {
        CopyIn();
        Compute();
        CopyOut();
    }

private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<float> inputXLocal = inQueueX.AllocTensor<float>();
        AscendC::LocalTensor<float> gammaLocal = inQueueGamma.AllocTensor<float>();
        AscendC::LocalTensor<float> betaLocal = inQueueBeta.AllocTensor<float>();

        AscendC::DataCopy<float>(inputXLocal, inputXGlobal, n * c * this->hwAlignSize);
        AscendC::DataCopy<float>(gammaLocal, gammGlobal, this->cAlignSize);
        AscendC::DataCopy<float>(betaLocal, betaGlobal, this->cAlignSize);

        inQueueX.EnQue(inputXLocal);
        inQueueGamma.EnQue(gammaLocal);
        inQueueBeta.EnQue(betaLocal);
    }

    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<float> inputXLocal = inQueueX.DeQue<float>();
        AscendC::LocalTensor<float> gammaLocal = inQueueGamma.DeQue<float>();
        AscendC::LocalTensor<float> betaLocal = inQueueBeta.DeQue<float>();

        AscendC::LocalTensor<float> outputLocal = outQueue.AllocTensor<float>();
        AscendC::LocalTensor<float> meanLocal = outQueueMean.AllocTensor<float>();
        AscendC::LocalTensor<float> varianceLocal = outQueueVariance.AllocTensor<float>();

        AscendC::GroupNorm<float, false>(outputLocal, meanLocal, varianceLocal, inputXLocal, gammaLocal, betaLocal,
                                         epsilon, tiling_);

        outQueue.EnQue<float>(outputLocal);
        outQueueMean.EnQue<float>(meanLocal);
        outQueueVariance.EnQue<float>(varianceLocal);
        inQueueX.FreeTensor(inputXLocal);
        inQueueGamma.FreeTensor(gammaLocal);
        inQueueBeta.FreeTensor(betaLocal);
    }

    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<float> outputLocal = outQueue.DeQue<float>();
        AscendC::LocalTensor<float> meanLocal = outQueueMean.DeQue<float>();
        AscendC::LocalTensor<float> varLocal = outQueueVariance.DeQue<float>();

        AscendC::DataCopy<float>(this->outputGlobal, outputLocal, n * c * hw);
        AscendC::DataCopy<float>(this->outputVarianceGlobal, varLocal, n * g);
        AscendC::DataCopy<float>(this->outputMeanGlobal, meanLocal, n * g);

        outQueue.FreeTensor(outputLocal);
        outQueueMean.FreeTensor(meanLocal);
        outQueueVariance.FreeTensor(varLocal);
    }

private:
    AscendC::GlobalTensor<float> inputXGlobal;
    AscendC::GlobalTensor<float> gammGlobal;
    AscendC::GlobalTensor<float> betaGlobal;
    AscendC::GlobalTensor<float> outputGlobal;
    AscendC::GlobalTensor<float> outputMeanGlobal;
    AscendC::GlobalTensor<float> outputVarianceGlobal;

    AscendC::TPipe* pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueGamma;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueBeta;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueue;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueueMean;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueueVariance;

    uint32_t n, c, hw, g;
    uint32_t nchwLength;
    uint32_t hwAlignSize;
    uint32_t cAlignSize;
    uint32_t gAlignSize;
    GroupNormTiling tiling_;
    float epsilon;
};
} // namespace MyCustomKernel

__aicore__ inline void CopyTiling(MyCustomKernel::VecTiling* tiling, GM_ADDR tilingGM)
{
    uint32_t* ptr = reinterpret_cast<uint32_t*>(tiling);
    auto tiling32 = reinterpret_cast<__gm__ uint32_t*>(tilingGM);

    for (int i = 0; i < sizeof(MyCustomKernel::VecTiling) / sizeof(uint32_t); i++, ptr++) { *ptr = *(tiling32 + i); }
    return;
}

extern "C" __global__ __vector__ void groupnorm_custom(GM_ADDR inputXGm, GM_ADDR gammaGm, GM_ADDR betaGm,
                                                       GM_ADDR outputGm, GM_ADDR outputMeanGm, GM_ADDR outputVarianceGm,
                                                       GM_ADDR workspace, GM_ADDR tiling)
{
    AscendC::TPipe pipe;
    MyCustomKernel::VecTiling tilingData;
    CopyTiling(&tilingData, tiling);
    MyCustomKernel::KernelGroupnorm<false> op;
    op.Init(inputXGm, gammaGm, betaGm, outputGm, outputMeanGm, outputVarianceGm, tilingData, &pipe);
    op.Process();
}

constexpr uint32_t NLENGTH = 2;
constexpr uint32_t CLENGTH = 16;
constexpr uint32_t HLENGTH = 8;
constexpr uint32_t WLENGTH = 8;
constexpr uint32_t GROUP_NUM = 4;
constexpr uint32_t NUM_BLOCKS = 1;
constexpr uint32_t TILINGDATA_SIZE = 32;
constexpr uint32_t WORKSPACE_SIZE = 1024;

static bool CompareResult(const void* outputData, int64_t outSize, std::string goldenName)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden_output_" + goldenName + ".bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden_output_%s.bin success!\n", goldenName.c_str());
    } else {
        printf("test failed!\n");
        return false;
    }
    constexpr float EPS = 1e-5;
    int64_t wrongNum = 0;

    for (int i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult golden_output_%s.bin failed output is %lf, golden is %lf\n", goldenName.c_str(), a,
                   b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    if (wrongNum != 0) {
        return false;
    } else {
        printf("CompareResult golden_output_%s.bin success!\n", goldenName.c_str());
        return true;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    uint32_t numBlocks = NUM_BLOCKS;
    size_t workspaceSize = WORKSPACE_SIZE * sizeof(float);
    size_t xSize = NLENGTH * CLENGTH * HLENGTH * WLENGTH * sizeof(float);
    size_t gammaSize = CLENGTH * sizeof(float);
    size_t betaSize = CLENGTH * sizeof(float);
    size_t outputSize = NLENGTH * CLENGTH * HLENGTH * WLENGTH * sizeof(float);
    size_t meanSize = NLENGTH * GROUP_NUM * sizeof(float);
    size_t varianceSize = NLENGTH * GROUP_NUM * sizeof(float);
    size_t tilingFileSize = TILINGDATA_SIZE * sizeof(uint32_t);
    bool goldenResult = true;
    InputParams params;
    params.nLength = NLENGTH;
    params.cLength = CLENGTH;
    params.hLength = HLENGTH;
    params.wLength = WLENGTH;
    params.typeSize = sizeof(float);
    params.groupNum = GROUP_NUM;

    aclInit(nullptr);
    aclrtContext context;
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtCreateContext(&context, deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *inputXHost, *gammaHost, *betaHost, *resultHost, *meanHost, *varianceHost, *workspaceHost, *tilingHost;
    uint8_t *inputXDevice, *gammaDevice, *betaDevice, *resultDevice, *meanDevice, *varianceDevice, *workspaceDevice,
        *tilingDevice;

    aclrtMallocHost((void**)(&inputXHost), xSize);
    aclrtMallocHost((void**)(&gammaHost), gammaSize);
    aclrtMallocHost((void**)(&betaHost), betaSize);
    aclrtMallocHost((void**)(&resultHost), outputSize);
    aclrtMallocHost((void**)(&meanHost), meanSize);
    aclrtMallocHost((void**)(&varianceHost), varianceSize);
    aclrtMallocHost((void**)(&workspaceHost), workspaceSize);
    aclrtMallocHost((void**)(&tilingHost), tilingFileSize);
    aclrtMalloc((void**)&inputXDevice, xSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&gammaDevice, gammaSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&betaDevice, betaSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&resultDevice, outputSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&meanDevice, meanSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&varianceDevice, varianceSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&workspaceDevice, workspaceSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&tilingDevice, tilingFileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/input_inputX.bin", xSize, inputXHost, xSize);
    ReadFile("./input/input_gamma.bin", gammaSize, gammaHost, gammaSize);
    ReadFile("./input/input_beta.bin", betaSize, betaHost, betaSize);

    aclrtMemcpy(workspaceDevice, workspaceSize, workspaceHost, workspaceSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(tilingDevice, tilingFileSize, GenerateTiling(params), tilingFileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    aclrtMemcpy(inputXDevice, xSize, inputXHost, xSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(gammaDevice, gammaSize, gammaHost, gammaSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(betaDevice, betaSize, betaHost, betaSize, ACL_MEMCPY_HOST_TO_DEVICE);

    groupnorm_custom<<<numBlocks, nullptr, stream>>>(inputXDevice, gammaDevice, betaDevice, resultDevice, meanDevice,
                                                    varianceDevice, workspaceDevice, tilingDevice);
    aclrtSynchronizeStream(stream);
    aclrtMemcpy(resultHost, outputSize, resultDevice, outputSize, ACL_MEMCPY_DEVICE_TO_HOST);
    aclrtMemcpy(meanHost, meanSize, meanDevice, meanSize, ACL_MEMCPY_DEVICE_TO_HOST);

    aclrtMemcpy(varianceHost, varianceSize, varianceDevice, varianceSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output_result.bin", resultHost, outputSize);
    WriteFile("./output/output_mean.bin", meanHost, meanSize);
    WriteFile("./output/output_variance.bin", varianceHost, varianceSize);

    goldenResult &= CompareResult(resultHost, outputSize, "result");
    goldenResult &= CompareResult(meanHost, meanSize, "mean");
    goldenResult &= CompareResult(varianceHost, varianceSize, "variance");

    aclrtFree(inputXDevice);
    aclrtFree(gammaDevice);
    aclrtFree(betaDevice);
    aclrtFree(resultDevice);
    aclrtFree(meanDevice);
    aclrtFree(varianceDevice);
    aclrtFree(workspaceDevice);
    aclrtFree(tilingDevice);
    aclrtFreeHost(inputXHost);
    aclrtFreeHost(gammaHost);
    aclrtFreeHost(betaHost);
    aclrtFreeHost(resultHost);
    aclrtFreeHost(meanHost);
    aclrtFreeHost(varianceHost);
    aclrtFreeHost(workspaceHost);
    aclrtFreeHost(tilingHost);

    aclrtDestroyStream(stream);
    aclrtDestroyContext(context);
    aclrtResetDevice(deviceId);
    aclFinalize();
    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }
    return 0;
}