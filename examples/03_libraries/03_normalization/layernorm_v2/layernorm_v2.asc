/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file layernorm_v2.asc
 * \brief
 */

#include "acl/acl.h"
#include "data_utils.h"
#include "kernel_operator.h"
#include "tiling/tiling_api.h"

namespace optiling {
BEGIN_TILING_DATA_DEF(LayernormCustomTilingData)
TILING_DATA_FIELD_DEF_STRUCT(LayerNormSeparateTiling, layernormTilingData);
TILING_DATA_FIELD_DEF(uint32_t, aLength);
TILING_DATA_FIELD_DEF(uint32_t, rLength);
TILING_DATA_FIELD_DEF(uint32_t, rLengthWithPadding);
TILING_DATA_FIELD_DEF(float, epsilon);
END_TILING_DATA_DEF;

REGISTER_TILING_DATA_CLASS(LayernormCustom, LayernormCustomTilingData)
} // namespace optiling

void ComputeTiling(const uint32_t aLength, const uint32_t rLength, const uint32_t rLengthWithPadding,
                   optiling::LayernormCustomTilingData& tiling)
{
    ge::Shape geShape({aLength, rLength});

    uint32_t maxTmpSize = 0;
    uint32_t minTmpSize = 0;
    bool isReuseSource = false;
    AscendC::GetLayerNormMaxMinTmpSize(geShape, sizeof(float), isReuseSource, true, false, maxTmpSize, minTmpSize);

    uint32_t localWorkspaceSize = minTmpSize;
    // get layernorm Tiling
    AscendC::GetLayerNormNDTilingInfo(geShape, localWorkspaceSize, sizeof(float), isReuseSource, true,
                                      tiling.layernormTilingData);
    tiling.set_aLength(aLength);
    tiling.set_rLength(rLength);
    tiling.set_rLengthWithPadding(rLengthWithPadding);
    tiling.set_epsilon(0.0001);
}

uint8_t* GetTilingBuf(optiling::LayernormCustomTilingData* tilingData)
{
    uint32_t tilingSize = sizeof(optiling::LayernormCustomTilingData);
    uint8_t* buf = (uint8_t*)malloc(tilingSize);
    tilingData->SaveToBuffer(buf, tilingSize);
    return buf;
}

uint8_t* GenerateTiling(uint32_t aLength, uint32_t rLength, uint32_t rLengthWithPadding)
{
    optiling::LayernormCustomTilingData tiling;
    ComputeTiling(aLength, rLength, rLengthWithPadding, tiling);
    return GetTilingBuf(&tiling);
}

namespace LayerNormCustomKernel {
struct VecTiling {
    LayerNormSeparateTiling layernormTilingData;
    uint32_t aLength = 0;
    uint32_t rLength = 0;
    uint32_t rLengthWithPadding = 0;
    float epsilon = 0;
};
__aicore__ constexpr AscendC::LayerNormConfig GetConfig()
{
    return {.isNoBeta = false, .isNoGamma = false, .isOnlyOutput = false};
}
template <bool isReuseSource = false>
class KernelLayernorm {
public:
    __aicore__ inline KernelLayernorm() {}
    __aicore__ inline void Init(GM_ADDR inputXGm, GM_ADDR gammGm, GM_ADDR betaGm, GM_ADDR outputGm,
                                GM_ADDR outputMeanGm, GM_ADDR outputRstdGm, VecTiling tilingData,
                                AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;
        this->epsilon = tilingData.epsilon;
        tiling_ = tilingData.layernormTilingData;
        this->aLength = tilingData.aLength;
        this->rLength = tilingData.rLength;
        this->rLengthWithPadding = tilingData.rLengthWithPadding;

        arLength = aLength * rLengthWithPadding;

        inputXGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(inputXGm), arLength);
        gammGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(gammGm), rLengthWithPadding);
        betaGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(betaGm), rLengthWithPadding);

        outputGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(outputGm), arLength);
        outputMeanGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(outputMeanGm), aLength);
        outputRstdGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(outputRstdGm), aLength);

        pipe->InitBuffer(inQueueX, 1, sizeof(float) * arLength);
        pipe->InitBuffer(inQueueGamma, 1, sizeof(float) * rLengthWithPadding);
        pipe->InitBuffer(inQueueBeta, 1, sizeof(float) * rLengthWithPadding);
        pipe->InitBuffer(outQueue, 1, sizeof(float) * arLength);
        pipe->InitBuffer(outQueueMean, 1, sizeof(float) * aLength);
        pipe->InitBuffer(outQueueRstd, 1, sizeof(float) * aLength);
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        Compute();
        CopyOut();
    }

private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<float> inputXLocal = inQueueX.AllocTensor<float>();
        AscendC::LocalTensor<float> gammaLocal = inQueueGamma.AllocTensor<float>();
        AscendC::LocalTensor<float> betaLocal = inQueueBeta.AllocTensor<float>();

        AscendC::DataCopy(inputXLocal, inputXGlobal, arLength);
        AscendC::DataCopy(gammaLocal, gammGlobal, rLengthWithPadding);
        AscendC::DataCopy(betaLocal, betaGlobal, rLengthWithPadding);

        inQueueX.EnQue(inputXLocal);
        inQueueGamma.EnQue(gammaLocal);
        inQueueBeta.EnQue(betaLocal);
    }
    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<float> inputXLocal = inQueueX.DeQue<float>();
        AscendC::LocalTensor<float> gammaLocal = inQueueGamma.DeQue<float>();
        AscendC::LocalTensor<float> betaLocal = inQueueBeta.DeQue<float>();

        AscendC::LocalTensor<float> outputLocal = outQueue.AllocTensor<float>();
        AscendC::LocalTensor<float> meanLocal = outQueueMean.AllocTensor<float>();
        AscendC::LocalTensor<float> rstdLocal = outQueueRstd.AllocTensor<float>();

        const AscendC::LayerNormPara para = {aLength, rLength, rLengthWithPadding};
        static constexpr AscendC::LayerNormConfig config = GetConfig();
        AscendC::LayerNorm<float, float, isReuseSource, config>(outputLocal, meanLocal, rstdLocal, inputXLocal,
                                                                gammaLocal, betaLocal, (float)epsilon, para, tiling_);

        outQueue.EnQue<float>(outputLocal);
        outQueueMean.EnQue<float>(meanLocal);
        outQueueRstd.EnQue<float>(rstdLocal);

        inQueueX.FreeTensor(inputXLocal);
        inQueueGamma.FreeTensor(gammaLocal);
        inQueueBeta.FreeTensor(betaLocal);
    }
    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<float> outputLocal = outQueue.DeQue<float>();
        AscendC::LocalTensor<float> meanLocal = outQueueMean.DeQue<float>();
        AscendC::LocalTensor<float> rstdLocal = outQueueRstd.DeQue<float>();

        AscendC::DataCopy(outputGlobal, outputLocal, arLength);
        AscendC::DataCopy(outputMeanGlobal, meanLocal, aLength);
        AscendC::DataCopy(outputRstdGlobal, rstdLocal, aLength);

        outQueue.FreeTensor(outputLocal);
        outQueueMean.FreeTensor(meanLocal);
        outQueueRstd.FreeTensor(rstdLocal);
    }

private:
    AscendC::GlobalTensor<float> inputXGlobal;
    AscendC::GlobalTensor<float> gammGlobal;
    AscendC::GlobalTensor<float> betaGlobal;
    AscendC::GlobalTensor<float> outputGlobal;
    AscendC::GlobalTensor<float> outputMeanGlobal;
    AscendC::GlobalTensor<float> outputRstdGlobal;

    AscendC::TPipe* pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueGamma;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueBeta;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueue;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueueMean;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueueRstd;

    uint32_t aLength;
    uint32_t rLength;
    uint32_t rLengthWithPadding;
    float epsilon;
    LayerNormSeparateTiling tiling_;

    uint32_t arLength;
};
} // namespace LayerNormCustomKernel

__aicore__ inline void CopyTiling(LayerNormCustomKernel::VecTiling* tiling, GM_ADDR tilingGM)
{
    uint32_t* ptr = reinterpret_cast<uint32_t*>(tiling);
    auto tiling32 = reinterpret_cast<__gm__ uint32_t*>(tilingGM);

    for (int i = 0; i < sizeof(LayerNormCustomKernel::VecTiling) / sizeof(uint32_t); i++, ptr++) {
        *ptr = *(tiling32 + i);
    }
    return;
}

extern "C" __global__ __aicore__ void layernorm_custom(GM_ADDR inputXGm, GM_ADDR gammaGm, GM_ADDR betaGm,
                                                       GM_ADDR outputGm, GM_ADDR outputMeanGm, GM_ADDR outputRstdGm,
                                                       GM_ADDR workspace, GM_ADDR tiling)
{
    KERNEL_TASK_TYPE_DEFAULT(KERNEL_TYPE_AIV_ONLY);
    AscendC::TPipe pipe;
    LayerNormCustomKernel::VecTiling tilingData;
    CopyTiling(&tilingData, tiling);
    LayerNormCustomKernel::KernelLayernorm<false> op;
    op.Init(inputXGm, gammaGm, betaGm, outputGm, outputMeanGm, outputRstdGm, tilingData, &pipe);
    op.Process();
}

constexpr uint32_t ALENGTH = 32;
constexpr uint32_t RLENGTH = 32;
constexpr uint32_t RLENGTH_WITH_PAD = 32;
constexpr uint32_t BLOCK_DIM = 40;
constexpr uint32_t TILINGDATA_SIZE = 30;
constexpr uint32_t WORKSPACE_SIZE = 1024;

static bool CompareResult(const void* outputData, int64_t outSize, std::string goldenName)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden_output_" + goldenName + ".bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden_output_%s.bin success!\n", goldenName.c_str());
    } else {
        printf("test failed!\n");
        return false;
    }
    constexpr float EPS = 1e-5;
    int64_t wrongNum = 0;

    for (int i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult golden_output_%s.bin failed output is %lf, golden is %lf\n", goldenName.c_str(), a,
                   b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    if (wrongNum != 0) {
        return false;
    } else {
        printf("CompareResult golden_output_%s.bin success!\n", goldenName.c_str());
        return true;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    uint32_t blockDim = BLOCK_DIM;
    size_t workspaceSize = WORKSPACE_SIZE * sizeof(float);
    size_t xSize = ALENGTH * RLENGTH_WITH_PAD * sizeof(float);
    size_t gammaSize = RLENGTH_WITH_PAD * sizeof(float);
    size_t betaSize = RLENGTH_WITH_PAD * sizeof(float);
    size_t outputSize = ALENGTH * RLENGTH_WITH_PAD * sizeof(float);
    size_t meanSize = ALENGTH * sizeof(float);
    size_t rstdSize = ALENGTH * sizeof(float);
    size_t tilingFileSize = TILINGDATA_SIZE * sizeof(uint32_t);
    bool goldenResult = true;
    uint8_t* tilingBuf = GenerateTiling(ALENGTH, RLENGTH, RLENGTH_WITH_PAD);

    aclInit(nullptr);
    aclrtContext context;
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtCreateContext(&context, deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *inputXHost, *gammaHost, *betaHost, *resultHost, *meanHost, *rstdHost, *workspaceHost, *tilingHost;
    uint8_t *inputXDevice, *gammaDevice, *betaDevice, *resultDevice, *meanDevice, *rstdDevice, *workspaceDevice,
        *tilingDevice;

    aclrtMallocHost((void**)(&inputXHost), xSize);
    aclrtMallocHost((void**)(&gammaHost), gammaSize);
    aclrtMallocHost((void**)(&betaHost), betaSize);
    aclrtMallocHost((void**)(&resultHost), outputSize);
    aclrtMallocHost((void**)(&meanHost), meanSize);
    aclrtMallocHost((void**)(&rstdHost), rstdSize);
    aclrtMallocHost((void**)(&workspaceHost), workspaceSize);
    aclrtMallocHost((void**)(&tilingHost), tilingFileSize);
    aclrtMalloc((void**)&inputXDevice, xSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&gammaDevice, gammaSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&betaDevice, betaSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&resultDevice, outputSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&meanDevice, meanSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&rstdDevice, rstdSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&workspaceDevice, workspaceSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&tilingDevice, tilingFileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/input_inputX.bin", xSize, inputXHost, xSize);
    ReadFile("./input/input_gamma.bin", gammaSize, gammaHost, gammaSize);
    ReadFile("./input/input_beta.bin", betaSize, betaHost, betaSize);

    aclrtMemcpy(workspaceDevice, workspaceSize, workspaceHost, workspaceSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(tilingDevice, tilingFileSize, tilingBuf, tilingFileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    aclrtMemcpy(inputXDevice, xSize, inputXHost, xSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(gammaDevice, gammaSize, gammaHost, gammaSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(betaDevice, betaSize, betaHost, betaSize, ACL_MEMCPY_HOST_TO_DEVICE);

    layernorm_custom<<<blockDim, nullptr, stream>>>(inputXDevice, gammaDevice, betaDevice, resultDevice, meanDevice,
                                                    rstdDevice, workspaceDevice, tilingDevice);
    aclrtSynchronizeStream(stream);
    aclrtMemcpy(resultHost, outputSize, resultDevice, outputSize, ACL_MEMCPY_DEVICE_TO_HOST);
    aclrtMemcpy(meanHost, meanSize, meanDevice, meanSize, ACL_MEMCPY_DEVICE_TO_HOST);

    aclrtMemcpy(rstdHost, rstdSize, rstdDevice, rstdSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output_result.bin", resultHost, outputSize);
    WriteFile("./output/output_mean.bin", meanHost, meanSize);
    WriteFile("./output/output_rstd.bin", rstdHost, rstdSize);

    goldenResult &= CompareResult(resultHost, outputSize, "result");
    goldenResult &= CompareResult(meanHost, meanSize, "mean");
    goldenResult &= CompareResult(rstdHost, rstdSize, "rstd");

    aclrtFree(inputXDevice);
    aclrtFree(gammaDevice);
    aclrtFree(betaDevice);
    aclrtFree(resultDevice);
    aclrtFree(meanDevice);
    aclrtFree(rstdDevice);
    aclrtFree(workspaceDevice);
    aclrtFree(tilingDevice);
    aclrtFreeHost(inputXHost);
    aclrtFreeHost(gammaHost);
    aclrtFreeHost(betaHost);
    aclrtFreeHost(resultHost);
    aclrtFreeHost(meanHost);
    aclrtFreeHost(rstdHost);
    aclrtFreeHost(workspaceHost);
    aclrtFreeHost(tilingHost);

    aclrtDestroyStream(stream);
    aclrtDestroyContext(context);
    aclrtResetDevice(deviceId);
    aclFinalize();

    free(tilingBuf);
    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }
    return 0;
}