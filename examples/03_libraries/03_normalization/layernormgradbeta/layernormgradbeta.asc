/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file layernormgradbeta.asc
 * \brief
 */

#include "acl/acl.h"
#include "data_utils.h"
#include "kernel_operator.h"
#include "tiling/tiling_api.h"

namespace AscendC {
__aicore__ inline void GetLayerNormGradBetaNDTilingInfo(const ShapeInfo info, const uint32_t stackBufferSize,
                                                        const uint32_t typeSize, const bool isReuseSource,
                                                        LayerNormGradBetaTiling& tiling)
{
    uint32_t bLength = info.shape[0];
    uint32_t sLength = info.shape[1];
    uint32_t hLength = info.shape[2];
    uint32_t originalHLength = info.originalShape[2];

    if ((tiling.bLength == bLength) && (tiling.sLength == sLength) && (tiling.hLength == hLength)
        && (tiling.originalHLength == originalHLength)) {
        return;
    }

    tiling.bLength = bLength;
    tiling.sLength = sLength;
    tiling.hLength = hLength;
    tiling.originalHLength = originalHLength;

    tiling.bshLength = tiling.bLength * tiling.sLength * tiling.hLength;
    tiling.bsLength = tiling.bLength * tiling.sLength;

    tiling.stackBufferSize = stackBufferSize / sizeof(float);

    tiling.oneCalSize = tiling.stackBufferSize;
    if (typeSize == B16_BYTE_SIZE) {
        tiling.numberOfTmpBuf = TWO_OF_STACK_BUFFER;
        tiling.oneCalSize = tiling.oneCalSize - tiling.hLength - tiling.hLength;
        tiling.oneCalSize = tiling.oneCalSize / tiling.numberOfTmpBuf;
    }

    tiling.oneCalSize = tiling.oneCalSize / tiling.hLength * tiling.hLength;

    if (tiling.oneCalSize == 0) {
        return;
    }

    if (tiling.oneCalSize >= tiling.bshLength) {
        tiling.oneCalSize = tiling.bshLength;
    }

    tiling.loopRound = tiling.bshLength / tiling.oneCalSize;
    tiling.inputTailSize = tiling.bshLength % tiling.oneCalSize;

    tiling.inputTailPos = tiling.bshLength - tiling.inputTailSize;
    tiling.bsTailSize = tiling.inputTailSize / tiling.hLength;

    tiling.bshCurLength = tiling.oneCalSize;
    tiling.bsCurLength = tiling.oneCalSize / tiling.hLength;

    tiling.resForGammaTmpTensorPos = 0;

    if (typeSize == B16_BYTE_SIZE) {
        tiling.gammaTempTensorPos = 0;
        tiling.betaTempTensorPos = tiling.gammaTempTensorPos + tiling.hLength;
        tiling.inputDyTmpTensorPos = tiling.betaTempTensorPos + tiling.hLength;
        tiling.resForGammaTmpTensorPos = tiling.inputDyTmpTensorPos + tiling.oneCalSize;
    }
}

template <typename T, bool isReuseSource = false>
class KernelLayernormGradBeta {
public:
    __aicore__ inline KernelLayernormGradBeta() {}
    __aicore__ inline void Init(__gm__ uint8_t* resForGammaGm, __gm__ uint8_t* inputDyGm,
                                __gm__ uint8_t* outputPdGammaGm, __gm__ uint8_t* outputPdBetaGm, uint32_t bLength,
                                uint32_t sLength, uint32_t hLength, DataFormat dataFormat, AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;
        this->bLength = bLength;
        this->sLength = sLength;
        this->hLength = hLength;
        this->dataFormat = dataFormat;

        bshLength = bLength * sLength * hLength;
        bsLength = bLength * sLength;

        resForGammaGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(resForGammaGm), bshLength);
        inputDyGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(inputDyGm), bshLength);

        outputPdGammaGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(outputPdGammaGm), hLength);
        outputPdBetaGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(outputPdBetaGm), hLength);

        pipe->InitBuffer(inQueueResForGamma, 1, sizeof(T) * bshLength);
        pipe->InitBuffer(inQueueDy, 1, sizeof(T) * bshLength);

        pipe->InitBuffer(outQueuePdGamma, 1, sizeof(T) * hLength);
        pipe->InitBuffer(outQueuePdBeta, 1, sizeof(T) * hLength);

        LocalTensor<uint8_t> stackBuffer;
        bool ans = PopStackBuffer<uint8_t, TPosition::LCM>(stackBuffer);
        stackBufferSize = stackBuffer.GetSize();
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        Compute();
        CopyOut();
    }

private:
    __aicore__ inline void CopyIn()
    {
        LocalTensor<T> resForGammaLocal = inQueueResForGamma.AllocTensor<T>();
        LocalTensor<T> inputDyLocal = inQueueDy.AllocTensor<T>();

        DataCopy(resForGammaLocal, resForGammaGlobal, bshLength);
        DataCopy(inputDyLocal, inputDyGlobal, bshLength);

        inQueueResForGamma.EnQue(resForGammaLocal);
        inQueueDy.EnQue(inputDyLocal);
    }
    __aicore__ inline void Compute()
    {
        LocalTensor<T> resForGammaLocal = inQueueResForGamma.DeQue<T>();
        LocalTensor<T> inputDyLocal = inQueueDy.DeQue<T>();
        LocalTensor<T> outputPdGammaLocal = outQueuePdGamma.AllocTensor<T>();
        LocalTensor<T> outputPdBetaLocal = outQueuePdBeta.AllocTensor<T>();

        uint32_t inputShape3[3] = {bLength, sLength, hLength};
        ShapeInfo shapeInfo3{3, inputShape3, 3, inputShape3, dataFormat};

        LayerNormGradBetaTiling layerNormGradBetaTiling;
        GetLayerNormGradBetaNDTilingInfo(shapeInfo3, stackBufferSize, sizeof(T), isReuseSource,
                                         layerNormGradBetaTiling);

        LayerNormGradBeta<T, isReuseSource>(outputPdGammaLocal, outputPdBetaLocal, resForGammaLocal, inputDyLocal,
                                            layerNormGradBetaTiling);

        outQueuePdGamma.EnQue<T>(outputPdGammaLocal);
        outQueuePdBeta.EnQue<T>(outputPdBetaLocal);

        inQueueResForGamma.FreeTensor(resForGammaLocal);
        inQueueDy.FreeTensor(inputDyLocal);
    }
    __aicore__ inline void CopyOut()
    {
        LocalTensor<T> outputPdGammaLocal = outQueuePdGamma.DeQue<T>();
        LocalTensor<T> outputPdBetaLocal = outQueuePdBeta.DeQue<T>();

        DataCopy(outputPdGammaGlobal, outputPdGammaLocal, hLength);
        DataCopy(outputPdBetaGlobal, outputPdBetaLocal, hLength);

        outQueuePdGamma.FreeTensor(outputPdGammaLocal);
        outQueuePdBeta.FreeTensor(outputPdBetaLocal);
    }

private:
    TPipe* pipe;
    TQue<QuePosition::VECIN, 1> inQueueResForGamma;
    TQue<QuePosition::VECIN, 1> inQueueDy;
    TQue<QuePosition::VECOUT, 1> outQueuePdGamma;
    TQue<QuePosition::VECOUT, 1> outQueuePdBeta;

    GlobalTensor<T> resForGammaGlobal;
    GlobalTensor<T> inputDyGlobal;
    GlobalTensor<T> outputPdGammaGlobal;
    GlobalTensor<T> outputPdBetaGlobal;

    uint32_t bLength;
    uint32_t sLength;
    uint32_t hLength;
    DataFormat dataFormat;

    uint32_t bshLength;
    uint32_t bsLength;

    uint32_t stackBufferSize = 0;
};
} // namespace AscendC

__global__ __vector__ void layernormgradbeta_custom(GM_ADDR outputPdGamma_gm, GM_ADDR outputPdBeta_gm,
                                                    GM_ADDR inputDy_gm, GM_ADDR resForGamma_gm)
{
    AscendC::TPipe pipe;
    constexpr uint32_t bLength = 4;
    constexpr uint32_t sLength = 8;
    constexpr uint32_t hLength = 512;
    AscendC::KernelLayernormGradBeta<float, false> op;
    op.Init(resForGamma_gm, inputDy_gm, outputPdGamma_gm, outputPdBeta_gm, bLength, sLength, hLength,
            AscendC::DataFormat::ND, &pipe);
    op.Process();
}

static bool CompareResult(const void* outputData, int64_t outSize, std::string goldenName)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden_output_" + goldenName + ".bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden_output_%s.bin success!\n", goldenName.c_str());
    } else {
        aclrtFreeHost(goldenData);
        return false;
    }
    constexpr float EPS = 1e-5;
    int64_t wrongNum = 0;

    for (int i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult golden_output_%s.bin failed output is %lf, golden is %lf\n", goldenName.c_str(), a,
                   b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    if (wrongNum != 0) {
        return false;
    } else {
        printf("CompareResult golden_output_%s.bin success!\n", goldenName.c_str());
        return true;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    size_t param1FileSize = 512 * sizeof(float);
    size_t param2FileSize = 512 * sizeof(float);
    size_t param3FileSize = 16384 * sizeof(float);
    size_t param4FileSize = 16384 * sizeof(float);
    uint32_t numBlocks = 1;

    aclInit(nullptr);
    aclrtContext context;
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtCreateContext(&context, deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t* param1Host;
    uint8_t* param1Device;
    aclrtMallocHost((void**)(&param1Host), param1FileSize);
    aclrtMalloc((void**)&param1Device, param1FileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    uint8_t* param2Host;
    uint8_t* param2Device;
    aclrtMallocHost((void**)(&param2Host), param2FileSize);
    aclrtMalloc((void**)&param2Device, param2FileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    uint8_t* param3Host;
    uint8_t* param3Device;
    aclrtMallocHost((void**)(&param3Host), param3FileSize);
    aclrtMalloc((void**)&param3Device, param3FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_inputDy.bin", param3FileSize, param3Host, param3FileSize);
    aclrtMemcpy(param3Device, param3FileSize, param3Host, param3FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param4Host;
    uint8_t* param4Device;
    aclrtMallocHost((void**)(&param4Host), param4FileSize);
    aclrtMalloc((void**)&param4Device, param4FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_resForGamma.bin", param4FileSize, param4Host, param4FileSize);
    aclrtMemcpy(param4Device, param4FileSize, param4Host, param4FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    layernormgradbeta_custom<<<numBlocks, nullptr, stream>>>(param1Device, param2Device, param3Device, param4Device);
    aclrtSynchronizeStream(stream);

    aclrtFree(param3Device);
    aclrtFreeHost(param3Host);
    aclrtFree(param4Device);
    aclrtFreeHost(param4Host);

    aclrtMemcpy(param1Host, param1FileSize, param1Device, param1FileSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output_PdGamma.bin", param1Host, param1FileSize);
    aclrtFree(param1Device);
    aclrtFreeHost(param1Host);

    aclrtMemcpy(param2Host, param2FileSize, param2Device, param2FileSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output_PdBeta.bin", param2Host, param2FileSize);
    aclrtFree(param2Device);
    aclrtFreeHost(param2Host);

    bool goldenResult = true;
    goldenResult &= CompareResult(param1Host, param1FileSize, "PdGamma");
    goldenResult &= CompareResult(param2Host, param2FileSize, "PdBeta");
    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }

    aclrtDestroyStream(stream);
    aclrtDestroyContext(context);
    aclrtResetDevice(deviceId);
    aclFinalize();

    return 0;
}