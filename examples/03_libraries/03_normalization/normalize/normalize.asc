/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file addcdiv_custom.asc
 * \brief
 */

#include "acl/acl.h"
#include "data_utils.h"
#include "kernel_operator.h"
#include "tiling/tiling_api.h"

namespace optiling {
BEGIN_TILING_DATA_DEF(NormalizeCustomTilingData)
TILING_DATA_FIELD_DEF(uint32_t, aLength);
TILING_DATA_FIELD_DEF(uint32_t, rLength);
TILING_DATA_FIELD_DEF(uint32_t, rLengthWithPadding);
TILING_DATA_FIELD_DEF(uint32_t, tmpLocalSize);
END_TILING_DATA_DEF;
REGISTER_TILING_DATA_CLASS(NormalizeCustom, NormalizeCustomTilingData)
} // namespace optiling

void ComputeTiling(uint32_t aLength, uint32_t rLength, uint32_t rLengthWithPadding,
                   optiling::NormalizeCustomTilingData& tiling)
{
    std::vector<int64_t> shapeVec = {aLength, rLengthWithPadding};
    ge::Shape srcShape(shapeVec);
    uint32_t maxsize = 0;
    uint32_t minsize = 0;
    uint32_t dtypesizeT = 4; // float
    uint32_t dtypesizeU = 4; // float

    tiling.set_aLength(aLength);
    tiling.set_rLength(rLength);
    tiling.set_rLengthWithPadding(rLengthWithPadding);

    AscendC::GetNormalizeMaxMinTmpSize(srcShape, dtypesizeU, dtypesizeT, false, true, false, maxsize, minsize);
    tiling.set_tmpLocalSize(minsize);
}

uint8_t* GetTilingBuf(optiling::NormalizeCustomTilingData* tilingData)
{
    uint32_t tilingSize = sizeof(optiling::NormalizeCustomTilingData);
    uint8_t* buf = (uint8_t*)malloc(tilingSize);
    tilingData->SaveToBuffer(buf, tilingSize);
    return buf;
}
uint8_t* GenerateTiling(uint32_t aLength, uint32_t rLength, uint32_t rLengthWithPadding)
{
    optiling::NormalizeCustomTilingData tiling;
    ComputeTiling(aLength, rLength, rLengthWithPadding, tiling);
    return GetTilingBuf(&tiling);
}

namespace NormalizeCustomKernel {
struct NormalizeTiling {
    uint32_t aLength;
    uint32_t rLength;
    uint32_t rLengthWithPadding;
    uint32_t tmpLocalSize;
};

constexpr uint8_t LOCAL_BYTES = 32;

template <typename T, typename U, bool isReuseSource = false>
class KernelNormalize {
public:
    __aicore__ inline KernelNormalize() {}
    __aicore__ inline void Init(GM_ADDR inputXGm, GM_ADDR inputMeanGm, GM_ADDR inputVarGm, GM_ADDR gammaGm,
                                GM_ADDR betaGm, GM_ADDR outputGm, GM_ADDR outputRstdGm, NormalizeTiling tilingData,
                                AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;
        aLength = tilingData.aLength;
        rLength = tilingData.rLength;
        rLengthWithPadding = tilingData.rLengthWithPadding;
        tmpLocalBytes = tilingData.tmpLocalSize;
        uint32_t totalLength = aLength * rLengthWithPadding;
        inputX_global.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(inputXGm), totalLength);               // [A, R]
        inputMean_global.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(inputMeanGm), aLength);         // [A]
        inputVar_global.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(inputVarGm), aLength);           // [A]
        inputGamma_global.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(gammaGm), rLengthWithPadding); // [R]
        inputBeta_global.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(betaGm), rLengthWithPadding);   // [R]

        output_global.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(outputGm), totalLength);
        outputRstd_global.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(outputRstdGm), aLength);

        pipe->InitBuffer(inQueueX, 1, sizeof(T) * totalLength);
        pipe->InitBuffer(inQueueMean, 1, sizeof(float) * aLength);
        pipe->InitBuffer(inQueueVar, 1, sizeof(float) * aLength);
        pipe->InitBuffer(inQueueGamma, 1, sizeof(float) * rLengthWithPadding);
        pipe->InitBuffer(inQueueBeta, 1, sizeof(float) * rLengthWithPadding);

        pipe->InitBuffer(outQueue, 1, sizeof(T) * totalLength);
        pipe->InitBuffer(outQueueRstd, 1, sizeof(float) * aLength);
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        Compute();
        CopyOut();
    }

private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<T> inputXLocal = inQueueX.AllocTensor<T>();
        AscendC::LocalTensor<T> inMeanLocal = inQueueMean.AllocTensor<float>();
        AscendC::LocalTensor<T> inVarLocal = inQueueVar.AllocTensor<float>();
        AscendC::LocalTensor<U> inGammaLocal = inQueueGamma.AllocTensor<U>();
        AscendC::LocalTensor<U> inBetaLocal = inQueueBeta.AllocTensor<U>();

        AscendC::DataCopy(inputXLocal, inputX_global, aLength * rLengthWithPadding);
        AscendC::DataCopy(inMeanLocal, inputMean_global, aLength);
        AscendC::DataCopy(inVarLocal, inputVar_global, aLength);
        AscendC::DataCopy(inGammaLocal, inputGamma_global, rLengthWithPadding);
        AscendC::DataCopy(inBetaLocal, inputBeta_global, rLengthWithPadding);

        inQueueX.EnQue(inputXLocal);
        inQueueMean.EnQue(inMeanLocal);
        inQueueVar.EnQue(inVarLocal);
        inQueueGamma.EnQue(inGammaLocal);
        inQueueBeta.EnQue(inBetaLocal);
    }

    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<T> inputXLocal = inQueueX.DeQue<T>();
        AscendC::LocalTensor<float> inputMeanLocal = inQueueMean.DeQue<float>();
        AscendC::LocalTensor<float> inputVarLocal = inQueueVar.DeQue<float>();
        AscendC::LocalTensor<U> inputGammaLocal = inQueueGamma.DeQue<U>();
        AscendC::LocalTensor<U> inputBetaLocal = inQueueBeta.DeQue<U>();

        AscendC::LocalTensor<T> outLocal = outQueue.AllocTensor<T>();
        AscendC::LocalTensor<float> outRstdLocal = outQueueRstd.AllocTensor<float>();

        float epsilon = 0.001;
        AscendC::NormalizePara para = {aLength, rLength, rLengthWithPadding};
        static constexpr AscendC::NormalizeConfig config = AscendC::GetNormalizeConfig(false, false);
        AscendC::LocalTensor<uint8_t> sharedTmpBuffer;
        bool ans = AscendC::PopStackBuffer<uint8_t, AscendC::TPosition::LCM>(sharedTmpBuffer);
        sharedTmpBuffer.SetSize(tmpLocalBytes);
        AscendC::Normalize<U, T, false, config>(outLocal, outRstdLocal, inputMeanLocal, inputVarLocal, inputXLocal,
                                                inputGammaLocal, inputBetaLocal, sharedTmpBuffer, epsilon, para);

        outQueue.EnQue(outLocal);
        outQueueRstd.EnQue(outRstdLocal);
        inQueueX.FreeTensor(inputXLocal);
        inQueueMean.FreeTensor(inputMeanLocal);
        inQueueVar.FreeTensor(inputVarLocal);
        inQueueGamma.FreeTensor(inputGammaLocal);
        inQueueBeta.FreeTensor(inputBetaLocal);
    }
    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<U> outLocal = outQueue.DeQue<T>();
        AscendC::LocalTensor<U> outRstdLocal = outQueueRstd.DeQue<float>();

        AscendC::DataCopy(output_global, outLocal, aLength * rLengthWithPadding);
        AscendC::DataCopy(outputRstd_global, outRstdLocal, aLength);

        outQueue.FreeTensor(outLocal);
        outQueueRstd.FreeTensor(outRstdLocal);
    }

private:
    AscendC::TPipe* pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueMean;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueVar;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueGamma;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueBeta;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueue;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueueRstd;

    AscendC::GlobalTensor<T> inputX_global;
    AscendC::GlobalTensor<float> inputMean_global;
    AscendC::GlobalTensor<float> inputVar_global;
    AscendC::GlobalTensor<U> inputGamma_global;
    AscendC::GlobalTensor<U> inputBeta_global;
    AscendC::GlobalTensor<T> output_global;
    AscendC::GlobalTensor<float> outputRstd_global;

    uint32_t tmpLocalBytes = 0;
    uint32_t aLength;
    uint32_t rLength;
    uint32_t rLengthWithPadding;
};

} // namespace NormalizeCustomKernel

__aicore__ inline void CopyTiling(NormalizeCustomKernel::NormalizeTiling* tiling, GM_ADDR tilingGM)
{
    uint32_t* ptr = reinterpret_cast<uint32_t*>(tiling);
    auto tiling32 = reinterpret_cast<__gm__ uint32_t*>(tilingGM);

    for (uint32_t i = 0; i < sizeof(NormalizeCustomKernel::NormalizeTiling) / sizeof(uint32_t); i++, ptr++) {
        *ptr = *(tiling32 + i);
    }
    return;
}

extern "C" __global__ __vector__ void normalize_custom(GM_ADDR srcGm, GM_ADDR inMeanGm, GM_ADDR inVarGm,
                                                       GM_ADDR inGammaGm, GM_ADDR inBetaGm, GM_ADDR outGm,
                                                       GM_ADDR outRstdGm, GM_ADDR workspace, GM_ADDR tiling)
{
    AscendC::TPipe pipe;
    NormalizeCustomKernel::KernelNormalize<float, float, false> op;
    NormalizeCustomKernel::NormalizeTiling tilingData;
    CopyTiling(&tilingData, tiling);
    op.Init(srcGm, inMeanGm, inVarGm, inGammaGm, inBetaGm, outGm, outRstdGm, tilingData, &pipe);
    op.Process();
}

constexpr uint8_t NUM_BLOCKS = 1;
constexpr uint32_t TILINGDATA_SIZE = 6;
constexpr uint32_t WORKSPACE_SIZE = 1024 * 1024;

constexpr uint32_t A_SIZE = 8;
constexpr uint32_t R_SIZE = 64;
constexpr uint32_t R_SIZE_WITH_PAD = 64;

static bool CompareResult(const void* outputData, int64_t outSize, std::string goldenName)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden_" + goldenName + ".bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden_%s.bin success!\n", goldenName.c_str());
    } else {
        printf("test failed!\n");
        return false;
    }
    constexpr float EPS = 1e-4;
    int64_t wrongNum = 0;

    for (int i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult golden_%s.bin failed output is %lf, golden is %lf\n", goldenName.c_str(), a, b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    if (wrongNum != 0) {
        return false;
    } else {
        printf("CompareResult golden_%s.bin success!\n", goldenName.c_str());
        return true;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    uint32_t numBlocks = NUM_BLOCKS;
    size_t inputSrcSize = A_SIZE * R_SIZE_WITH_PAD * sizeof(float);
    size_t inputMeanSize = A_SIZE * sizeof(float);
    size_t inputVarSize = A_SIZE * sizeof(float);
    size_t inputGammaSize = R_SIZE_WITH_PAD * sizeof(float);
    size_t inputBetaSize = R_SIZE_WITH_PAD * sizeof(float);
    size_t outputSize = A_SIZE * R_SIZE_WITH_PAD * sizeof(float);
    size_t outputRstdSize = A_SIZE * sizeof(float);

    size_t workspaceSize = WORKSPACE_SIZE;
    size_t tilingFileSize = TILINGDATA_SIZE * sizeof(uint32_t);
    uint8_t* tilingBuf = GenerateTiling(A_SIZE, R_SIZE, R_SIZE_WITH_PAD);

    aclInit(nullptr);
    aclrtContext context;
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtCreateContext(&context, deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *srcHost, *inMeanHost, *inVarHost, *inGammaHost, *inBetaHost, *outHost, *outRstdHost, *workspaceHost;
    uint8_t *srcDevice, *inMeanDevice, *inVarDevice, *inGammaDevice, *inBetaDevice, *outDevice, *outRstdDevice,
        *workspaceDevice, *tilingDevice;

    aclrtMallocHost((void**)(&srcHost), inputSrcSize);
    aclrtMallocHost((void**)(&inMeanHost), inputMeanSize);
    aclrtMallocHost((void**)(&inVarHost), inputVarSize);
    aclrtMallocHost((void**)(&inGammaHost), inputGammaSize);
    aclrtMallocHost((void**)(&inBetaHost), inputBetaSize);
    aclrtMallocHost((void**)(&outHost), outputSize);
    aclrtMallocHost((void**)(&outRstdHost), outputRstdSize);
    aclrtMallocHost((void**)(&workspaceHost), workspaceSize);

    aclrtMalloc((void**)&srcDevice, inputSrcSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&inMeanDevice, inputMeanSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&inVarDevice, inputVarSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&inGammaDevice, inputGammaSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&inBetaDevice, inputBetaSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&outDevice, outputSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&outRstdDevice, outputRstdSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&workspaceDevice, workspaceSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&tilingDevice, tilingFileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/input_srcGm.bin", inputSrcSize, srcHost, inputSrcSize);
    ReadFile("./input/input_inMeanGm.bin", inputMeanSize, inMeanHost, inputMeanSize);
    ReadFile("./input/input_inVarGm.bin", inputVarSize, inVarHost, inputVarSize);
    ReadFile("./input/input_inGammaGm.bin", inputGammaSize, inGammaHost, inputGammaSize);
    ReadFile("./input/input_inBetaGm.bin", inputBetaSize, inBetaHost, inputBetaSize);

    aclrtMemcpy(workspaceDevice, workspaceSize, workspaceHost, workspaceSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(tilingDevice, tilingFileSize, tilingBuf, tilingFileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    aclrtMemcpy(srcDevice, inputSrcSize, srcHost, inputSrcSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inMeanDevice, inputMeanSize, inMeanHost, inputMeanSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inVarDevice, inputVarSize, inVarHost, inputVarSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inGammaDevice, inputGammaSize, inGammaHost, inputGammaSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inBetaDevice, inputBetaSize, inBetaHost, inputBetaSize, ACL_MEMCPY_HOST_TO_DEVICE);

    normalize_custom<<<numBlocks, nullptr, stream>>>(srcDevice, inMeanDevice, inVarDevice, inGammaDevice, inBetaDevice,
                                                    outDevice, outRstdDevice, workspaceDevice, tilingDevice);

    aclrtSynchronizeStream(stream);

    aclrtMemcpy(outHost, outputSize, outDevice, outputSize, ACL_MEMCPY_DEVICE_TO_HOST);
    aclrtMemcpy(outRstdHost, outputRstdSize, outRstdDevice, outputRstdSize, ACL_MEMCPY_DEVICE_TO_HOST);

    WriteFile("./output/output_outGm.bin", outHost, outputSize);
    WriteFile("./output/output_outRstdGm.bin", outRstdHost, outputRstdSize);

    bool goldenResult = true;
    goldenResult &= CompareResult(outHost, outputSize, "outGm");
    goldenResult &= CompareResult(outRstdHost, outputRstdSize, "outRstdGm");
    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }

    aclrtFree(srcDevice);
    aclrtFree(inMeanDevice);
    aclrtFree(inVarDevice);
    aclrtFree(inGammaDevice);
    aclrtFree(inBetaDevice);
    aclrtFree(outDevice);
    aclrtFree(outRstdDevice);
    aclrtFree(workspaceDevice);
    aclrtFree(tilingDevice);

    aclrtFreeHost(srcHost);
    aclrtFreeHost(inMeanHost);
    aclrtFreeHost(inVarHost);
    aclrtFreeHost(inGammaHost);
    aclrtFreeHost(inBetaHost);
    aclrtFreeHost(outHost);
    aclrtFreeHost(outRstdHost);
    aclrtFreeHost(workspaceHost);

    aclrtDestroyStream(stream);
    aclrtDestroyContext(context);
    aclrtResetDevice(deviceId);
    aclFinalize();
    free(tilingBuf);
    return 0;
}