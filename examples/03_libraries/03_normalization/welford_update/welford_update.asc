/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file welford_update.asc
 * \brief
 */

#include "acl/acl.h"
#include "data_utils.h"
#include "kernel_operator.h"
#include "tiling/tiling_api.h"

namespace optiling {
BEGIN_TILING_DATA_DEF(WelfordUpdateCustomTilingData)
TILING_DATA_FIELD_DEF(bool, inplace);
TILING_DATA_FIELD_DEF(uint32_t, nLength);
TILING_DATA_FIELD_DEF(uint32_t, rLength);
TILING_DATA_FIELD_DEF(uint32_t, abComputeLength);
TILING_DATA_FIELD_DEF(float, nRec);
TILING_DATA_FIELD_DEF(uint32_t, tmpLocalSize);
END_TILING_DATA_DEF;
REGISTER_TILING_DATA_CLASS(WelfordUpdateCustom, WelfordUpdateCustomTilingData)
} // namespace optiling

constexpr bool ISREUSESOURCE = false;
constexpr bool ISINPLACE = true;

void ComputeTiling(bool inplace, uint32_t nLength, uint32_t rLength, uint32_t abComputeLength, float nRec,
                   optiling::WelfordUpdateCustomTilingData& tiling)
{
    std::vector<int64_t> shapeVec = {nLength, rLength};
    ge::Shape srcShape(shapeVec);
    uint32_t maxsize = 0;
    uint32_t minsize = 0;
    uint32_t dtypesizeT = 2; // half type
    uint32_t dtypesizeU = 4; // float type

    tiling.set_inplace(inplace);
    tiling.set_nLength(nLength);
    tiling.set_rLength(rLength);
    tiling.set_abComputeLength(abComputeLength);
    tiling.set_nRec(nRec);

    AscendC::GetWelfordUpdateMaxMinTmpSize(srcShape, dtypesizeT, dtypesizeU, ISREUSESOURCE, ISINPLACE, maxsize,
                                           minsize);
    tiling.set_tmpLocalSize(minsize);
}

uint8_t* GetTilingBuf(optiling::WelfordUpdateCustomTilingData* tilingData)
{
    uint32_t tilingSize = sizeof(optiling::WelfordUpdateCustomTilingData);
    uint8_t* buf = (uint8_t*)malloc(tilingSize);
    tilingData->SaveToBuffer(buf, tilingSize);
    return buf;
}
uint8_t* GenerateTiling(bool inplace, uint32_t nLength, uint32_t rLength, uint32_t abComputeLength, float nRec)
{
    optiling::WelfordUpdateCustomTilingData tiling;
    ComputeTiling(inplace, nLength, rLength, abComputeLength, nRec, tiling);
    return GetTilingBuf(&tiling);
}

namespace MyCustomKernel {
struct VecTiling {
    bool inplace;
    uint32_t nLength;
    uint32_t rLength;
    uint32_t abComputeLength;
    float nRec;
    uint32_t tmpLocalSize;
};

constexpr uint8_t LOCAL_BYTES = 32;

template <typename T, typename U, bool isReuseSource = false, bool tmpLocal = true>
class KernelWelfordUpdate {
public:
    __aicore__ inline KernelWelfordUpdate() {}
    __aicore__ inline void Init(GM_ADDR inputXGm, GM_ADDR inputMeanGm, GM_ADDR inputVarGm, GM_ADDR outputMeanGm,
                                GM_ADDR outputVarGm, VecTiling tilingData, AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;
        nLength = tilingData.nLength;
        rLength = tilingData.rLength;
        abComputeLength = tilingData.abComputeLength;
        nRec = tilingData.nRec;
        bshLength = tilingData.nLength * tilingData.rLength;
        inplace = tilingData.inplace;
        tmpLocalBytes = tilingData.tmpLocalSize;

        inputX_global.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(inputXGm), bshLength);
        inputMean_global.SetGlobalBuffer(reinterpret_cast<__gm__ U*>(inputMeanGm), bshLength);
        inputVar_global.SetGlobalBuffer(reinterpret_cast<__gm__ U*>(inputVarGm), bshLength);

        outputMean_global.SetGlobalBuffer(reinterpret_cast<__gm__ U*>(outputMeanGm), bshLength);
        outputVar_global.SetGlobalBuffer(reinterpret_cast<__gm__ U*>(outputVarGm), bshLength);

        pipe->InitBuffer(inQueueX, 1, sizeof(T) * bshLength);
        pipe->InitBuffer(inQueueMean, 1, sizeof(U) * bshLength);
        pipe->InitBuffer(inQueueVar, 1, sizeof(U) * bshLength);
        pipe->InitBuffer(outQueueMean, 1, sizeof(U) * bshLength);
        pipe->InitBuffer(outQueueVar, 1, sizeof(U) * bshLength);
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        Compute();
        CopyOut();
    }

private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<T> inputXLocal = inQueueX.AllocTensor<T>();
        AscendC::LocalTensor<U> inMeanLocal = inQueueMean.AllocTensor<U>();
        AscendC::LocalTensor<U> inVarLocal = inQueueVar.AllocTensor<U>();

        AscendC::DataCopy(inputXLocal, inputX_global, bshLength);
        AscendC::DataCopy(inMeanLocal, inputMean_global, bshLength);
        AscendC::DataCopy(inVarLocal, inputVar_global, bshLength);

        inQueueX.EnQue(inputXLocal);
        inQueueMean.EnQue(inMeanLocal);
        inQueueVar.EnQue(inVarLocal);
    }
    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<T> inputXLocal = inQueueX.DeQue<T>();
        AscendC::LocalTensor<U> inMeanLocal = inQueueMean.DeQue<U>();
        AscendC::LocalTensor<U> inVarLocal = inQueueVar.DeQue<U>();

        AscendC::LocalTensor<U> outMeanLocal = outQueueMean.AllocTensor<U>();
        AscendC::LocalTensor<U> outVarLocal = outQueueVar.AllocTensor<U>();
        static constexpr AscendC::WelfordUpdateConfig WELFORD_UPDATE_ENABLE_INPLACE_CFG = {true};
        static constexpr AscendC::WelfordUpdateConfig WELFORD_UPDATE_UNENABLE_INPLACE_CFG = {false};
        struct AscendC::WelfordUpdateParam para = {nLength, rLength, abComputeLength, nRec};
        if (!tmpLocal) {
            if (inplace) {
                AscendC::WelfordUpdate<T, U, isReuseSource, WELFORD_UPDATE_ENABLE_INPLACE_CFG>(
                    outMeanLocal, outVarLocal, inMeanLocal, inVarLocal, inputXLocal, para);
            } else {
                AscendC::WelfordUpdate<T, U, isReuseSource, WELFORD_UPDATE_UNENABLE_INPLACE_CFG>(
                    outMeanLocal, outVarLocal, inMeanLocal, inVarLocal, inputXLocal, para);
            }
        } else {
            if (tmpLocalBytes % LOCAL_BYTES != 0) {
                tmpLocalBytes = (tmpLocalBytes + LOCAL_BYTES - 1) / LOCAL_BYTES * LOCAL_BYTES;
            }
            pipe->InitBuffer(tmpLocalBuf, tmpLocalBytes);
            AscendC::LocalTensor<uint8_t> tmpLocalTensor = tmpLocalBuf.Get<uint8_t>();
            if (inplace) {
                AscendC::WelfordUpdate<T, U, isReuseSource, WELFORD_UPDATE_ENABLE_INPLACE_CFG>(
                    outMeanLocal, outVarLocal, inMeanLocal, inVarLocal, inputXLocal, tmpLocalTensor, para);
            } else {
                AscendC::WelfordUpdate<T, U, isReuseSource, WELFORD_UPDATE_UNENABLE_INPLACE_CFG>(
                    outMeanLocal, outVarLocal, inMeanLocal, inVarLocal, inputXLocal, tmpLocalTensor, para);
            }
        }

        inQueueX.FreeTensor(inputXLocal);
        inQueueMean.FreeTensor(inMeanLocal);
        inQueueVar.FreeTensor(inVarLocal);

        outQueueMean.EnQue(outMeanLocal);
        outQueueVar.EnQue(outVarLocal);
    }
    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<U> outMeanLocal = outQueueMean.DeQue<U>();
        AscendC::LocalTensor<U> outVarLocal = outQueueVar.DeQue<U>();

        AscendC::DataCopy(outputMean_global, outMeanLocal, bshLength);
        AscendC::DataCopy(outputVar_global, outVarLocal, bshLength);

        outQueueMean.FreeTensor(outMeanLocal);
        outQueueVar.FreeTensor(outVarLocal);
    }

private:
    AscendC::TPipe* pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueMean;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueVar;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueueMean;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueueVar;

    AscendC::GlobalTensor<T> inputX_global;
    AscendC::GlobalTensor<U> inputMean_global;
    AscendC::GlobalTensor<U> inputVar_global;
    AscendC::GlobalTensor<U> outputMean_global;
    AscendC::GlobalTensor<U> outputVar_global;
    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpLocalBuf;

    uint32_t tmpLocalBytes = 0;
    uint32_t nLength;
    uint32_t rLength;
    uint32_t abComputeLength;
    float nRec;
    uint32_t bshLength;
    bool inplace;
};

} // namespace MyCustomKernel

__aicore__ inline void CopyTiling(MyCustomKernel::VecTiling* tiling, GM_ADDR tilingGM)
{
    uint32_t* ptr = reinterpret_cast<uint32_t*>(tiling);
    auto tiling32 = reinterpret_cast<__gm__ uint32_t*>(tilingGM);

    for (uint32_t i = 0; i < sizeof(MyCustomKernel::VecTiling) / sizeof(uint32_t); i++, ptr++) {
        *ptr = *(tiling32 + i);
    }
    return;
}

extern "C" __global__ __vector__ void welford_update_custom(GM_ADDR srcGm, GM_ADDR inMeanGm, GM_ADDR inVarGm,
                                                            GM_ADDR outMeanGm, GM_ADDR outVarGm, GM_ADDR workspace,
                                                            GM_ADDR tiling)
{
    AscendC::TPipe pipe;
    MyCustomKernel::KernelWelfordUpdate<half, float> op;
    MyCustomKernel::VecTiling tilingData;
    CopyTiling(&tilingData, tiling);
    op.Init(srcGm, inMeanGm, inVarGm, outMeanGm, outVarGm, tilingData, &pipe);
    op.Process();
}

constexpr uint8_t NUM_BLOCKS = 1;
constexpr uint32_t TILINGDATA_SIZE = 6;
constexpr uint32_t WORKSPACE_SIZE = 1024 * 1024;

constexpr uint8_t RN_SIZE = 1;
constexpr uint32_t AB_SIZE = 64;
constexpr uint32_t AB_LENGTH = 35;
constexpr float NREC = 1.0 / 8;

static bool CompareResult(const void* outputData, int64_t outSize, std::string goldenName)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden_" + goldenName + ".bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden_%s.bin success!\n", goldenName.c_str());
    } else {
        printf("test failed!\n");
        return false;
    }
    constexpr float EPS = 1e-4;
    int64_t wrongNum = 0;

    for (int i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult golden_%s.bin failed output is %lf, golden is %lf\n", goldenName.c_str(), a, b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    if (wrongNum != 0) {
        return false;
    } else {
        printf("CompareResult golden_%s.bin success!\n", goldenName.c_str());
        return true;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    uint32_t numBlocks = NUM_BLOCKS;
    size_t inputSrcSize = RN_SIZE * AB_SIZE * sizeof(float);
    size_t inputMeanSize = RN_SIZE * AB_SIZE * sizeof(float);
    size_t inputVarSize = RN_SIZE * AB_SIZE * sizeof(float);
    size_t outputMeanSize = RN_SIZE * AB_SIZE * sizeof(float);
    size_t outputVarSize = RN_SIZE * AB_SIZE * sizeof(float);

    size_t workspaceSize = WORKSPACE_SIZE;
    size_t tilingFileSize = TILINGDATA_SIZE * sizeof(uint32_t);
    uint8_t* tilingBuf = GenerateTiling(ISINPLACE, RN_SIZE, AB_SIZE, AB_LENGTH, NREC);

    aclInit(nullptr);
    aclrtContext context;
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtCreateContext(&context, deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *srcHost, *inMeanHost, *inVarHost, *outMeanHost, *outVarHost, *workspaceHost;
    uint8_t *srcDevice, *inMeanDevice, *inVarDevice, *outMeanDevice, *outVarDevice, *workspaceDevice, *tilingDevice;

    aclrtMallocHost((void**)(&srcHost), inputSrcSize);
    aclrtMallocHost((void**)(&inMeanHost), inputMeanSize);
    aclrtMallocHost((void**)(&inVarHost), inputVarSize);
    aclrtMallocHost((void**)(&outMeanHost), outputMeanSize);
    aclrtMallocHost((void**)(&outVarHost), outputVarSize);
    aclrtMallocHost((void**)(&workspaceHost), workspaceSize);

    aclrtMalloc((void**)&srcDevice, inputSrcSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&inMeanDevice, inputMeanSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&inVarDevice, inputVarSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&outMeanDevice, outputMeanSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&outVarDevice, outputVarSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&workspaceDevice, workspaceSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&tilingDevice, tilingFileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/input_srcGm.bin", inputSrcSize, srcHost, inputSrcSize);
    ReadFile("./input/input_inMeanGm.bin", inputMeanSize, inMeanHost, inputMeanSize);
    ReadFile("./input/input_inVarGm.bin", inputVarSize, inVarHost, inputVarSize);

    aclrtMemcpy(workspaceDevice, workspaceSize, workspaceHost, workspaceSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(tilingDevice, tilingFileSize, tilingBuf, tilingFileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    aclrtMemcpy(srcDevice, inputMeanSize, srcHost, inputMeanSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inMeanDevice, inputMeanSize, inMeanHost, inputMeanSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inVarDevice, inputVarSize, inVarHost, inputVarSize, ACL_MEMCPY_HOST_TO_DEVICE);

    welford_update_custom<<<numBlocks, nullptr, stream>>>(srcDevice, inMeanDevice, inVarDevice, outMeanDevice,
                                                         outVarDevice, workspaceDevice, tilingDevice);

    aclrtSynchronizeStream(stream);

    aclrtMemcpy(outMeanHost, outputMeanSize, outMeanDevice, outputMeanSize, ACL_MEMCPY_DEVICE_TO_HOST);
    aclrtMemcpy(outVarHost, outputVarSize, outVarDevice, outputVarSize, ACL_MEMCPY_DEVICE_TO_HOST);

    WriteFile("./output/output_outMeanGm.bin", outMeanHost, outputMeanSize);
    WriteFile("./output/output_outVarGm.bin", outVarHost, outputVarSize);

    bool goldenResult = true;
    goldenResult &= CompareResult(outMeanHost, outputMeanSize, "outMeanGm");
    goldenResult &= CompareResult(outVarHost, outputVarSize, "outVarGm");
    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }

    aclrtFree(srcDevice);
    aclrtFree(inMeanDevice);
    aclrtFree(inVarDevice);
    aclrtFree(outMeanDevice);
    aclrtFree(outVarDevice);
    aclrtFree(workspaceDevice);
    aclrtFree(tilingDevice);

    aclrtFreeHost(srcHost);
    aclrtFreeHost(inMeanHost);
    aclrtFreeHost(inVarHost);
    aclrtFreeHost(outMeanHost);
    aclrtFreeHost(outVarHost);
    aclrtFreeHost(workspaceHost);

    aclrtDestroyStream(stream);
    aclrtDestroyContext(context);
    aclrtResetDevice(deviceId);
    aclFinalize();

    free(tilingBuf);
    return 0;
}