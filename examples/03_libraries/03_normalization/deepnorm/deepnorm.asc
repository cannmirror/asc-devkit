/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file deepnorm.asc
 * \brief
 */

#include "acl/acl.h"
#include "data_utils.h"
#include "kernel_operator.h"
#include "tiling/tiling_api.h"

constexpr uint32_t SIZE_OF_FLOAT = 4;
constexpr uint32_t DEEPNORM_ONE_BLK_SIZE = 32;
constexpr uint32_t DEEPNORM_MAX_REPEAT = 255;
constexpr uint32_t BASIC_BLK_HLENGTH = 64;
constexpr uint32_t BASIC_BLK_BSLENGTH = 8;

template <typename T, bool isReuseSrc = false, bool isBasicBlock = false>
class KernelDeepNorm {
public:
    __aicore__ inline KernelDeepNorm() {}

    __aicore__ inline uint32_t GetFinalBlockSizeTest(uint32_t dataAmount, uint32_t blockSize)
    {
        return (dataAmount + blockSize - 1) / blockSize * blockSize;
    }

    __aicore__ inline uint32_t GetDeepNormMaxTmpSizeCur(const AscendC::ShapeInfo& inputShapeInfo,
                                                        const uint32_t typeSize, const bool isReuseSource)
    {
        uint32_t bLength = inputShapeInfo.shape[0];
        uint32_t sLength = inputShapeInfo.shape[1];
        uint32_t hLength = inputShapeInfo.shape[2];

        uint32_t inputBSsize = bLength * sLength * SIZE_OF_FLOAT;
        uint32_t inputBSHsize = bLength * sLength * hLength * SIZE_OF_FLOAT;
        inputBSsize = GetFinalBlockSizeTest(inputBSsize, DEEPNORM_ONE_BLK_SIZE);
        inputBSHsize = GetFinalBlockSizeTest(inputBSHsize, DEEPNORM_ONE_BLK_SIZE);

        if (isReuseSource && (typeSize == SIZE_OF_FLOAT)) {
            return 2 * inputBSHsize + 2 * inputBSsize;
        }
        return 3 * inputBSHsize + 2 * inputBSsize;
    }

    __aicore__ inline uint32_t GetDeepNormMinTmpSizeCur(const AscendC::ShapeInfo& inputShapeInfo,
                                                        const uint32_t typeSize, const bool isReuseSource,
                                                        const bool isBasicBlk)
    {
        uint32_t bLength = inputShapeInfo.shape[0];
        uint32_t sLength = inputShapeInfo.shape[1];
        uint32_t hLength = inputShapeInfo.shape[2];

        uint32_t inputBSsize = bLength * sLength;
        uint32_t inputHsize = hLength;

        inputBSsize = GetFinalBlockSizeTest(inputBSsize * SIZE_OF_FLOAT, DEEPNORM_ONE_BLK_SIZE);
        inputHsize = GetFinalBlockSizeTest(inputHsize * SIZE_OF_FLOAT, DEEPNORM_ONE_BLK_SIZE);

        if (isReuseSource && (typeSize == SIZE_OF_FLOAT)) {
            return 2 * inputHsize + 2 * inputBSsize;
        }
        return 3 * inputHsize + 2 * inputBSsize;
    }

    __aicore__ inline bool GetDeepNormMaxMinTmpSizeCur(const AscendC::ShapeInfo& inputShapeInfo,
                                                       const uint32_t typeSize, const bool isReuseSource,
                                                       const bool isBasicBlk, uint32_t& maxValue, uint32_t& minValue)
    {
        uint32_t bLength = inputShapeInfo.shape[0];
        uint32_t sLength = inputShapeInfo.shape[1];
        uint32_t hLength = inputShapeInfo.shape[2];

        bool hDivBy64 = (hLength % BASIC_BLK_HLENGTH == 0) && (hLength > 0);
        bool bsDivBy8 = (bLength * sLength) % BASIC_BLK_BSLENGTH == 0;

        if (isBasicBlock && !(hDivBy64 && bsDivBy8)) {
            return false;
        }

        maxValue = GetDeepNormMaxTmpSizeCur(inputShapeInfo, typeSize, isReuseSource);
        minValue = GetDeepNormMinTmpSizeCur(inputShapeInfo, typeSize, isReuseSource, isBasicBlock);
        return true;
    }

    __aicore__ inline bool GetDeepNormNDTilingInfo(const AscendC::ShapeInfo& inputShapeInfo,
                                                   const AscendC::ShapeInfo& originShapeInfo,
                                                   const uint32_t stackBufferSize, const uint32_t typeSize,
                                                   const bool isReuseSource, const bool isBasicBlk,
                                                   DeepNormTiling& tiling)
    {
        uint32_t minSize = 0;
        uint32_t maxSize = 0;
        bool res = GetDeepNormMaxMinTmpSizeCur(inputShapeInfo, typeSize, isReuseSource, isBasicBlk, maxSize, minSize);
        if (!res || stackBufferSize < minSize) {
            return false;
        }
        uint32_t bLength = inputShapeInfo.shape[0];
        uint32_t sLength = inputShapeInfo.shape[1];
        uint32_t hLength = inputShapeInfo.shape[2];

        uint32_t bLength_ori = originShapeInfo.shape[0];
        uint32_t sLength_ori = originShapeInfo.shape[1];
        uint32_t originalHLength = originShapeInfo.shape[2];

        bool bsCheck = (bLength == bLength_ori) && (sLength == sLength_ori);
        bool hAlign = (hLength * typeSize % DEEPNORM_ONE_BLK_SIZE) == 0;
        bool hCheckOri = (0u < originalHLength && originalHLength <= hLength);
        bool basicblkOriH = !(isBasicBlk && originalHLength != hLength);
        bool hLengthCheck = (hLength <= DEEPNORM_MAX_REPEAT * 8);

        if (!(bsCheck && hAlign && hCheckOri && basicblkOriH && hLengthCheck)) {
            return false;
        }

        tiling.bLength = bLength;
        tiling.sLength = sLength;
        tiling.hLength = hLength;
        tiling.originalHLength = originalHLength;
        tiling.inputXSize = tiling.bLength * tiling.sLength * tiling.hLength;
        tiling.meanVarSize = tiling.bLength * tiling.sLength;

        tiling.numberOfTmpBuf =
            (isReuseSource && (typeSize == 4)) ? AscendC::TWO_OF_STACK_BUFFER : AscendC::THREE_OF_STACK_BUFFER;

        uint32_t oneBlockNum = AscendC::ONE_BLK_SIZE / sizeof(float);
        tiling.meanTmpTensorPos = 0;
        tiling.meanTmpTensorSize = (tiling.meanVarSize + oneBlockNum - 1) / oneBlockNum * oneBlockNum;
        tiling.varianceTmpTensorPos = tiling.meanTmpTensorSize;
        tiling.varianceTmpTensorSize = tiling.meanTmpTensorSize;

        uint32_t meanVarTotalSize = (typeSize == 4) ? 0 : tiling.meanTmpTensorSize + tiling.varianceTmpTensorSize;

        tiling.tmpBufSize = stackBufferSize / sizeof(float);
        tiling.oneTmpSize = (tiling.tmpBufSize - meanVarTotalSize) / tiling.numberOfTmpBuf;
        tiling.oneTmpSize = tiling.oneTmpSize / tiling.hLength * tiling.hLength;
        tiling.oneTmpSize = (tiling.oneTmpSize > tiling.inputXSize) ? tiling.inputXSize : tiling.oneTmpSize;

        if (isBasicBlk && (tiling.oneTmpSize / (BASIC_BLK_BSLENGTH * tiling.hLength) > 0)) {
            tiling.oneTmpSize =
                tiling.oneTmpSize / (BASIC_BLK_BSLENGTH * tiling.hLength) * (BASIC_BLK_BSLENGTH * tiling.hLength);
        }

        if (tiling.oneTmpSize == 0) {
            return false;
        }

        tiling.firstTmpStartPos = meanVarTotalSize;
        tiling.secondTmpStartPos = tiling.firstTmpStartPos + tiling.oneTmpSize;
        tiling.thirdTmpStartPos = tiling.secondTmpStartPos + tiling.oneTmpSize;

        tiling.loopRound = tiling.inputXSize / tiling.oneTmpSize;
        tiling.inputTailSize = tiling.inputXSize % tiling.oneTmpSize;
        tiling.inputTailPos = tiling.inputXSize - tiling.inputTailSize;
        tiling.inputRoundSize = tiling.oneTmpSize;
        tiling.meanVarRoundSize = tiling.inputRoundSize / tiling.hLength;
        tiling.meanVarTailSize = tiling.inputTailSize / tiling.hLength;
        tiling.meanVarTailPos = tiling.meanVarSize - tiling.meanVarTailSize;

        tiling.bshCurLength = tiling.inputRoundSize;
        tiling.bsCurLength = tiling.meanVarRoundSize;

        float lastDimValueBack = 1.0;
        lastDimValueBack = lastDimValueBack / tiling.originalHLength;
        tiling.lastDimValueBack = (lastDimValueBack);

        return true;
    }

    __aicore__ inline void Init(GM_ADDR inputX_gm, GM_ADDR inputGx_gm, GM_ADDR beta_gm, GM_ADDR gamm_gm, T alpha,
                                T epsilon, GM_ADDR output_gm, GM_ADDR outputMean_gm, GM_ADDR outputVariance_gm,
                                uint32_t bLength, uint32_t sLength, uint32_t hLength, uint32_t originalhLength,
                                float hLengthFloat, uint32_t tmpMode, AscendC::DataFormat dataFormat,
                                AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;
        this->bLength = bLength;
        this->sLength = sLength;
        this->hLength = hLength;
        this->originalhLength = originalhLength;
        this->hLengthFloat = hLengthFloat;
        this->alpha = alpha;
        this->epsilon = epsilon;
        this->tmpMode = tmpMode;
        this->dataFormat = dataFormat;

        uint32_t oneBlockNum = 32 / sizeof(T);

        bshLength = bLength * sLength * hLength;
        bsLength = bLength * sLength;
        originalBsLength = bsLength;
        bsLength = (bsLength + oneBlockNum - 1) / oneBlockNum * oneBlockNum;

        inputX_global.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(inputX_gm), bshLength);
        inputGx_global.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(inputGx_gm), bshLength);
        beta_global.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(beta_gm), hLength);
        gamm_global.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(gamm_gm), hLength);

        output_global.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(output_gm), bshLength);
        outputMean_global.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(outputMean_gm), bsLength);
        outputVariance_global.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(outputVariance_gm), bsLength);

        pipe->InitBuffer(inQueueX, 1, sizeof(T) * bshLength);
        pipe->InitBuffer(inQueueGx, 1, sizeof(T) * bshLength);
        pipe->InitBuffer(inQueueBeta, 1, sizeof(T) * hLength);
        pipe->InitBuffer(inQueueGamma, 1, sizeof(T) * hLength);
        pipe->InitBuffer(outQueue, 1, sizeof(T) * bshLength);
        pipe->InitBuffer(outQueueMean, 1, sizeof(T) * bsLength);
        pipe->InitBuffer(outQueueVariance, 1, sizeof(T) * bsLength);
    }
    __aicore__ inline void Process()
    {
        AscendC::AscendCUtils::SetOverflow(1);
        CopyIn();
        Compute();
        CopyOut();
        AscendC::AscendCUtils::SetOverflow(0);
    }

private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<T> inputXLocal = inQueueX.AllocTensor<T>();
        AscendC::LocalTensor<T> inputGxLocal = inQueueGx.AllocTensor<T>();
        AscendC::LocalTensor<T> gammaLocal = inQueueGamma.AllocTensor<T>();
        AscendC::LocalTensor<T> betaLocal = inQueueBeta.AllocTensor<T>();

        AscendC::DataCopy(inputXLocal, inputX_global, bshLength);
        AscendC::DataCopy(inputGxLocal, inputGx_global, bshLength);
        AscendC::DataCopy(gammaLocal, gamm_global, hLength);
        AscendC::DataCopy(betaLocal, beta_global, hLength);

        inQueueX.EnQue(inputXLocal);
        inQueueGx.EnQue(inputGxLocal);
        inQueueBeta.EnQue(betaLocal);
        inQueueGamma.EnQue(gammaLocal);
    }
    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<T> inputXLocal = inQueueX.DeQue<T>();
        AscendC::LocalTensor<T> inputGxLocal = inQueueGx.DeQue<T>();
        AscendC::LocalTensor<T> gammaLocal = inQueueGamma.DeQue<T>();
        AscendC::LocalTensor<T> betaLocal = inQueueBeta.DeQue<T>();
        AscendC::LocalTensor<T> outputLocal = outQueue.AllocTensor<T>();
        AscendC::LocalTensor<T> meanLocal = outQueueMean.AllocTensor<T>();
        AscendC::LocalTensor<T> varianceLocal = outQueueVariance.AllocTensor<T>();

        DeepNormTiling tiling;

        uint32_t inputShape[3] = {bLength, sLength, hLength};
        AscendC::ShapeInfo shapeInfo{3, inputShape, 3, inputShape, dataFormat};

        uint32_t maxSize = GetDeepNormMaxTmpSizeCur(shapeInfo, sizeof(T), isReuseSrc);
        uint32_t minSize = GetDeepNormMinTmpSizeCur(shapeInfo, sizeof(T), isReuseSrc, isBasicBlock);

        AscendC::LocalTensor<uint8_t> stackBuffer;
        bool ans = AscendC::PopStackBuffer<uint8_t, AscendC::TPosition::LCM>(stackBuffer);
        stackBufferSize = stackBuffer.GetSize();

        for (int i = 0; i < 1; i++) {
            if (tmpMode == 0) {
                GetDeepNormNDTilingInfo(shapeInfo, shapeInfo, stackBufferSize, sizeof(T), isReuseSrc, isBasicBlock,
                                        tiling);
                AscendC::DeepNorm<T, isReuseSrc, isBasicBlock>(outputLocal, meanLocal, varianceLocal, inputXLocal,
                                                               inputGxLocal, betaLocal, gammaLocal, (T)alpha,
                                                               (T)epsilon, tiling);
            } else {
                if (tmpMode == 1) {
                    stackBufferSize = minSize;
                } else if (tmpMode == 2) {
                    stackBufferSize = maxSize;
                } else if (tmpMode == 3) {
                    stackBufferSize = (minSize + maxSize) / 2;
                }
                stackBuffer.SetSize(stackBufferSize);
                GetDeepNormNDTilingInfo(shapeInfo, shapeInfo, stackBufferSize, sizeof(T), isReuseSrc, isBasicBlock,
                                        tiling);
                AscendC::DeepNorm<T, isReuseSrc, isBasicBlock>(outputLocal, meanLocal, varianceLocal, inputXLocal,
                                                               inputGxLocal, betaLocal, gammaLocal, stackBuffer,
                                                               (T)alpha, (T)epsilon, tiling);
            }
        }

        outQueue.EnQue<T>(outputLocal);
        outQueueMean.EnQue<T>(meanLocal);
        outQueueVariance.EnQue<T>(varianceLocal);

        inQueueX.FreeTensor(inputXLocal);
        inQueueGx.FreeTensor(inputGxLocal);
        inQueueGamma.FreeTensor(gammaLocal);
        inQueueBeta.FreeTensor(betaLocal);
    }
    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<T> outputLocal = outQueue.DeQue<T>();
        AscendC::LocalTensor<T> meanLocal = outQueueMean.DeQue<T>();
        AscendC::LocalTensor<T> varianceLocal = outQueueVariance.DeQue<T>();

        AscendC::DataCopyParams copyParams;
        copyParams.blockLen = originalBsLength * sizeof(T);

        AscendC::DataCopy(output_global, outputLocal, bshLength);
        AscendC::DataCopy(outputMean_global, meanLocal, bsLength);
        AscendC::DataCopy(outputVariance_global, varianceLocal, bsLength);

        outQueue.FreeTensor(outputLocal);
        outQueueMean.FreeTensor(meanLocal);
        outQueueVariance.FreeTensor(varianceLocal);
    }

private:
    AscendC::GlobalTensor<T> inputX_global;
    AscendC::GlobalTensor<T> inputGx_global;
    AscendC::GlobalTensor<T> gamm_global;
    AscendC::GlobalTensor<T> beta_global;
    AscendC::GlobalTensor<T> output_global;
    AscendC::GlobalTensor<T> outputMean_global;
    AscendC::GlobalTensor<T> outputVariance_global;

    AscendC::TPipe* pipe;
    AscendC::TQue<AscendC::QuePosition::VECIN, 1> inQueueX;
    AscendC::TQue<AscendC::QuePosition::VECIN, 1> inQueueGx;
    AscendC::TQue<AscendC::QuePosition::VECIN, 1> inQueueGamma;
    AscendC::TQue<AscendC::QuePosition::VECIN, 1> inQueueBeta;
    AscendC::TQue<AscendC::QuePosition::VECOUT, 1> outQueue;
    AscendC::TQue<AscendC::QuePosition::VECOUT, 1> outQueueMean;
    AscendC::TQue<AscendC::QuePosition::VECOUT, 1> outQueueVariance;

    uint32_t bLength;
    uint32_t sLength;
    uint32_t hLength;
    uint32_t originalhLength;
    float hLengthFloat;
    T alpha;
    T epsilon;
    uint32_t tmpMode;
    AscendC::DataFormat dataFormat;

    uint32_t bshLength;
    uint32_t bsLength;
    uint32_t originalBsLength;
    uint32_t stackBufferSize = 0;
};

__global__ __vector__ void deepnorm_custom(GM_ADDR inputX_gm, GM_ADDR inputGx_gm, GM_ADDR beta_gm, GM_ADDR gamm_gm,
                                           GM_ADDR output_gm, GM_ADDR outputMean_gm, GM_ADDR outputVariance_gm)
{
    AscendC::TPipe pipe;
    constexpr uint32_t bLength = 4;
    constexpr uint32_t sLength = 16;
    constexpr uint32_t hLength = 64;
    constexpr float hLengthFloat = 64;
    constexpr uint32_t originalhLength = 64;
    constexpr float alpha = -5.5;
    constexpr float epsilon = 65504;
    constexpr uint32_t tmpMode = 2;
    KernelDeepNorm<float, false, true> op;
    op.Init(inputX_gm, inputGx_gm, beta_gm, gamm_gm, alpha, epsilon, output_gm, outputMean_gm, outputVariance_gm,
            bLength, sLength, hLength, originalhLength, hLengthFloat, tmpMode, AscendC::DataFormat::ND, &pipe);
    op.Process();
}

static bool CompareResult(const void* outputData, int64_t outSize, std::string goldenName)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden_output_" + goldenName + ".bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden_output_%s.bin success!\n", goldenName.c_str());
    } else {
        aclrtFreeHost(goldenData);
        return false;
    }
    constexpr float EPS = 1e-5;
    int64_t wrongNum = 0;

    for (int i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult golden_output_%s.bin failed output is %lf, golden is %lf\n", goldenName.c_str(), a,
                   b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    if (wrongNum != 0) {
        return false;
    } else {
        printf("CompareResult golden_output_%s.bin success!\n", goldenName.c_str());
        return true;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    size_t param1FileSize = 4096 * sizeof(float);
    size_t param2FileSize = 4096 * sizeof(float);
    size_t param3FileSize = 64 * sizeof(float);
    size_t param4FileSize = 64 * sizeof(float);
    size_t param5FileSize = 4096 * sizeof(float);
    size_t param6FileSize = 64 * sizeof(float);
    size_t param7FileSize = 64 * sizeof(float);
    uint32_t numBlocks = 1;

    aclInit(nullptr);
    aclrtContext context;
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtCreateContext(&context, deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t* param1Host;
    uint8_t* param1Device;
    aclrtMallocHost((void**)(&param1Host), param1FileSize);
    aclrtMalloc((void**)&param1Device, param1FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_inputX.bin", param1FileSize, param1Host, param1FileSize);
    aclrtMemcpy(param1Device, param1FileSize, param1Host, param1FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param2Host;
    uint8_t* param2Device;
    aclrtMallocHost((void**)(&param2Host), param2FileSize);
    aclrtMalloc((void**)&param2Device, param2FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_inputGx.bin", param2FileSize, param2Host, param2FileSize);
    aclrtMemcpy(param2Device, param2FileSize, param2Host, param2FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param3Host;
    uint8_t* param3Device;
    aclrtMallocHost((void**)(&param3Host), param3FileSize);
    aclrtMalloc((void**)&param3Device, param3FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_beta.bin", param3FileSize, param3Host, param3FileSize);
    aclrtMemcpy(param3Device, param3FileSize, param3Host, param3FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param4Host;
    uint8_t* param4Device;
    aclrtMallocHost((void**)(&param4Host), param4FileSize);
    aclrtMalloc((void**)&param4Device, param4FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_gamma.bin", param4FileSize, param4Host, param4FileSize);
    aclrtMemcpy(param4Device, param4FileSize, param4Host, param4FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param5Host;
    uint8_t* param5Device;
    aclrtMallocHost((void**)(&param5Host), param5FileSize);
    aclrtMalloc((void**)&param5Device, param5FileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    uint8_t* param6Host;
    uint8_t* param6Device;
    aclrtMallocHost((void**)(&param6Host), param6FileSize);
    aclrtMalloc((void**)&param6Device, param6FileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    uint8_t* param7Host;
    uint8_t* param7Device;
    aclrtMallocHost((void**)(&param7Host), param7FileSize);
    aclrtMalloc((void**)&param7Device, param7FileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    deepnorm_custom<<<numBlocks, nullptr, stream>>>(param1Device, param2Device, param3Device, param4Device, param5Device,
                                                   param6Device, param7Device);

    aclrtSynchronizeStream(stream);

    aclrtFree(param1Device);
    aclrtFreeHost(param1Host);
    aclrtFree(param2Device);
    aclrtFreeHost(param2Host);
    aclrtFree(param3Device);
    aclrtFreeHost(param3Host);
    aclrtFree(param4Device);
    aclrtFreeHost(param4Host);

    aclrtMemcpy(param5Host, param5FileSize, param5Device, param5FileSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output_result.bin", param5Host, param5FileSize);
    aclrtFree(param5Device);
    aclrtFreeHost(param5Host);

    aclrtMemcpy(param6Host, param6FileSize, param6Device, param6FileSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output_mean.bin", param6Host, param6FileSize);
    aclrtFree(param6Device);
    aclrtFreeHost(param6Host);

    aclrtMemcpy(param7Host, param7FileSize, param7Device, param7FileSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output_variance.bin", param7Host, param7FileSize);
    aclrtFree(param7Device);
    aclrtFreeHost(param7Host);

    bool goldenResult = true;
    goldenResult &= CompareResult(param5Host, param5FileSize, "result");
    goldenResult &= CompareResult(param6Host, param6FileSize, "mean");
    goldenResult &= CompareResult(param7Host, param7FileSize, "variance");
    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }

    aclrtDestroyStream(stream);
    aclrtDestroyContext(context);
    aclrtResetDevice(deviceId);
    aclFinalize();

    return 0;
}