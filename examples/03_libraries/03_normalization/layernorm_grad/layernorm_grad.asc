/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file layernorm_grad.asc
 * \brief
 */

#include "acl/acl.h"
#include "data_utils.h"
#include "kernel_operator.h"
#include "tiling/tiling_api.h"

namespace optiling {
BEGIN_TILING_DATA_DEF(LayernormGradCustomTilingData)
TILING_DATA_FIELD_DEF_STRUCT(LayerNormGradTiling, layernormGradTilingData);
TILING_DATA_FIELD_DEF(float, epsilon);
END_TILING_DATA_DEF;

REGISTER_TILING_DATA_CLASS(LayernormGradCustom, LayernormGradCustomTilingData)
} // namespace optiling

void ComputeTiling(const uint32_t bLength, const uint32_t sLength, const uint32_t hLength,
                   optiling::LayernormGradCustomTilingData& tiling)
{
    ge::Shape geShape({bLength, sLength, hLength, hLength});

    uint32_t maxTmpSize = 0;
    uint32_t minTmpSize = 0;
    bool isReuseSource = false;
    AscendC::GetLayerNormGradMaxMinTmpSize(geShape, sizeof(float), isReuseSource, maxTmpSize, minTmpSize);
    uint32_t localWorkspaceSize = minTmpSize;
    AscendC::GetLayerNormGradNDTilingInfo(geShape, localWorkspaceSize, sizeof(float), isReuseSource,
                                          tiling.layernormGradTilingData);

    tiling.set_epsilon(0.0001);
}

uint8_t* GetTilingBuf(optiling::LayernormGradCustomTilingData* tilingData)
{
    uint32_t tilingSize = sizeof(optiling::LayernormGradCustomTilingData);
    uint8_t* buf = (uint8_t*)malloc(tilingSize);
    tilingData->SaveToBuffer(buf, tilingSize);
    return buf;
}

uint8_t* GenerateTiling(uint32_t bLength, uint32_t sLength, uint32_t hLength)
{
    optiling::LayernormGradCustomTilingData tiling;
    ComputeTiling(bLength, sLength, hLength, tiling);
    return GetTilingBuf(&tiling);
}

namespace MyCustomKernel {
struct VecTiling {
    LayerNormGradTiling layernormGradTilingData;
    float epsilon = 0;
};

template <bool isReuseSource = false>
class KernelLayernormGrad {
public:
    __aicore__ inline KernelLayernormGrad() {}
    __aicore__ inline void Init(GM_ADDR inputXGm, GM_ADDR inputDyGm, GM_ADDR inputVarianceGm, GM_ADDR inputMeanGm,
                                GM_ADDR inputGammaGm, GM_ADDR outputPdXGm, GM_ADDR resForGammaGm, VecTiling tilingData,
                                AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;
        this->epsilon = tilingData.epsilon;
        tiling_ = tilingData.layernormGradTilingData;
        this->bLength = tiling_.bLength;
        this->sLength = tiling_.sLength;
        this->hLength = tiling_.hLength;

        bshLength = bLength * sLength * hLength;
        bsLength = bLength * sLength;

        inputXGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(inputXGm), bshLength);
        inputDyGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(inputDyGm), bshLength);
        inputVarianceGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(inputVarianceGm), bsLength);
        inputMeanGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(inputMeanGm), bsLength);
        inputGammaGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(inputGammaGm), hLength);

        outputPdXGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(outputPdXGm), bshLength);
        outputResForGammaGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(resForGammaGm), bshLength);

        pipe->InitBuffer(inQueueX, 1, sizeof(float) * bshLength);
        pipe->InitBuffer(inQueueDy, 1, sizeof(float) * bshLength);
        pipe->InitBuffer(inQueueVariance, 1, sizeof(float) * bsLength);
        pipe->InitBuffer(inQueueMean, 1, sizeof(float) * bsLength);
        pipe->InitBuffer(inQueueGamma, 1, sizeof(float) * hLength);
        pipe->InitBuffer(outQueuePdX, 1, sizeof(float) * bshLength);
        pipe->InitBuffer(outQueueResForGamma, 1, sizeof(float) * bshLength);
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        Compute();
        CopyOut();
    }

private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<float> inputXLocal = inQueueX.AllocTensor<float>();
        AscendC::LocalTensor<float> inputDyLocal = inQueueDy.AllocTensor<float>();
        AscendC::LocalTensor<float> inputVarianceLocal = inQueueVariance.AllocTensor<float>();
        AscendC::LocalTensor<float> inputMeanLocal = inQueueMean.AllocTensor<float>();
        AscendC::LocalTensor<float> inputGammaLocal = inQueueGamma.AllocTensor<float>();

        AscendC::DataCopy(inputXLocal, inputXGlobal, bshLength);
        AscendC::DataCopy(inputDyLocal, inputDyGlobal, bshLength);
        AscendC::DataCopy(inputVarianceLocal, inputVarianceGlobal, bsLength);
        AscendC::DataCopy(inputMeanLocal, inputMeanGlobal, bsLength);
        AscendC::DataCopy(inputGammaLocal, inputGammaGlobal, hLength);

        inQueueX.EnQue(inputXLocal);
        inQueueDy.EnQue(inputDyLocal);
        inQueueVariance.EnQue(inputVarianceLocal);
        inQueueMean.EnQue(inputMeanLocal);
        inQueueGamma.EnQue(inputGammaLocal);
    }
    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<float> inputXLocal = inQueueX.DeQue<float>();
        AscendC::LocalTensor<float> inputDyLocal = inQueueDy.DeQue<float>();
        AscendC::LocalTensor<float> inputVarianceLocal = inQueueVariance.DeQue<float>();
        AscendC::LocalTensor<float> inputMeanLocal = inQueueMean.DeQue<float>();
        AscendC::LocalTensor<float> inputGammaLocal = inQueueGamma.DeQue<float>();
        AscendC::LocalTensor<float> outputPdXLocal = outQueuePdX.AllocTensor<float>();
        AscendC::LocalTensor<float> outputResForGammaLocal = outQueueResForGamma.AllocTensor<float>();
        AscendC::LayerNormGrad<float, isReuseSource>(outputPdXLocal, outputResForGammaLocal, inputDyLocal, inputXLocal,
                                                     inputVarianceLocal, inputMeanLocal, inputGammaLocal,
                                                     (float)epsilon, tiling_);

        outQueuePdX.EnQue(outputPdXLocal);
        outQueueResForGamma.EnQue(outputResForGammaLocal);

        inQueueX.FreeTensor(inputXLocal);
        inQueueDy.FreeTensor(inputDyLocal);
        inQueueVariance.FreeTensor(inputVarianceLocal);
        inQueueMean.FreeTensor(inputMeanLocal);
        inQueueGamma.FreeTensor(inputGammaLocal);
    }
    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<float> outputPdXLocal = outQueuePdX.DeQue<float>();
        AscendC::LocalTensor<float> outputResForGammaLocal = outQueueResForGamma.DeQue<float>();

        AscendC::DataCopy(outputPdXGlobal, outputPdXLocal, bshLength);
        AscendC::DataCopy(outputResForGammaGlobal, outputResForGammaLocal, bshLength);

        outQueuePdX.FreeTensor(outputPdXLocal);
        outQueueResForGamma.FreeTensor(outputResForGammaLocal);
    }

private:
    AscendC::GlobalTensor<float> inputXGlobal;
    AscendC::GlobalTensor<float> inputDyGlobal;
    AscendC::GlobalTensor<float> inputVarianceGlobal;
    AscendC::GlobalTensor<float> inputMeanGlobal;
    AscendC::GlobalTensor<float> inputGammaGlobal;
    AscendC::GlobalTensor<float> outputPdXGlobal;
    AscendC::GlobalTensor<float> outputResForGammaGlobal;

    AscendC::TPipe* pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueDy;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueVariance;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueMean;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueGamma;

    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueuePdX;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> outQueueResForGamma;

    uint32_t bLength;
    uint32_t sLength;
    uint32_t hLength;
    float epsilon;
    LayerNormGradTiling tiling_;

    uint32_t bshLength;
    uint32_t bsLength;
};
} // namespace MyCustomKernel

__aicore__ inline void CopyTiling(MyCustomKernel::VecTiling* tiling, GM_ADDR tilingGM)
{
    uint32_t* ptr = reinterpret_cast<uint32_t*>(tiling);
    auto tiling32 = reinterpret_cast<__gm__ uint32_t*>(tilingGM);

    for (int i = 0; i < sizeof(MyCustomKernel::VecTiling) / sizeof(uint32_t); i++, ptr++) { *ptr = *(tiling32 + i); }
    return;
}

extern "C" __global__ __vector__ void layernorm_grad_custom(GM_ADDR inputXGm, GM_ADDR inputDyGm,
                                                            GM_ADDR inputVarianceGm, GM_ADDR inputMeanGm,
                                                            GM_ADDR inputGammaGm, GM_ADDR outputPdXGm,
                                                            GM_ADDR resForGammaGm, GM_ADDR workspace, GM_ADDR tiling)
{
    AscendC::TPipe pipe;
    MyCustomKernel::VecTiling tilingData;
    CopyTiling(&tilingData, tiling);
    MyCustomKernel::KernelLayernormGrad<false> op;
    op.Init(inputXGm, inputDyGm, inputVarianceGm, inputMeanGm, inputGammaGm, outputPdXGm, resForGammaGm, tilingData,
            &pipe);
    op.Process();
}

constexpr uint32_t BLENGTH = 2;
constexpr uint32_t SLENGTH = 32;
constexpr uint32_t HLENGTH = 16;
constexpr uint32_t NUM_BLOCKS = 1;
constexpr uint32_t TILINGDATA_SIZE = 31;
constexpr uint32_t WORKSPACE_SIZE = 16 * 1024 * 1024;

static bool CompareResult(const void* outputData, int64_t outSize, std::string goldenName)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden_" + goldenName + ".bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden_%s.bin success!\n", goldenName.c_str());
    } else {
        aclrtFreeHost(goldenData);
        return false;
    }
    constexpr float EPS = 1e-4;
    int64_t wrongNum = 0;

    for (int i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult golden_%s.bin failed output is %lf, golden is %lf\n", goldenName.c_str(), a, b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    if (wrongNum != 0) {
        return false;
    } else {
        printf("CompareResult golden_%s.bin success!\n", goldenName.c_str());
        return true;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    uint32_t numBlocks = NUM_BLOCKS;
    size_t workspaceSize = WORKSPACE_SIZE;
    size_t inputSize_inputX = BLENGTH * SLENGTH * HLENGTH * sizeof(float);
    size_t inputSize_inputDy = BLENGTH * SLENGTH * HLENGTH * sizeof(float);
    size_t inputSize_inputMean = BLENGTH * SLENGTH * sizeof(float);
    size_t inputSize_inputVariance = BLENGTH * SLENGTH * sizeof(float);
    size_t inputSize_inputGamma = HLENGTH * sizeof(float);
    size_t outputSize_outputPdX = BLENGTH * SLENGTH * HLENGTH * sizeof(float);
    size_t outputSize_resForGamma = BLENGTH * SLENGTH * HLENGTH * sizeof(float);
    size_t tilingFileSize = TILINGDATA_SIZE * sizeof(uint32_t);
    uint8_t* tilingBuf = GenerateTiling(BLENGTH, SLENGTH, HLENGTH);

    aclInit(nullptr);
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *inputXHost, *inputDyHost, *inputMeanHost, *inputVarianceHost, *inputGammaHost, *outputPdXHost,
        *resForGammaHost, *workspaceHost, *tilingHost;
    uint8_t *inputXDevice, *inputDyDevice, *inputMeanDevice, *inputVarianceDevice, *inputGammaDevice, *outputPdXDevice,
        *resForGammaDevice, *workspaceDevice, *tilingDevice;

    aclrtMallocHost((void**)(&inputXHost), inputSize_inputX);
    aclrtMallocHost((void**)(&inputDyHost), inputSize_inputDy);
    aclrtMallocHost((void**)(&inputMeanHost), inputSize_inputMean);
    aclrtMallocHost((void**)(&inputVarianceHost), inputSize_inputVariance);
    aclrtMallocHost((void**)(&inputGammaHost), inputSize_inputGamma);
    aclrtMallocHost((void**)(&outputPdXHost), outputSize_outputPdX);
    aclrtMallocHost((void**)(&resForGammaHost), outputSize_resForGamma);
    aclrtMallocHost((void**)(&workspaceHost), workspaceSize);
    aclrtMallocHost((void**)(&tilingHost), tilingFileSize);
    aclrtMalloc((void**)&inputXDevice, inputSize_inputX, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&inputDyDevice, inputSize_inputDy, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&inputMeanDevice, inputSize_inputMean, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&inputVarianceDevice, inputSize_inputVariance, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&inputGammaDevice, inputSize_inputGamma, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&outputPdXDevice, outputSize_outputPdX, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&resForGammaDevice, outputSize_resForGamma, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&workspaceDevice, workspaceSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&tilingDevice, tilingFileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/input_inputX.bin", inputSize_inputX, inputXHost, inputSize_inputX);
    ReadFile("./input/input_inputDy.bin", inputSize_inputDy, inputDyHost, inputSize_inputDy);
    ReadFile("./input/input_inputMean.bin", inputSize_inputMean, inputMeanHost, inputSize_inputMean);
    ReadFile("./input/input_inputVariance.bin", inputSize_inputVariance, inputVarianceHost, inputSize_inputVariance);
    ReadFile("./input/input_inputGamma.bin", inputSize_inputGamma, inputGammaHost, inputSize_inputGamma);

    aclrtMemcpy(workspaceDevice, workspaceSize, workspaceHost, workspaceSize, ACL_MEMCPY_HOST_TO_DEVICE);

    aclrtMemcpy(tilingDevice, tilingFileSize, tilingBuf, tilingFileSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inputXDevice, inputSize_inputX, inputXHost, inputSize_inputX, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inputDyDevice, inputSize_inputDy, inputDyHost, inputSize_inputDy, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inputMeanDevice, inputSize_inputMean, inputMeanHost, inputSize_inputMean, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inputVarianceDevice, inputSize_inputVariance, inputVarianceHost, inputSize_inputVariance,
                ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(inputGammaDevice, inputSize_inputGamma, inputGammaHost, inputSize_inputGamma,
                ACL_MEMCPY_HOST_TO_DEVICE);

    layernorm_grad_custom<<<numBlocks, nullptr, stream>>>(inputXDevice, inputDyDevice, inputVarianceDevice,
                                                         inputMeanDevice, inputGammaDevice, outputPdXDevice,
                                                         resForGammaDevice, workspaceDevice, tilingDevice);

    aclrtSynchronizeStream(stream);

    aclrtMemcpy(outputPdXHost, outputSize_outputPdX, outputPdXDevice, outputSize_outputPdX, ACL_MEMCPY_DEVICE_TO_HOST);
    aclrtMemcpy(resForGammaHost, outputSize_resForGamma, resForGammaDevice, outputSize_resForGamma,
                ACL_MEMCPY_DEVICE_TO_HOST);

    WriteFile("./output/output_outputPdX.bin", outputPdXHost, outputSize_outputPdX);
    WriteFile("./output/output_resForGamma.bin", resForGammaHost, outputSize_resForGamma);
    bool goldenResult = true;
    goldenResult &= CompareResult(outputPdXHost, outputSize_outputPdX, "outputPdX");
    goldenResult &= CompareResult(resForGammaHost, outputSize_resForGamma, "resForGamma");
    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }

    aclrtFree(inputXDevice);
    aclrtFree(inputDyDevice);
    aclrtFree(inputMeanDevice);
    aclrtFree(inputVarianceDevice);
    aclrtFree(inputGammaDevice);
    aclrtFree(outputPdXDevice);
    aclrtFree(resForGammaDevice);
    aclrtFree(workspaceDevice);
    aclrtFree(tilingDevice);

    aclrtFreeHost(inputXHost);
    aclrtFreeHost(inputDyHost);
    aclrtFreeHost(inputMeanHost);
    aclrtFreeHost(inputVarianceHost);
    aclrtFreeHost(inputGammaHost);
    aclrtFreeHost(outputPdXHost);
    aclrtFreeHost(resForGammaHost);
    aclrtFreeHost(workspaceHost);
    aclrtFreeHost(tilingHost);

    aclrtDestroyStream(stream);
    aclrtResetDevice(deviceId);
    aclFinalize();
    free(tilingBuf);
    return 0;
}