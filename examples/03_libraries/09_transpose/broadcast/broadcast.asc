/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file broadcast.asc
 * \brief
 */

#include "acl/acl.h"
#include "data_utils.h"
#include "kernel_operator.h"
#include "tiling/tiling_api.h"

namespace optiling {
BEGIN_TILING_DATA_DEF(BroadcastTilingData)
TILING_DATA_FIELD_DEF(uint32_t, dim);
TILING_DATA_FIELD_DEF(uint32_t, axis);
TILING_DATA_FIELD_DEF(uint32_t, srcFirstDim);
TILING_DATA_FIELD_DEF(uint32_t, srcLastDim);
TILING_DATA_FIELD_DEF(uint32_t, dstFirstDim);
TILING_DATA_FIELD_DEF(uint32_t, dstLastDim);
END_TILING_DATA_DEF;

REGISTER_TILING_DATA_CLASS(BroadcastCustom, BroadcastTilingData)
} // namespace optiling

void ComputeTiling(const ge::Shape& inputShape, const ge::Shape& outputShape, uint32_t dtypeSize,
                   optiling::BroadcastTilingData& tiling)
{
    int32_t axis = 0;
    const uint32_t dim = inputShape.GetDimNum();
    if (dim == 1) {
        tiling.set_srcFirstDim(inputShape.GetDim(0));
        tiling.set_srcLastDim(1);
        tiling.set_dstFirstDim(outputShape.GetDim(0));
        tiling.set_dstLastDim(1);
    } else {
        tiling.set_srcFirstDim(inputShape.GetDim(0));
        tiling.set_srcLastDim(inputShape.GetDim(1));
        tiling.set_dstFirstDim(outputShape.GetDim(0));
        tiling.set_dstLastDim(outputShape.GetDim(1));
        if (inputShape.GetDim(1) == 1) {
            axis = 1;
        }
    }

    tiling.set_axis(axis);
    tiling.set_dim(dim);
    return;
}

uint8_t* GetTilingBuf(optiling::BroadcastTilingData* tilingData)
{
    uint32_t tilingSize = sizeof(optiling::BroadcastTilingData);
    uint8_t* buf = (uint8_t*)malloc(tilingSize);
    tilingData->SaveToBuffer(buf, tilingSize);
    return buf;
}

uint8_t* GenerateTiling(const ge::Shape& inputShape, const ge::Shape& outputShape, uint32_t dtypeSize)
{
    optiling::BroadcastTilingData tiling;
    ComputeTiling(inputShape, outputShape, dtypeSize, tiling);
    return GetTilingBuf(&tiling);
}

constexpr int32_t BUFFER_NUM = 1;
template <typename T, int32_t dim, int32_t axis>
class KernelBroadcastCustom {
public:
    __aicore__ inline KernelBroadcastCustom() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, uint32_t srcLength, uint32_t dstLength,
                                const uint32_t srcShape[dim], const uint32_t dstShape[dim], AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;
        xGm.SetGlobalBuffer((__gm__ T*)x, srcLength);
        yGm.SetGlobalBuffer((__gm__ T*)y, dstLength);

        pipe->InitBuffer(inQueueX, BUFFER_NUM, srcLength * sizeof(T));
        pipe->InitBuffer(outQueueY, BUFFER_NUM, dstLength * sizeof(T));

        srcLength_ = srcLength;
        dstLength_ = dstLength;
        srcShape_ = srcShape;
        dstShape_ = dstShape;
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        Compute();
        CopyOut();
    }

private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<T> xLocal = inQueueX.AllocTensor<T>();
        AscendC::DataCopy(xLocal, xGm, srcLength_);
        inQueueX.EnQue(xLocal);
    }
    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<T> xLocal = inQueueX.DeQue<T>();
        AscendC::LocalTensor<T> yLocal = outQueueY.AllocTensor<T>();
        AscendC::BroadCast<T, dim, axis>(yLocal, xLocal, dstShape_, srcShape_);

        outQueueY.EnQue<T>(yLocal);
        inQueueX.FreeTensor(xLocal);
    }
    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<T> yLocal = outQueueY.DeQue<T>();
        AscendC::DataCopy(yGm, yLocal, dstLength_);
        outQueueY.FreeTensor(yLocal);
    }

private:
    AscendC::TPipe* pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECOUT, BUFFER_NUM> outQueueY;
    AscendC::GlobalTensor<T> xGm;
    AscendC::GlobalTensor<T> yGm;
    uint32_t srcLength_;
    uint32_t dstLength_;
    const uint32_t* srcShape_{nullptr};
    const uint32_t* dstShape_{nullptr};
};

struct BroadcastTilingData {
    uint32_t dim{0};
    uint32_t axis{0};
    uint32_t srcFirstDim{0};
    uint32_t srcLastDim{0};
    uint32_t dstFirstDim{0};
    uint32_t dstLastDim{0};
};

__aicore__ inline void CopyTiling(BroadcastTilingData* tiling, GM_ADDR tilingGM)
{
    uint32_t* ptr = reinterpret_cast<uint32_t*>(tiling);
    auto tiling32 = reinterpret_cast<__gm__ uint32_t*>(tilingGM);

    for (int i = 0; i < sizeof(BroadcastTilingData) / sizeof(uint32_t); i++, ptr++) { *ptr = *(tiling32 + i); }
    return;
}

extern "C" __global__ __aicore__ void broadcast_custom(GM_ADDR x, GM_ADDR y, GM_ADDR workspace, GM_ADDR tiling)
{
    KERNEL_TASK_TYPE_DEFAULT(KERNEL_TYPE_AIV_ONLY);
    AscendC::TPipe pipe;
    BroadcastTilingData tilingData;
    CopyTiling(&tilingData, tiling);
    uint32_t axis = tilingData.axis;
    uint32_t dim = tilingData.dim;

    if (dim == 1) {
        const uint32_t srcShape[] = {tilingData.srcFirstDim};
        const uint32_t dstShape[] = {tilingData.dstFirstDim};
        KernelBroadcastCustom<float, 1, 0> op;
        op.Init(x, y, tilingData.srcFirstDim, tilingData.dstFirstDim, srcShape, dstShape, &pipe);
        op.Process();
    } else {
        const uint32_t srcShape[] = {tilingData.srcFirstDim, tilingData.srcLastDim};
        const uint32_t dstShape[] = {tilingData.dstFirstDim, tilingData.dstLastDim};

        if (axis == 0) {
            KernelBroadcastCustom<float, 2, 0> op;
            op.Init(x, y, tilingData.srcFirstDim * tilingData.srcLastDim,
                    tilingData.dstFirstDim * tilingData.dstLastDim, srcShape, dstShape, &pipe);
            op.Process();
        } else {
            KernelBroadcastCustom<float, 2, 1> op;
            op.Init(x, y, tilingData.srcFirstDim * tilingData.srcLastDim,
                    tilingData.dstFirstDim * tilingData.dstLastDim, srcShape, dstShape, &pipe);
            op.Process();
        }
    }
}

constexpr uint32_t TILINGDATA_SIZE = 6;

int64_t CompareResult(void* outputData, int64_t outSize)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden.bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden success!\n");
    } else {
        aclrtFreeHost(goldenData);
        return -1;
    }
    constexpr float EPS = 1e-5;
    int64_t wrongNum = 0;

    for (int i = 0; i < outSize / sizeof(float); i++) {
        float a = ((float*)outputData)[i];
        float b = ((float*)goldenData)[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult failed output is %lf, golden is %lf\n", a, b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    return wrongNum;
}

uint8_t* GenerateTiling(const ge::Shape& inputShape, const ge::Shape& outputShape, uint32_t dtypeSize);

int32_t main(int32_t argc, char* argv[])
{
    uint32_t numBlocks = 1;
    size_t inputSize = 48 * sizeof(float);
    size_t outputSize = 96 * 48 * sizeof(float);
    std::vector<int64_t> inputDims = {1, 48};
    std::vector<int64_t> outputDims = {96, 48};
    if (argc == 2) {
        if (!strcmp(argv[1], "1")) {
            inputSize = 96 * sizeof(float);
            outputSize = 96 * 96 * sizeof(float);
            inputDims = {96, 1};
            outputDims = {96, 96};
        }
    }
    ge::Shape inputShape(inputDims);
    ge::Shape outputShape(outputDims);
    size_t tilingSize = TILINGDATA_SIZE * sizeof(uint32_t); // tilingData size , defined in broadcast_custom_tiling.h
    int64_t wrongNum = -1;
    uint8_t* tilingBuf = GenerateTiling(inputShape, outputShape, sizeof(float));

    aclInit(nullptr);
    aclrtContext context;
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtCreateContext(&context, deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *xHost, *yHost, *tilingHost;
    uint8_t *xDevice, *yDevice, *tilingDevice;

    aclrtMallocHost((void**)(&xHost), inputSize);
    aclrtMallocHost((void**)(&yHost), outputSize);
    aclrtMallocHost((void**)(&tilingHost), tilingSize);
    aclrtMalloc((void**)&xDevice, inputSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&yDevice, outputSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&tilingDevice, tilingSize, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/input.bin", inputSize, xHost, inputSize);

    aclrtMemcpy(xDevice, inputSize, xHost, inputSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(tilingDevice, tilingSize, tilingBuf, tilingSize, ACL_MEMCPY_HOST_TO_DEVICE);

    broadcast_custom<<<numBlocks, nullptr, stream>>>(xDevice, yDevice, nullptr, tilingDevice);
    aclrtSynchronizeStream(stream);

    aclrtMemcpy(yHost, outputSize, yDevice, outputSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", yHost, outputSize);

    wrongNum = CompareResult(yHost, outputSize);

    aclrtFree(xDevice);
    aclrtFree(yDevice);
    aclrtFree(tilingDevice);
    aclrtFreeHost(xHost);
    aclrtFreeHost(yHost);
    aclrtFreeHost(tilingHost);

    aclrtDestroyStream(stream);
    aclrtDestroyContext(context);
    aclrtResetDevice(deviceId);
    aclFinalize();
    free(tilingBuf);
    if (wrongNum != 0) {
        printf("test failed!\n");
    } else {
        printf("test pass!\n");
    }
    return 0;
}