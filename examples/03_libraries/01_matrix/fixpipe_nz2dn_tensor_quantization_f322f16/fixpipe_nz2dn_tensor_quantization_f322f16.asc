/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file fixpipe_nz2dn_tensor_quantization_f322f16.asc
 * \brief
 */
#include <cstdint>
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include "acl/acl.h"
#include "kernel_operator.h"
#include "data_utils.h"

constexpr int32_t ONE_BLK_SIZE = 32;

template <typename FmT, typename WT, typename L1outT, typename DstT>
class KernelFixpipe {
public:
    __aicore__ inline KernelFixpipe(const uint16_t C1_in, const uint16_t H_in, const uint16_t W_in, const uint8_t Kh_in,
        const uint8_t Kw_in, const uint16_t Cout_in, const uint16_t C0_in, const uint16_t dilation_h_in,
        const uint16_t dilation_w_in) {
        C1 = C1_in;
        H = H_in;
        W = W_in;
        Kh = Kh_in;
        Kw = Kw_in;
        Cout = Cout_in;
        C0 = C0_in;
        dilation_h = dilation_h_in;
        dilation_w = dilation_w_in;
        channel_size = C0 * C1;
        cout_blocks = (Cout +16 - 1) / 16;
        ho = H - dilation_h * (Kh - 1);
        wo = W - dilation_w * (Kw - 1);
        howo = ho * wo;
        howo_round =((howo + 16 - 1) / 16) * 16;
        feature_map_size = C1 * H * W * C0;
        weight_size = C1 * Kh * Kw * Cout * C0;
        feature_map_l0a_size = howo_round * (C1 * Kh * Kw * C0);
        weight_l0b_size = (C1 * Kh * Kw * C0) * cout_blocks *16;
        m = howo;
        k = C1 * Kh * Kw * C0;
        n = Cout;
        bias_size = Cout;
        deq_size = Cout;
        dst_size = cout_blocks * howo * 16;
        dst_l0c_size = cout_blocks * howo_round * 16;
        dstStride = (m + 16 - 1) / 16;
        }
    __aicore__ inline void Init(__gm__ uint8_t* fm_data, __gm__ uint8_t* we_data, __gm__ uint8_t* deq_tensor, __gm__ uint8_t* output_data)
    {
        feature_map_gm.SetGlobalBuffer(reinterpret_cast<__gm__ FmT *>(fm_data), feature_map_size);
        weight_gm.SetGlobalBuffer(reinterpret_cast<__gm__ WT *>(we_data), weight_size);
        deq_tensor_gm.SetGlobalBuffer(reinterpret_cast<__gm__ uint64_t *>(deq_tensor), deq_size);
        output_gm.SetGlobalBuffer(reinterpret_cast<__gm__ DstT *>(output_data), dst_size);
        pipe.InitBuffer(inQueueA1, 1, feature_map_size*sizeof(FmT));
        pipe.InitBuffer(inQueueB1, 1, weight_size*sizeof(WT));
        pipe.InitBuffer(inQueueA2, 1, feature_map_l0a_size*sizeof(FmT));
        pipe.InitBuffer(inQueueB2, 1, weight_l0b_size*sizeof(WT));
        pipe.InitBuffer(outQueueCO1, 1, dst_l0c_size*sizeof(L1outT));
        pipe.InitBuffer(deqQueue, 1 ,deq_size*sizeof(uint64_t));
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        SplitA();
        SplitB();
        Compute();
        CopyOut();
    }

private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<FmT> feature_map_l1 = inQueueA1.AllocTensor<FmT>();
        AscendC::LocalTensor<WT> weight_l1 = inQueueB1.AllocTensor<WT>();
        AscendC::DataCopy(feature_map_l1, feature_map_gm, {1, static_cast<uint16_t>(feature_map_size * sizeof(FmT) / 32), 0, 0});
        AscendC::DataCopy(weight_l1, weight_gm, {1, static_cast<uint16_t>(weight_size * sizeof(WT) / 32), 0, 0});
        inQueueA1.EnQue(feature_map_l1);
        inQueueB1.EnQue(weight_l1);
    }
    __aicore__ inline void SplitA()
    {
        AscendC::LocalTensor<FmT> feature_map_l1 = inQueueA1.DeQue<FmT>();
        AscendC::LocalTensor<FmT> feature_map_l0a = inQueueA2.AllocTensor<FmT>();
        uint8_t padList[AscendC::PAD_SIZE] = {0, 0, 0, 0};
        AscendC::SetLoadDataRepeat({0, 1, 0, dstStride});
        AscendC::LoadData(feature_map_l0a, feature_map_l1,
            {padList, H, W, channel_size, k, howo_round, 0,
                0, 1, 1, Kw, Kh, dilation_w, dilation_h, false, false, 0});
        inQueueA2.EnQue<FmT>(feature_map_l0a);
        inQueueA1.FreeTensor(feature_map_l1);
    }
    __aicore__ inline void SplitB()
    {
        AscendC::LocalTensor<WT> weight_l1 = inQueueB1.DeQue<WT>();
        AscendC::LocalTensor<WT> weight_l0b = inQueueB2.AllocTensor<WT>();
        uint16_t nAlign = n * sizeof(WT) / 32;
        uint16_t kAlign = k/16;
        uint16_t we_mstep = kAlign;
        uint16_t we_kstep = nAlign;
        AscendC::LoadData2DParamsV2 loadDataParams = {0, 0, we_mstep, we_kstep, we_mstep, we_mstep, false, 0};
        AscendC::LoadData(weight_l0b, weight_l1, loadDataParams);
        inQueueB1.FreeTensor(weight_l1);
        inQueueB2.EnQue<WT>(weight_l0b);
    }
    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<FmT> feature_map_l0a = inQueueA2.DeQue<FmT>();
        AscendC::LocalTensor<WT> weight_l0b = inQueueB2.DeQue<WT>();
        AscendC::LocalTensor<L1outT> dst_l0c = outQueueCO1.AllocTensor<L1outT>();
        AscendC::LocalTensor<uint64_t> cbufWorkSpace = deqQueue.AllocTensor<uint64_t>();
        AscendC::Mmad(dst_l0c, feature_map_l0a, weight_l0b, {m, n, k, 0, false, true});
        outQueueCO1.EnQue<L1outT>(dst_l0c);
        deqQueue.EnQue<uint64_t>(cbufWorkSpace);
        inQueueA2.FreeTensor(feature_map_l0a);
        inQueueB2.FreeTensor(weight_l0b);
    }
    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<L1outT> dst_l0c = outQueueCO1.DeQue<L1outT>();
        AscendC::LocalTensor<uint64_t> cbufWorkspace = deqQueue.DeQue<uint64_t>();
        uint16_t deqDataSize = AscendC::DivCeil(deq_size * sizeof(uint64_t), 128) * 128;
        float tmp = 0.5;
        uint64_t val = static_cast<uint64_t>(*reinterpret_cast<int32_t*>(&tmp));
        AscendC::FixpipeParamsC310<AscendC::CO2Layout::COLUMN_MAJOR> fixpipeParams = {n, m, static_cast<uint16_t>(AscendC::AlignUp(m, AscendC::BLOCK_CUBE)), m};
        fixpipeParams.params = {1, 0, 0, 1};
        fixpipeParams.reluEn = 1;
        fixpipeParams.quantPre = F322F16;
        AscendC::Fixpipe<DstT, L1outT, AscendC::CFG_COLUMN_MAJOR>(output_gm, dst_l0c, fixpipeParams);
        outQueueCO1.FreeTensor(dst_l0c);
        deqQueue.FreeTensor(cbufWorkspace);
    }

    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::TPosition::A1, 1> inQueueA1;
    AscendC::TQue<AscendC::TPosition::B1, 1> inQueueB1;
    AscendC::TQue<AscendC::TPosition::A2, 1> inQueueA2;
    AscendC::TQue<AscendC::TPosition::B2, 1> inQueueB2;
    AscendC::TQue<AscendC::TPosition::CO1, 1> outQueueCO1;
    AscendC::TQue<AscendC::TPosition::C1, 1> deqQueue;
    AscendC::GlobalTensor<FmT> feature_map_gm;
    AscendC::GlobalTensor<WT> weight_gm;
    AscendC::GlobalTensor<L1outT> bias_gm;
    AscendC::GlobalTensor<uint64_t> deq_tensor_gm;
    AscendC::GlobalTensor<DstT> output_gm;
    uint16_t C1;
    uint16_t H;
    uint16_t W;
    uint8_t Kh;
    uint8_t Kw;
    uint16_t Cout;
    uint16_t C0;
    uint8_t dilation_h;
    uint8_t dilation_w;
    uint16_t channel_size;
    uint16_t cout_blocks;
    uint16_t ho;
    uint16_t wo;
    uint16_t howo;
    uint16_t howo_round;
    uint32_t feature_map_size;
    uint32_t weight_size;
    uint32_t feature_map_l0a_size;
    uint32_t weight_l0b_size;
    uint16_t m;
    uint16_t k;
    uint16_t n;
    uint32_t bias_size;
    uint32_t deq_size;
    uint32_t dst_size;
    uint32_t dst_l0c_size;
    uint16_t dstStride;
};

extern "C" __global__ __cube__ void fixpipe_nz2dn_tensor_quantization_f322f16_custom(        \
    GM_ADDR fm_data, GM_ADDR we_data, GM_ADDR deq_tensor, GM_ADDR tiling, GM_ADDR output_data)                                  \
{                                                                                                                               \
    AscendC::GlobalTensor<uint32_t> tiling_global;                                                                              \
    tiling_global.SetGlobalBuffer(reinterpret_cast<__gm__ uint32_t *>(tiling), 16);                                             \
    const uint16_t C1 = (uint16_t)tiling_global.GetValue(0);                                                                    \
    const uint16_t H = (uint16_t)tiling_global.GetValue(1);                                                                     \
    const uint16_t W = (uint16_t)tiling_global.GetValue(2);                                                                     \
    const uint8_t Kh = (uint8_t)tiling_global.GetValue(3);                                                                      \
    const uint8_t Kw = (uint8_t)tiling_global.GetValue(4);                                                                      \
    const uint16_t Cout = (uint16_t)tiling_global.GetValue(5);                                                                  \
    const uint16_t C0 = (uint16_t)tiling_global.GetValue(6);                                                                    \
    const uint8_t dilation_h = (uint8_t)tiling_global.GetValue(7);                                                              \
    const uint8_t dilation_w = (uint8_t)tiling_global.GetValue(8);                                                              \
                                                                                                                                \
    KernelFixpipe<half, half, float, half> op(C1, H, W, Kh, Kw, Cout, C0, dilation_h, dilation_w);         \
    op.Init(fm_data, we_data, deq_tensor, output_data);                                                                         \
    op.Process();                                                                                                               \
}

int32_t main(int32_t argc, char* argv[])
{
    size_t param1FileSize = 512 * sizeof(half);
    size_t param2FileSize = 16384 * sizeof(half); 
    size_t param3FileSize = 128 * sizeof(uint64_t);
    size_t param4FileSize = 16 * sizeof(uint32_t);
    size_t param5FileSize = 512 * sizeof(half);
    uint32_t numBlocks = 1;

    aclInit(nullptr);
    aclrtContext context;
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtCreateContext(&context, deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t* param1Host;
    uint8_t* param1Device;
    aclrtMallocHost((void**)(&param1Host), param1FileSize);
    aclrtMalloc((void**)&param1Device, param1FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/fm_data.bin", param1FileSize, param1Host, param1FileSize);
    aclrtMemcpy(param1Device, param1FileSize, param1Host, param1FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param2Host;
    uint8_t* param2Device;
    aclrtMallocHost((void**)(&param2Host), param2FileSize);
    aclrtMalloc((void**)&param2Device, param2FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/we_data.bin", param2FileSize, param2Host, param2FileSize);
    aclrtMemcpy(param2Device, param2FileSize, param2Host, param2FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param3Host;
    uint8_t* param3Device;
    aclrtMallocHost((void**)(&param3Host), param3FileSize);
    aclrtMalloc((void**)&param3Device, param3FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/deq_tensor.bin", param3FileSize, param3Host, param3FileSize);
    aclrtMemcpy(param3Device, param3FileSize, param3Host, param3FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param4Host;
    uint8_t* param4Device;
    aclrtMallocHost((void**)(&param4Host), param4FileSize);
    aclrtMalloc((void**)&param4Device, param4FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/tiling.bin", param4FileSize, param4Host, param4FileSize);
    aclrtMemcpy(param4Device, param4FileSize, param4Host, param4FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* param5Host;
    uint8_t* param5Device;
    aclrtMallocHost((void**)(&param5Host), param5FileSize);
    aclrtMalloc((void**)&param5Device, param5FileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    fixpipe_nz2dn_tensor_quantization_f322f16_custom<<<numBlocks, nullptr, stream>>>(param1Device, param2Device, param3Device, param4Device, param5Device);
    aclrtSynchronizeStream(stream);

    aclrtFree(param1Device);
    aclrtFreeHost(param1Host);
    aclrtFree(param2Device);
    aclrtFreeHost(param2Host);
    aclrtFree(param3Device);
    aclrtFreeHost(param3Host);
    aclrtFree(param4Device);
    aclrtFreeHost(param4Host);
    aclrtMemcpy(param5Host, param5FileSize, param5Device, param5FileSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", param5Host, param5FileSize);
    aclrtFree(param5Device);
    aclrtFreeHost(param5Host);

    aclrtDestroyStream(stream);
    aclrtDestroyContext(context);
    aclrtResetDevice(deviceId);
    aclFinalize();
    return 0;
}
