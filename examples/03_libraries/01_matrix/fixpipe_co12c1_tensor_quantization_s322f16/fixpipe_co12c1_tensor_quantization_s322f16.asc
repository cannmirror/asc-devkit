/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file fixpipe_co12c1_tensor_quantization_s322f16.asc
 * \brief
 */

#include "acl/acl.h"
#include "kernel_operator.h"
#include "data_utils.h"

constexpr uint32_t M = 32;
constexpr uint32_t N = 32;
constexpr uint32_t K = 32;

template <typename C_T, typename A_T, typename B_T, typename dstCO1_T>
class KernelMatmul {
public:
    __aicore__ inline KernelMatmul(){};

    __aicore__ inline void Init(__gm__ uint8_t* a, __gm__ uint8_t* b, __gm__ uint8_t* c, __gm__ uint8_t* deqTensor, AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;

        aGM.SetGlobalBuffer((__gm__ A_T*)a);
        bGM.SetGlobalBuffer((__gm__ B_T*)b);
        cGM.SetGlobalBuffer((__gm__ C_T*)c);
        deqTensorGM.SetGlobalBuffer((__gm__ uint64_t*)deqTensor);

        pipe->InitBuffer(inQueueA1, 1, (M * K) * sizeof(A_T));
        pipe->InitBuffer(inQueueA2, 1, (M * K) * sizeof(A_T));
        pipe->InitBuffer(inQueueB1, 1, (K * N) * sizeof(B_T));
        pipe->InitBuffer(inQueueB2, 2, (K * N) * sizeof(B_T));
        pipe->InitBuffer(outQueueCO1, 1, (M * N) * sizeof(dstCO1_T));
        pipe->InitBuffer(outQueueC1, 1, (M * N) * sizeof(C_T));
        pipe->InitBuffer(deqQueue, 1, N * sizeof(uint64_t));
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        SplitA();
        SplitB();
        Compute();
        CopyOut();
    }

private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<A_T> a1Local = inQueueA1.AllocTensor<A_T>();
        AscendC::LocalTensor<B_T> b1Local = inQueueB1.AllocTensor<B_T>();
        AscendC::LocalTensor<uint64_t> deqLocal = deqQueue.AllocTensor<uint64_t>();

        AscendC::Nd2NzParams dataCopyA1Params;
        dataCopyA1Params.ndNum = 1;
        dataCopyA1Params.nValue = M;
        dataCopyA1Params.dValue = K;
        dataCopyA1Params.srcNdMatrixStride = 0;
        dataCopyA1Params.srcDValue = K;
        dataCopyA1Params.dstNzC0Stride = M;
        dataCopyA1Params.dstNzNStride = 1;
        dataCopyA1Params.dstNzMatrixStride = 0;

        AscendC::Nd2NzParams dataCopyB1Params;
        dataCopyB1Params.ndNum = 1;
        dataCopyB1Params.nValue = K;
        dataCopyB1Params.dValue = N;
        dataCopyB1Params.srcNdMatrixStride = 0;
        dataCopyB1Params.srcDValue = N;
        dataCopyB1Params.dstNzC0Stride = K;
        dataCopyB1Params.dstNzNStride = 1;
        dataCopyB1Params.dstNzMatrixStride = 0;

        // AscendC::DataCopy GM->L1:ND->大N小z
        AscendC::DataCopy(a1Local, aGM, dataCopyA1Params);
        AscendC::DataCopy(b1Local, bGM, dataCopyB1Params);
        AscendC::DataCopy(deqLocal, deqTensorGM, N);

        inQueueA1.EnQue(a1Local);
        inQueueB1.EnQue(b1Local);
        deqQueue.EnQue(deqLocal);
    }
    __aicore__ inline void SplitA()
    {
        AscendC::LocalTensor<A_T> a1Local = inQueueA1.DeQue<A_T>();
        AscendC::LocalTensor<A_T> a2Local = inQueueA2.AllocTensor<A_T>();

        // AscendC::LoadData L1->L0A
        uint16_t mBlocks = M / AscendC::BLOCK_CUBE;
        uint16_t kBlocks = K / (AscendC::ONE_BLK_SIZE / sizeof(A_T));
        AscendC::LoadData2dParams loadL0AParams;
        loadL0AParams.repeatTimes = mBlocks;
        loadL0AParams.srcStride = 1;
        loadL0AParams.dstGap = kBlocks - 1;
        loadL0AParams.ifTranspose = false;
        for (int i = 0; i < kBlocks; i++) {
            AscendC::LoadData(a2Local[i * AscendC::BLOCK_CUBE * (AscendC::ONE_BLK_SIZE / sizeof(A_T))],
                              a1Local[i * M * (AscendC::ONE_BLK_SIZE / sizeof(A_T))], loadL0AParams);
        }
        inQueueA2.EnQue<A_T>(a2Local);
        inQueueA1.FreeTensor(a1Local);
    }
    __aicore__ inline void SplitB()
    {
        AscendC::LocalTensor<B_T> b1Local = inQueueB1.DeQue<B_T>();
        AscendC::LocalTensor<B_T> b2Local = inQueueB2.AllocTensor<B_T>();

        // Load2d transpose L1->L0B
        AscendC::LoadData2dTransposeParams loadDataParams;
        loadDataParams.startIndex = 0;
        loadDataParams.srcStride = 1;
        loadDataParams.addrMode = 0;
        loadDataParams.repeatTimes = K * N / B8_SIZE;
        loadDataParams.dstGap = N / AscendC::ONE_BLK_SIZE - 1;
        loadDataParams.dstFracGap = 0;
        AscendC::LoadDataWithTranspose(b2Local, b1Local, loadDataParams);
        inQueueB1.FreeTensor(b1Local);
        inQueueB2.EnQue<B_T>(b2Local);
    }
    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<A_T> a2Local = inQueueA2.DeQue<A_T>();
        AscendC::LocalTensor<B_T> b2Local = inQueueB2.DeQue<B_T>();
        AscendC::LocalTensor<dstCO1_T> c1Local = outQueueCO1.AllocTensor<dstCO1_T>();
        AscendC::MmadParams mmadParams;
        mmadParams.m = M;
        mmadParams.n = N;
        mmadParams.k = K;
        AscendC::Mmad(c1Local, a2Local, b2Local, mmadParams); // M*N
        outQueueCO1.EnQue<dstCO1_T>(c1Local);
        inQueueA2.FreeTensor(a2Local);
        inQueueB2.FreeTensor(b2Local);
    }
    __aicore__ inline void CopyOut()
    {
        float val = 2.0;

        AscendC::LocalTensor<dstCO1_T> co1Local = outQueueCO1.DeQue<dstCO1_T>();
        AscendC::LocalTensor<C_T> c1Local = outQueueC1.AllocTensor<C_T>();
        AscendC::LocalTensor<uint64_t> deqTensorLocal = deqQueue.DeQue<uint64_t>();

        AscendC::FixpipeParamsV220 fixpipeParams;
        fixpipeParams.nSize = N;
        fixpipeParams.mSize = M;
        fixpipeParams.srcStride = M;
        fixpipeParams.dstStride = M * AscendC::BLOCK_CUBE * sizeof(C_T) / AscendC::ONE_BLK_SIZE;
        fixpipeParams.quantPre = QuantMode_t::VDEQF16;
        AscendC::Fixpipe<C_T, dstCO1_T, AscendC::CFG_NZ>(c1Local, co1Local, deqTensorLocal, fixpipeParams);
        outQueueCO1.FreeTensor(co1Local);
        deqQueue.FreeTensor(deqTensorLocal);

        event_t eventIDFIXToMTE3 = static_cast<event_t>(GetTPipePtr()->FetchEventID(AscendC::HardEvent::FIX_MTE3));
        AscendC::SetFlag<AscendC::HardEvent::FIX_MTE3>(eventIDFIXToMTE3);
        AscendC::WaitFlag<AscendC::HardEvent::FIX_MTE3>(eventIDFIXToMTE3);
        AscendC::DataCopyParams dataCopyInfo;
        dataCopyInfo.blockCount = 1;
        dataCopyInfo.blockLen = N * M * sizeof(C_T) / AscendC::ONE_BLK_SIZE;
        AscendC::DataCopy(cGM, c1Local, dataCopyInfo);
        outQueueC1.FreeTensor(c1Local);
    }

private:
    AscendC::TPipe* pipe;
    AscendC::TQue<AscendC::TPosition::A1, 1> inQueueA1;
    AscendC::TQue<AscendC::TPosition::A2, 1> inQueueA2;
    AscendC::TQue<AscendC::TPosition::B1, 1> inQueueB1;
    AscendC::TQue<AscendC::TPosition::B2, 1> inQueueB2;
    AscendC::TQue<AscendC::TPosition::CO1, 1> outQueueCO1;
    AscendC::TQue<AscendC::TPosition::C1, 1> outQueueC1;
    AscendC::TQue<AscendC::TPosition::C1, 1> deqQueue;

    AscendC::GlobalTensor<A_T> aGM;
    AscendC::GlobalTensor<B_T> bGM;
    AscendC::GlobalTensor<C_T> cGM;
    AscendC::GlobalTensor<uint64_t> deqTensorGM;

    uint16_t B8_SIZE = 32 * 32;
};

extern "C" __global__ __aicore__ void fixpipe_co12c1_tensor_quantization_s322f16(__gm__ uint8_t* a, __gm__ uint8_t* b,
                                                                                 __gm__ uint8_t* c, __gm__ uint8_t* deq)
{
    KERNEL_TASK_TYPE_DEFAULT(KERNEL_TYPE_AIC_ONLY);

    AscendC::TPipe pipe;
    KernelMatmul<half, int8_t, int8_t, int32_t> op;
    op.Init(a, b, c, deq, &pipe);
    op.Process();
}

int32_t main(int32_t argc, char* argv[])
{
    size_t aFileSize = M * K * sizeof(uint8_t);
    size_t bFileSize = K * N * sizeof(uint8_t);
    size_t cFileSize = M * N * sizeof(half);
    size_t deqFileSize = N * sizeof(uint64_t);
    uint32_t blockDim = 1;

    aclInit(nullptr);
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t* aHost;
    uint8_t* aDevice;
    aclrtMallocHost((void**)(&aHost), aFileSize);
    aclrtMalloc((void**)&aDevice, aFileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/x1_gm.bin", aFileSize, aHost, aFileSize);
    aclrtMemcpy(aDevice, aFileSize, aHost, aFileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* bHost;
    uint8_t* bDevice;
    aclrtMallocHost((void**)(&bHost), bFileSize);
    aclrtMalloc((void**)&bDevice, bFileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/x2_gm.bin", bFileSize, bHost, bFileSize);
    aclrtMemcpy(bDevice, bFileSize, bHost, bFileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* deqHost;
    uint8_t* deqDevice;
    aclrtMallocHost((void**)(&deqHost), deqFileSize);
    aclrtMalloc((void**)&deqDevice, deqFileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/quant_vector_gm.bin", deqFileSize, deqHost, deqFileSize);
    aclrtMemcpy(deqDevice, deqFileSize, deqHost, deqFileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    uint8_t* cHost;
    uint8_t* cDevice;
    aclrtMallocHost((void**)(&cHost), cFileSize);
    aclrtMalloc((void**)&cDevice, cFileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    fixpipe_co12c1_tensor_quantization_s322f16<<<blockDim, nullptr, stream>>>(aDevice, bDevice, cDevice, deqDevice);
    aclrtSynchronizeStream(stream);

    aclrtMemcpy(cHost, cFileSize, cDevice, cFileSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", cHost, cFileSize);

    aclrtFree(aDevice);
    aclrtFreeHost(aHost);
    aclrtFree(bDevice);
    aclrtFreeHost(bHost);
    aclrtFree(cDevice);
    aclrtFreeHost(cHost);

    aclrtDestroyStream(stream);
    aclrtResetDevice(deviceId);
    aclFinalize();
    return 0;
}