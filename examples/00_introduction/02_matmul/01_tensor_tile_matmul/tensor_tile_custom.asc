/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/

#include <cstdint>
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include "acl/acl.h"
#include "kernel_operator.h"
#include "../01_add/data_utils.h"

class E2eCase {
public:
    __aicore__ inline E2eCase () {}
    __aicore__ inline void Init(int32_t m, int32_t n, int32_t k)
    {
        mLength = m;
        nLength = n;
        kLength = k;
        b1Address = mLength * kLength * sizeof(half);
    }
    __aicore__ inline void SetTensorA(const AscendC::GlobalTensor<half>& gm)
    {
        aGlobal_ = gm;
    }
    __aicore__ inline void SetTensorB(const AscendC::GlobalTensor<half>& gm)
    {
        bGlobal_ = gm;
    }
    __aicore__ inline void CopyGmToA1()
    {
        auto srcLayout = AscendC::MakeRowMajorLayout<half>(mLength, kLength);
        auto dstLayout = AscendC::MakeNZLayout<half>(mLength, kLength);

        auto srcTrait = AscendC::MakeTensorTrait<half, AscendC::TPosition::GM>(srcLayout);
        auto dstTrait = AscendC::MakeTensorTrait<half, AscendC::TPosition::A1>(dstLayout);

        using srcTraitType = decltype(srcTrait);
        using dstTraitType = decltype(dstTrait);

        AscendC::GlobalTensor<srcTraitType> aGlobalTrait;
        aGlobalTrait.SetTensorTrait(srcTrait);
        aGlobalTrait.address_ = aGlobal_.address_;
        aGlobalTrait.oriAddress_ = aGlobal_.oriAddress_;
        aGlobalTrait.bufferSize_ = aGlobal_.bufferSize_;
        aGlobalTrait.cacheMode_ = aGlobal_.cacheMode_;

        AscendC::LocalTensor<dstTraitType> leftMatrixTrait(a1Address, dstLayout);
        leftMatrixTrait.SetTensorTrait(dstTrait);
        
        AscendC::DataCopy(leftMatrixTrait, aGlobalTrait);
    }

    __aicore__ inline void CopyGmToB1()
    {
        auto srcLayout = AscendC::MakeRowMajorLayout<half>(kLength, nLength);
        auto dstLayout = AscendC::MakeNZLayout<half>(kLength, nLength);

        auto srcTrait = AscendC::MakeTensorTrait<half, AscendC::TPosition::GM>(srcLayout);
        auto dstTrait = AscendC::MakeTensorTrait<half, AscendC::TPosition::B1>(dstLayout);

        using srcTraitType = decltype(srcTrait);
        using dstTraitType = decltype(dstTrait);

        AscendC::GlobalTensor<srcTraitType> bGlobalTrait;
        bGlobalTrait.SetTensorTrait(srcTrait);
        bGlobalTrait.address_ = bGlobal_.address_;
        bGlobalTrait.oriAddress_ = bGlobal_.oriAddress_;
        bGlobalTrait.bufferSize_ = bGlobal_.bufferSize_;
        bGlobalTrait.cacheMode_ = bGlobal_.cacheMode_;

        AscendC::LocalTensor<dstTraitType> rightMatrixTrait(b1Address, dstLayout);
        rightMatrixTrait.SetTensorTrait(dstTrait);
        
        AscendC::DataCopy(rightMatrixTrait, bGlobalTrait);
    }

    __aicore__ inline void Load2DA1ToL0A()
    {
        auto srcLayout = AscendC::MakeNZLayout<half>(mLength, kLength);
        auto dstLayout = AscendC::MakeNZLayout<half>(mLength, kLength);

        auto srcTrait = AscendC::MakeTensorTrait<half, AscendC::TPosition::A1>(srcLayout);
        auto dstTrait = AscendC::MakeTensorTrait<half, AscendC::TPosition::A2>(dstLayout);

        using srcTraitType = decltype(srcTrait);
        using dstTraitType = decltype(dstTrait);

        AscendC::LocalTensor<srcTraitType> a1Matrix(a1Address, srcLayout);
        a1Matrix.SetTensorTrait(srcTrait);

        AscendC::LocalTensor<dstTraitType> a2Matrix(a2Address, dstLayout);
        a2Matrix.SetTensorTrait(dstTrait);

        AscendC::LoadData(a2Matrix, a1Matrix);
    }
  
    __aicore__ inline void Load2DB1ToL0B()
    {
        auto srcLayout = AscendC::MakeNZLayout<half>(kLength, nLength);
        auto dstLayout = AscendC::MakeZNLayout<half>(kLength, nLength);

        auto srcTrait = AscendC::MakeTensorTrait<half, AscendC::TPosition::B1>(srcLayout);
        auto dstTrait = AscendC::MakeTensorTrait<half, AscendC::TPosition::B2>(dstLayout);

        using srcTraitType = decltype(srcTrait);
        using dstTraitType = decltype(dstTrait);

        AscendC::LocalTensor<srcTraitType> b1Matrix(b1Address, srcLayout);
        b1Matrix.SetTensorTrait(srcTrait);

        AscendC::LocalTensor<dstTraitType> b2Matrix(b2Address, dstLayout);
        b2Matrix.SetTensorTrait(dstTrait);

        AscendC::LoadData(b2Matrix, b1Matrix);
    }  

    __aicore__ inline void Compute()
    {
        auto l0aLayout = AscendC::MakeNZLayout<half>(mLength, kLength);
        auto l0aTrait = AscendC::MakeTensorTrait<half, AscendC::TPosition::A2>(l0aLayout);
        using l0aTraitType = decltype(l0aTrait);
        AscendC::LocalTensor<l0aTraitType> a2Matrix(a2Address, l0aLayout);
        a2Matrix.SetTensorTrait(l0aTrait);

        auto l0bLayout = AscendC::MakeNZLayout<half>(kLength, nLength);
        auto l0bTrait = AscendC::MakeTensorTrait<half, AscendC::TPosition::B2>(l0bLayout);
        using l0bTraitType = decltype(l0bTrait);
        AscendC::LocalTensor<l0bTraitType> b2Matrix(b2Address, l0bLayout);
        b2Matrix.SetTensorTrait(l0bTrait);

        auto l0cLayout = AscendC::MakeNZLayout<AscendC::Std::ignore_t>(mLength, nLength);
        auto l0cTrait = AscendC::MakeTensorTrait<float, AscendC::TPosition::CO1>(l0cLayout);
        using l0cTraitType = decltype(l0cTrait);
        AscendC::LocalTensor<l0cTraitType> l0cLocal(l0cAddress, l0cLayout);
        l0cLocal.SetTensorTrait(l0cTrait);

        AscendC::MmadParams mmadParams;
        mmadParams.m = mLength;
        mmadParams.n = nLength;
        mmadParams.k = kLength;
        mmadParams.isBias = false;
        AscendC::Mmad(l0cLocal, a2Matrix, b2Matrix, mmadParams);
    }

    __aicore__ inline void CopyL0cToGm(const AscendC::GlobalTensor<float>& dst)
    {
        auto srcLayout = AscendC::MakeNZLayout<AscendC::Std::ignore_t>(mLength, nLength);
        auto dstLayout = AscendC::MakeRowMajorLayout<float>(mLength, nLength);

        auto srcTrait = AscendC::MakeTensorTrait<float, AscendC::TPosition::CO1>(srcLayout);
        auto dstTrait = AscendC::MakeTensorTrait<float, AscendC::TPosition::GM>(dstLayout);

        using srcTraitType = decltype(srcTrait);
        using dstTraitType = decltype(dstTrait);

        AscendC::LocalTensor<srcTraitType> l0cLocal(l0cAddress, srcLayout);
        l0cLocal.SetTensorTrait(srcTrait);

        AscendC::GlobalTensor<dstTraitType> dstGlobal;
        dstGlobal.SetTensorTrait(dstTrait);
        dstGlobal.address_ = dst.address_;
        dstGlobal.oriAddress_ = dst.oriAddress_;
        dstGlobal.bufferSize_ = dst.bufferSize_;
        
        AscendC::Fixpipe(dstGlobal, l0cLocal);
    }

    __aicore__ inline void Compute(const AscendC::GlobalTensor<float>& gm)
    {
        CopyGmToA1();
        CopyGmToB1();
        AscendC::SetFlag<AscendC::HardEvent::MTE2_MTE1>(EVENT_ID0);
        AscendC::WaitFlag<AscendC::HardEvent::MTE2_MTE1>(EVENT_ID0);
        Load2DA1ToL0A();
        Load2DB1ToL0B();
        AscendC::SetFlag<AscendC::HardEvent::MTE1_M>(EVENT_ID1);
        AscendC::WaitFlag<AscendC::HardEvent::MTE1_M>(EVENT_ID1);
        Compute();
        AscendC::SetFlag<AscendC::HardEvent::M_FIX>(EVENT_ID2);
        AscendC::WaitFlag<AscendC::HardEvent::M_FIX>(EVENT_ID2);
        CopyL0cToGm(gm);
    }
private:
    int32_t mLength = 0;
    int32_t nLength = 0;
    int32_t kLength = 0;

    uint32_t a1Address = 0;
    uint32_t b1Address = 0;
    uint32_t a2Address = 0;
    uint32_t b2Address = 0;
    uint32_t l0cAddress = 0;

    AscendC::GlobalTensor<half> aGlobal_;
    AscendC::GlobalTensor<half> bGlobal_;
};

__global__ __aicore__ void tensor_tile_custom(GM_ADDR x, GM_ADDR y, GM_ADDR z, int32_t m, int32_t n, int32_t k)
{
    AscendC::GlobalTensor<half> aGlobal;
    AscendC::GlobalTensor<half> bGlobal;
    AscendC::GlobalTensor<float> cGlobal;

    aGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ half*>(x), m * k);
    bGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ half*>(y), k * n);
    cGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ float*>(z), m * n);

    E2eCase ins;
    ins.Init(m, n, k);

    ins.SetTensorA(aGlobal);
    ins.SetTensorB(bGlobal);
    ins.Compute(cGlobal);
}


int32_t main(int32_t argc, char *argv[])
{
    uint32_t blockDim = 1;
    int32_t m = 64, n = 64, k = 64;
    size_t aInputByteSize = static_cast<size_t>(1) * m * k * sizeof(half);
    size_t bInputByteSize = static_cast<size_t>(1) * k * n * sizeof(half);
    size_t outputByteSize = static_cast<size_t>(1) * m * n * sizeof(float);
    aclInit(nullptr);
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *xHost, *yHost, *zHost;
    uint8_t *xDevice, *yDevice, *zDevice;

    aclrtMallocHost((void **)(&xHost), aInputByteSize);
    aclrtMallocHost((void **)(&yHost), bInputByteSize);
    aclrtMallocHost((void **)(&zHost), outputByteSize);
    aclrtMalloc((void **)&xDevice, aInputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&yDevice, bInputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&zDevice, outputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/input_x.bin", aInputByteSize, xHost, aInputByteSize);
    ReadFile("./input/input_y.bin", bInputByteSize, yHost, bInputByteSize);

    aclrtMemcpy(xDevice, aInputByteSize, xHost, aInputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(yDevice, bInputByteSize, yHost, bInputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);

    tensor_tile_custom<<<blockDim, nullptr, stream>>>(xDevice, yDevice, zDevice, m, n, k);
    aclrtSynchronizeStream(stream);

    aclrtMemcpy(zHost, outputByteSize, zDevice, outputByteSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", zHost, outputByteSize);

    aclrtFree(xDevice);
    aclrtFree(yDevice);
    aclrtFree(zDevice);
    aclrtFreeHost(xHost);
    aclrtFreeHost(yHost);
    aclrtFreeHost(zHost);

    aclrtDestroyStream(stream);
    aclrtResetDevice(deviceId);
    aclFinalize();

    return 0;
}