/**
 * Copyright (c) 2025 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */

/* !
 * \file vector_add_custom.asc
 * \brief
 */

#include <cassert>
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include "acl/acl.h"
#include "kernel_operator.h"
#include "data_utils.h"

#ifndef ADD_CUSTOM_TILING_H
#define ADD_CUSTOM_TILING_H
#include <cstdint>

struct AddCustomTilingData {
    uint32_t xLen;
    uint32_t yLen;
    uint32_t coef;
    uint32_t axis;
    uint32_t dataType;

    uint32_t isEvenCore;
    uint32_t blockLength;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t lastTileLength;

    uint32_t formerNum;
    uint32_t formerLength;
    uint32_t formerTileNum;
    uint32_t formerTileLength;
    uint32_t formerLastTileLength;

    uint32_t tailNum;
    uint32_t tailLength;
    uint32_t tailTileNum;
    uint32_t tailTileLength;
    uint32_t tailLastTileLength;
};
#endif // ADD_CUSTOM_TILING_H

// bfloat16, float16, float, int8, int16, int32
constexpr uint32_t DATA_TYPE_SIZE[] = {2, 2, 4, 1, 2, 4};
constexpr uint32_t BLOCK_SIZE = 32;
constexpr uint32_t BUFFER_NUM = 2;
constexpr uint32_t UB_BLOCK_NUM = 100; // UB最大可以使用的block数量
constexpr uint32_t MAX_AVAILABLE_UB_BLOCK_NUM = UB_BLOCK_NUM / BUFFER_NUM * BUFFER_NUM;
void TilingParamsCalc(uint32_t length, uint32_t ubBlockNum, uint32_t& tileNum, uint32_t& tileLength,
                      uint32_t& lastTileLength)
{
    assert(ubBlockNum != 0U);
    tileNum = length / ubBlockNum;
    if (length % ubBlockNum == 0U || tileNum == 0U) {
        if (tileNum == 0U) {
            tileNum = 1U;
        }
        if (length < ubBlockNum) {
            tileLength = length;
            lastTileLength = tileLength;
        } else {
            tileLength = ubBlockNum;
            lastTileLength = tileLength;
        }
    } else {
        tileNum++;
        tileLength = ubBlockNum;
        lastTileLength = (uint32_t)(length - (tileNum - 1) * tileLength);
    }
}

void GenerateTilingData(uint8_t* tilingBuf, uint32_t blockDim)
{
    uint32_t xLen;
    uint32_t yLen;
    uint32_t totalLength;
    uint32_t dataTypeSize;

    AddCustomTilingData* tiling = reinterpret_cast<AddCustomTilingData*>(tilingBuf);
    xLen = tiling->xLen;
    yLen = tiling->yLen;
    assert((xLen != 0U) && (yLen != 0U));
    dataTypeSize = DATA_TYPE_SIZE[tiling->dataType];
    totalLength = (xLen > yLen) ? xLen : yLen;

    uint32_t alignNum = BLOCK_SIZE / dataTypeSize;
    assert((alignNum != 0U) && (blockDim != 0U));
    uint32_t shorterAxisLen = (xLen < yLen) ? xLen : yLen;
    uint32_t alignCoef = (tiling->axis == 0U) ? shorterAxisLen : totalLength / shorterAxisLen;
    uint32_t divDimCoef = (tiling->axis == 0U) ? totalLength / shorterAxisLen : shorterAxisLen;
    uint32_t ubBlockAligned =
        (MAX_AVAILABLE_UB_BLOCK_NUM * alignNum / (alignCoef * BUFFER_NUM) * (alignCoef * BUFFER_NUM) == 0U) ?
            MAX_AVAILABLE_UB_BLOCK_NUM :
            MAX_AVAILABLE_UB_BLOCK_NUM * alignNum / (alignCoef * BUFFER_NUM) * (alignCoef * BUFFER_NUM);

    if (divDimCoef % blockDim == 0U) {
        uint32_t blockLength = divDimCoef / blockDim * alignCoef;
        uint32_t tileNum = 0;
        uint32_t tileLength = 0;
        uint32_t lastTileLength = 0;
        if (tiling->axis == 0U) {
            tileNum = blockLength / shorterAxisLen;
            tileLength = shorterAxisLen;
            lastTileLength = tileLength;
        } else {
            TilingParamsCalc(blockLength, ubBlockAligned, tileNum, tileLength, lastTileLength);
        }

        tiling->blockLength = blockLength;
        tiling->tileNum = tileNum;
        tiling->tileLength = tileLength;
        tiling->lastTileLength = lastTileLength;
        tiling->isEvenCore = 1U;
    } else {
        uint32_t formerNum;
        uint32_t tailNum;

        uint32_t formerLength;
        uint32_t tailLength;

        uint32_t formerTileNum;
        uint32_t formerTileLength;
        uint32_t formerLastTileLength;

        uint32_t tailTileNum;
        uint32_t tailTileLength;
        uint32_t tailLastTileLength;
        if (tiling->axis == 0) {
            formerNum = divDimCoef % blockDim;
            tailNum = blockDim - formerNum;

            formerLength = (divDimCoef / blockDim + 1U) * alignCoef;
            tailLength = divDimCoef / blockDim * alignCoef;

            formerTileNum = formerLength / shorterAxisLen;
            formerTileLength = shorterAxisLen;
            formerLastTileLength = shorterAxisLen;

            tailTileNum = tailLength / shorterAxisLen;
            tailTileLength = shorterAxisLen;
            tailLastTileLength = shorterAxisLen;
        } else {
            formerNum = (divDimCoef / BUFFER_NUM) % blockDim;
            tailNum = blockDim - formerNum;

            formerLength = (((divDimCoef / BUFFER_NUM) / blockDim) + 1U) * BUFFER_NUM * alignCoef;
            tailLength = ((divDimCoef / BUFFER_NUM) / blockDim) * BUFFER_NUM * alignCoef;

            TilingParamsCalc(formerLength, ubBlockAligned, formerTileNum, formerTileLength, formerLastTileLength);
            TilingParamsCalc(tailLength, ubBlockAligned, tailTileNum, tailTileLength, tailLastTileLength);
        }

        tiling->formerNum = formerNum;
        tiling->formerLength = formerLength;
        tiling->formerTileNum = formerTileNum;
        tiling->formerTileLength = formerTileLength;
        tiling->formerLastTileLength = formerLastTileLength;

        tiling->tailNum = tailNum;
        tiling->tailLength = tailLength;
        tiling->tailTileNum = tailTileNum;
        tiling->tailTileLength = tailTileLength;
        tiling->tailLastTileLength = tailLastTileLength;
        tiling->isEvenCore = 0U;
    }
}

constexpr uint32_t ADD_BFLOAT16 = 0;
constexpr uint32_t ADD_FLOAT16 = 1;
constexpr uint32_t ADD_FLOAT32 = 2;
constexpr uint32_t ADD_INT8 = 3;
constexpr uint32_t ADD_INT16 = 4;
constexpr uint32_t ADD_INT32 = 5;

constexpr uint32_t BROADCAST_DIM = 2;
constexpr uint32_t BROADCAST_AXIS_ZERO = 0;
constexpr uint32_t BROADCAST_AXIS_ONE = 1;
constexpr uint32_t LAST_TWO_TILE = 2;
template <typename dataType, uint32_t axis>
class KernelAdd;

// 针对axis = 0的场景
template <>
class KernelAdd<bfloat16_t, 0> {
public:
    __aicore__ inline KernelAdd() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, GM_ADDR z, AddCustomTilingData tiling)
    {
        GM_ADDR longerInputPtr;
        GM_ADDR shorterInputPtr;
        if (tiling.xLen > tiling.yLen) {
            longerInputPtr = x;
            shorterInputPtr = y;
            this->shorterAxisLen = tiling.yLen;
        } else {
            longerInputPtr = y;
            shorterInputPtr = x;
            this->shorterAxisLen = tiling.xLen;
        }
        this->coef = tiling.coef;
        if (tiling.isEvenCore) {
            this->tileNum = tiling.tileNum;
            this->tileLength = tiling.tileLength / BUFFER_NUM;
            this->lastTileLength = tiling.lastTileLength;

            xGm.SetGlobalBuffer((__gm__ bfloat16_t*)longerInputPtr + tiling.blockLength * AscendC::GetBlockIdx(),
                                tiling.blockLength);
            yGm.SetGlobalBuffer((__gm__ bfloat16_t*)shorterInputPtr, this->shorterAxisLen);
            zGm.SetGlobalBuffer((__gm__ bfloat16_t*)z + tiling.blockLength * AscendC::GetBlockIdx(),
                                tiling.blockLength);
        } else {
            if (AscendC::GetBlockIdx() < tiling.formerNum) {
                this->tileNum = tiling.formerTileNum;
                this->tileLength = tiling.formerTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.formerLastTileLength;

                xGm.SetGlobalBuffer((__gm__ bfloat16_t*)longerInputPtr + tiling.formerLength * AscendC::GetBlockIdx(),
                                    tiling.formerLength);
                yGm.SetGlobalBuffer((__gm__ bfloat16_t*)shorterInputPtr, this->shorterAxisLen);
                zGm.SetGlobalBuffer((__gm__ bfloat16_t*)z + tiling.formerLength * AscendC::GetBlockIdx(),
                                    tiling.formerLength);
            } else {
                this->tileNum = tiling.tailTileNum;
                this->tileLength = tiling.tailTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.tailLastTileLength;

                xGm.SetGlobalBuffer((__gm__ bfloat16_t*)longerInputPtr + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
                yGm.SetGlobalBuffer((__gm__ bfloat16_t*)shorterInputPtr, this->shorterAxisLen);
                zGm.SetGlobalBuffer((__gm__ bfloat16_t*)z + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
            }
        }
        pipe.InitBuffer(inQueueX, BUFFER_NUM, this->tileLength * sizeof(bfloat16_t));
        pipe.InitBuffer(inQueueY, BUFFER_NUM, this->tileLength * sizeof(bfloat16_t));
        pipe.InitBuffer(outQueueZ, BUFFER_NUM, this->tileLength * sizeof(bfloat16_t));

        pipe.InitBuffer(tmpBuf0, this->tileLength * sizeof(float));
        pipe.InitBuffer(tmpBuf1, this->tileLength * sizeof(float));
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum * BUFFER_NUM;
        for (int32_t i = 0; i < loopCount; i++) {
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<bfloat16_t> xLocal = inQueueX.AllocTensor<bfloat16_t>();
        AscendC::LocalTensor<bfloat16_t> yLocal = inQueueY.AllocTensor<bfloat16_t>();

        AscendC::DataCopyExtParams copyParams = {1, (uint32_t)(this->tileLength * sizeof(bfloat16_t)), 0, 0, 0};
        AscendC::DataCopyPadExtParams<bfloat16_t> padParams = {false, 0, 0, 0};

        AscendC::DataCopyPad<bfloat16_t>(xLocal, xGm[progress * this->tileLength], copyParams, padParams);
        AscendC::DataCopyPad<bfloat16_t>(yLocal, yGm[(progress % BUFFER_NUM) * this->tileLength], copyParams,
                                         padParams);
        inQueueX.EnQue(xLocal);
        inQueueY.EnQue(yLocal);
    }
    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<bfloat16_t> xLocal = inQueueX.DeQue<bfloat16_t>();
        AscendC::LocalTensor<bfloat16_t> yLocal = inQueueY.DeQue<bfloat16_t>();
        AscendC::LocalTensor<bfloat16_t> zLocal = outQueueZ.AllocTensor<bfloat16_t>();

        AscendC::LocalTensor<float> tmpTensor0 = tmpBuf0.Get<float>();
        AscendC::LocalTensor<float> tmpTensor1 = tmpBuf1.Get<float>();

        AscendC::Cast(tmpTensor0, xLocal, AscendC::RoundMode::CAST_NONE, this->tileLength);
        AscendC::Cast(tmpTensor1, yLocal, AscendC::RoundMode::CAST_NONE, this->tileLength);

        AscendC::Add(tmpTensor0, tmpTensor0, tmpTensor1, this->tileLength);
        AscendC::Cast(zLocal, tmpTensor0, AscendC::RoundMode::CAST_RINT, this->tileLength);

        outQueueZ.EnQue<bfloat16_t>(zLocal);
        inQueueX.FreeTensor(xLocal);
        inQueueY.FreeTensor(yLocal);
    }
    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<bfloat16_t> zLocal = outQueueZ.DeQue<bfloat16_t>();
        AscendC::DataCopyExtParams copyParams = {1, (uint32_t)(this->tileLength * sizeof(bfloat16_t)), 0, 0, 0};

        AscendC::DataCopyPad<bfloat16_t>(zGm[progress * this->tileLength], zLocal, copyParams);
        outQueueZ.FreeTensor(zLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueY;
    AscendC::TQue<AscendC::TPosition::VECOUT, BUFFER_NUM> outQueueZ;

    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf0;
    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf1;

    AscendC::GlobalTensor<bfloat16_t> xGm;
    AscendC::GlobalTensor<bfloat16_t> yGm;
    AscendC::GlobalTensor<bfloat16_t> zGm;

    uint32_t coef;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t lastTileLength;
    uint32_t shorterAxisLen;
};

template <>
class KernelAdd<int8_t, 0> {
public:
    __aicore__ inline KernelAdd() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, GM_ADDR z, AddCustomTilingData tiling)
    {
        GM_ADDR longerInputPtr;
        GM_ADDR shorterInputPtr;
        if (tiling.xLen > tiling.yLen) {
            longerInputPtr = x;
            shorterInputPtr = y;
            this->shorterAxisLen = tiling.yLen;
        } else {
            longerInputPtr = y;
            shorterInputPtr = x;
            this->shorterAxisLen = tiling.xLen;
        }
        this->coef = tiling.coef;
        if (tiling.isEvenCore) {
            this->tileNum = tiling.tileNum;
            this->tileLength = tiling.tileLength / BUFFER_NUM;
            this->lastTileLength = tiling.lastTileLength;

            xGm.SetGlobalBuffer((__gm__ int8_t*)longerInputPtr + tiling.blockLength * AscendC::GetBlockIdx(),
                                tiling.blockLength);
            yGm.SetGlobalBuffer((__gm__ int8_t*)shorterInputPtr, this->shorterAxisLen);
            zGm.SetGlobalBuffer((__gm__ int8_t*)z + tiling.blockLength * AscendC::GetBlockIdx(), tiling.blockLength);
        } else {
            if (AscendC::GetBlockIdx() < tiling.formerNum) {
                this->tileNum = tiling.formerTileNum;
                this->tileLength = tiling.formerTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.formerLastTileLength;

                xGm.SetGlobalBuffer((__gm__ int8_t*)longerInputPtr + tiling.formerLength * AscendC::GetBlockIdx(),
                                    tiling.formerLength);
                yGm.SetGlobalBuffer((__gm__ int8_t*)shorterInputPtr, this->shorterAxisLen);
                zGm.SetGlobalBuffer((__gm__ int8_t*)z + tiling.formerLength * AscendC::GetBlockIdx(),
                                    tiling.formerLength);
            } else {
                this->tileNum = tiling.tailTileNum;
                this->tileLength = tiling.tailTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.tailLastTileLength;

                xGm.SetGlobalBuffer((__gm__ int8_t*)longerInputPtr + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
                yGm.SetGlobalBuffer((__gm__ int8_t*)shorterInputPtr, this->shorterAxisLen);
                zGm.SetGlobalBuffer((__gm__ int8_t*)z + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
            }
        }
        pipe.InitBuffer(inQueueX, BUFFER_NUM, this->tileLength * sizeof(int8_t));
        pipe.InitBuffer(inQueueY, BUFFER_NUM, this->tileLength * sizeof(int8_t));
        pipe.InitBuffer(outQueueZ, BUFFER_NUM, this->tileLength * sizeof(int8_t));

        pipe.InitBuffer(tmpBuf0, this->tileLength * sizeof(half));
        pipe.InitBuffer(tmpBuf1, this->tileLength * sizeof(half));
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum * BUFFER_NUM;
        for (int32_t i = 0; i < loopCount; i++) {
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<int8_t> xLocal = inQueueX.AllocTensor<int8_t>();
        AscendC::LocalTensor<int8_t> yLocal = inQueueY.AllocTensor<int8_t>();

        AscendC::DataCopyExtParams copyParams = {1, (uint32_t)(this->tileLength * sizeof(int8_t)), 0, 0, 0};
        AscendC::DataCopyPadExtParams<int8_t> padParams = {false, 0, 0, 0};

        AscendC::DataCopyPad<int8_t>(xLocal, xGm[progress * this->tileLength], copyParams, padParams);
        AscendC::DataCopyPad<int8_t>(yLocal, yGm[(progress % BUFFER_NUM) * this->tileLength], copyParams, padParams);
        inQueueX.EnQue(xLocal);
        inQueueY.EnQue(yLocal);
    }
    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<int8_t> xLocal = inQueueX.DeQue<int8_t>();
        AscendC::LocalTensor<int8_t> yLocal = inQueueY.DeQue<int8_t>();
        AscendC::LocalTensor<int8_t> zLocal = outQueueZ.AllocTensor<int8_t>();

        AscendC::LocalTensor<half> tmpTensor0 = tmpBuf0.Get<half>();
        AscendC::LocalTensor<half> tmpTensor1 = tmpBuf1.Get<half>();

        AscendC::Cast(tmpTensor0, xLocal, AscendC::RoundMode::CAST_NONE, this->tileLength);
        AscendC::Cast(tmpTensor1, yLocal, AscendC::RoundMode::CAST_NONE, this->tileLength);

        AscendC::Add(tmpTensor0, tmpTensor0, tmpTensor1, this->tileLength);
        AscendC::Cast(zLocal, tmpTensor0, AscendC::RoundMode::CAST_NONE, this->tileLength);

        outQueueZ.EnQue<int8_t>(zLocal);
        inQueueX.FreeTensor(xLocal);
        inQueueY.FreeTensor(yLocal);
    }
    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<int8_t> zLocal = outQueueZ.DeQue<int8_t>();
        AscendC::DataCopyExtParams copyParams = {1, (uint32_t)(this->tileLength * sizeof(int8_t)), 0, 0, 0};

        AscendC::DataCopyPad<int8_t>(zGm[progress * this->tileLength], zLocal, copyParams);
        outQueueZ.FreeTensor(zLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueY;
    AscendC::TQue<AscendC::TPosition::VECOUT, BUFFER_NUM> outQueueZ;

    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf0;
    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf1;

    AscendC::GlobalTensor<int8_t> xGm;
    AscendC::GlobalTensor<int8_t> yGm;
    AscendC::GlobalTensor<int8_t> zGm;

    uint32_t coef;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t lastTileLength;
    uint32_t shorterAxisLen;
};

template <typename T>
class KernelAdd<T, 0> {
public:
    __aicore__ inline KernelAdd() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, GM_ADDR z, AddCustomTilingData tiling)
    {
        GM_ADDR longerInputPtr;
        GM_ADDR shorterInputPtr;
        if (tiling.xLen > tiling.yLen) {
            longerInputPtr = x;
            shorterInputPtr = y;
            this->shorterAxisLen = tiling.yLen;
        } else {
            longerInputPtr = y;
            shorterInputPtr = x;
            this->shorterAxisLen = tiling.xLen;
        }
        this->coef = tiling.coef;
        if (tiling.isEvenCore) {
            this->tileNum = tiling.tileNum;
            this->tileLength = tiling.tileLength / BUFFER_NUM;
            this->lastTileLength = tiling.lastTileLength;

            xGm.SetGlobalBuffer((__gm__ T*)longerInputPtr + tiling.blockLength * AscendC::GetBlockIdx(),
                                tiling.blockLength);
            yGm.SetGlobalBuffer((__gm__ T*)shorterInputPtr, this->shorterAxisLen);
            zGm.SetGlobalBuffer((__gm__ T*)z + tiling.blockLength * AscendC::GetBlockIdx(), tiling.blockLength);
        } else {
            if (AscendC::GetBlockIdx() < tiling.formerNum) {
                this->tileNum = tiling.formerTileNum;
                this->tileLength = tiling.formerTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.formerLastTileLength;

                xGm.SetGlobalBuffer((__gm__ T*)longerInputPtr + tiling.formerLength * AscendC::GetBlockIdx(),
                                    tiling.formerLength);
                yGm.SetGlobalBuffer((__gm__ T*)shorterInputPtr, this->shorterAxisLen);
                zGm.SetGlobalBuffer((__gm__ T*)z + tiling.formerLength * AscendC::GetBlockIdx(), tiling.formerLength);
            } else {
                this->tileNum = tiling.tailTileNum;
                this->tileLength = tiling.tailTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.tailLastTileLength;

                xGm.SetGlobalBuffer((__gm__ T*)longerInputPtr + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
                yGm.SetGlobalBuffer((__gm__ T*)shorterInputPtr, this->shorterAxisLen);
                zGm.SetGlobalBuffer((__gm__ T*)z + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
            }
        }
        pipe.InitBuffer(inQueueX, BUFFER_NUM, this->tileLength * sizeof(T));
        pipe.InitBuffer(inQueueY, BUFFER_NUM, this->tileLength * sizeof(T));
        pipe.InitBuffer(outQueueZ, BUFFER_NUM, this->tileLength * sizeof(T));
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum * BUFFER_NUM;
        for (int32_t i = 0; i < loopCount; i++) {
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<T> xLocal = inQueueX.AllocTensor<T>();
        AscendC::LocalTensor<T> yLocal = inQueueY.AllocTensor<T>();

        AscendC::DataCopyExtParams copyParams = {1, (uint32_t)(this->tileLength * sizeof(T)), 0, 0, 0};
        AscendC::DataCopyPadExtParams<T> padParams = {false, 0, 0, 0};

        AscendC::DataCopyPad<T>(xLocal, xGm[progress * this->tileLength], copyParams, padParams);
        AscendC::DataCopyPad<T>(yLocal, yGm[(progress % BUFFER_NUM) * this->tileLength], copyParams, padParams);
        inQueueX.EnQue(xLocal);
        inQueueY.EnQue(yLocal);
    }
    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<T> xLocal = inQueueX.DeQue<T>();
        AscendC::LocalTensor<T> yLocal = inQueueY.DeQue<T>();
        AscendC::LocalTensor<T> zLocal = outQueueZ.AllocTensor<T>();

        AscendC::Add(zLocal, xLocal, yLocal, this->tileLength);

        outQueueZ.EnQue<T>(zLocal);
        inQueueX.FreeTensor(xLocal);
        inQueueY.FreeTensor(yLocal);
    }
    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<T> zLocal = outQueueZ.DeQue<T>();
        AscendC::DataCopyExtParams copyParams = {1, (uint32_t)(this->tileLength * sizeof(T)), 0, 0, 0};

        AscendC::DataCopyPad<T>(zGm[progress * this->tileLength], zLocal, copyParams);
        outQueueZ.FreeTensor(zLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueY;
    AscendC::TQue<AscendC::TPosition::VECOUT, BUFFER_NUM> outQueueZ;

    AscendC::GlobalTensor<T> xGm;
    AscendC::GlobalTensor<T> yGm;
    AscendC::GlobalTensor<T> zGm;

    uint32_t coef;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t lastTileLength;
    uint32_t shorterAxisLen;
};

// 针对axis = 1的场景
template <>
class KernelAdd<bfloat16_t, 1> {
public:
    __aicore__ inline KernelAdd() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, GM_ADDR z, AddCustomTilingData tiling)
    {
        GM_ADDR longerInputPtr;
        GM_ADDR shorterInputPtr;
        if (tiling.xLen > tiling.yLen) {
            longerInputPtr = x;
            shorterInputPtr = y;
        } else {
            longerInputPtr = y;
            shorterInputPtr = x;
        }
        this->coef = tiling.coef;
        if (tiling.isEvenCore) {
            this->tileNum = tiling.tileNum;
            this->tileLength = tiling.tileLength / BUFFER_NUM;
            this->lastTileLength = tiling.lastTileLength;

            xGm.SetGlobalBuffer((__gm__ bfloat16_t*)longerInputPtr + tiling.blockLength * AscendC::GetBlockIdx(),
                                tiling.blockLength);
            yGm.SetGlobalBuffer((__gm__ bfloat16_t*)shorterInputPtr
                                    + tiling.blockLength * AscendC::GetBlockIdx() / this->coef,
                                tiling.blockLength / this->coef);
            zGm.SetGlobalBuffer((__gm__ bfloat16_t*)z + tiling.blockLength * AscendC::GetBlockIdx(),
                                tiling.blockLength);
        } else {
            if (AscendC::GetBlockIdx() < tiling.formerNum) {
                this->tileNum = tiling.formerTileNum;
                this->tileLength = tiling.formerTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.formerLastTileLength;

                xGm.SetGlobalBuffer((__gm__ bfloat16_t*)longerInputPtr + tiling.formerLength * AscendC::GetBlockIdx(),
                                    tiling.formerLength);
                yGm.SetGlobalBuffer((__gm__ bfloat16_t*)shorterInputPtr
                                        + tiling.formerLength * AscendC::GetBlockIdx() / this->coef,
                                    tiling.formerLength / this->coef);
                zGm.SetGlobalBuffer((__gm__ bfloat16_t*)z + tiling.formerLength * AscendC::GetBlockIdx(),
                                    tiling.formerLength);
            } else {
                this->tileNum = tiling.tailTileNum;
                this->tileLength = tiling.tailTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.tailLastTileLength;

                xGm.SetGlobalBuffer((__gm__ bfloat16_t*)longerInputPtr + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
                yGm.SetGlobalBuffer((__gm__ bfloat16_t*)shorterInputPtr
                                        + tiling.formerLength * tiling.formerNum / this->coef
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum) / this->coef,
                                    tiling.tailLength / this->coef);
                zGm.SetGlobalBuffer((__gm__ bfloat16_t*)z + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
            }
        }
        pipe.InitBuffer(inQueueX, BUFFER_NUM, this->tileLength * sizeof(bfloat16_t));
        pipe.InitBuffer(inQueueY, BUFFER_NUM, this->coef * sizeof(bfloat16_t));
        pipe.InitBuffer(outQueueZ, BUFFER_NUM, this->tileLength * sizeof(bfloat16_t));

        pipe.InitBuffer(tmpBuf2, this->tileLength * sizeof(bfloat16_t));
        pipe.InitBuffer(tmpBuf0, this->tileLength * sizeof(float));
        pipe.InitBuffer(tmpBuf1, this->tileLength * sizeof(float));
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum * BUFFER_NUM;
        for (int32_t i = 0; i < loopCount; i++) {
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<bfloat16_t> xLocal = inQueueX.AllocTensor<bfloat16_t>();
        AscendC::LocalTensor<bfloat16_t> yLocal = inQueueY.AllocTensor<bfloat16_t>();

        AscendC::DataCopyExtParams copyXParams = {1, (uint32_t)(this->tileLength * sizeof(bfloat16_t)), 0, 0, 0};
        AscendC::DataCopyExtParams copyYParams = {1, (uint32_t)(this->tileLength * sizeof(bfloat16_t) / this->coef), 0,
                                                  0, 0};
        AscendC::DataCopyPadExtParams<bfloat16_t> padParams = {false, 0, 0, 0};

        if (progress == (this->tileNum * BUFFER_NUM - 1)) {
            AscendC::DataCopyPad<bfloat16_t>(xLocal,
                                             xGm[(progress - LAST_TWO_TILE) * this->tileLength + this->lastTileLength],
                                             copyXParams, padParams);
            AscendC::DataCopyPad<bfloat16_t>(
                yLocal, yGm[((progress - LAST_TWO_TILE) * this->tileLength + this->lastTileLength) / this->coef],
                copyYParams, padParams);
        } else {
            AscendC::DataCopyPad<bfloat16_t>(xLocal, xGm[progress * this->tileLength], copyXParams, padParams);
            AscendC::DataCopyPad<bfloat16_t>(yLocal, yGm[progress * this->tileLength / this->coef], copyYParams,
                                             padParams);
        }
        inQueueX.EnQue(xLocal);
        inQueueY.EnQue(yLocal);
    }
    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<bfloat16_t> xLocal = inQueueX.DeQue<bfloat16_t>();
        AscendC::LocalTensor<bfloat16_t> yLocal = inQueueY.DeQue<bfloat16_t>();
        AscendC::LocalTensor<bfloat16_t> zLocal = outQueueZ.AllocTensor<bfloat16_t>();

        AscendC::LocalTensor<bfloat16_t> broadcastTmpTensor = tmpBuf2.Get<bfloat16_t>();
        uint32_t dstShape[] = {this->tileLength / this->coef, this->coef};
        uint32_t srcShape[] = {this->tileLength / this->coef, 1};
        AscendC::Broadcast<bfloat16_t, BROADCAST_DIM, BROADCAST_AXIS_ONE>(broadcastTmpTensor, yLocal, dstShape,
                                                                          srcShape);

        AscendC::LocalTensor<float> tmpTensor0 = tmpBuf0.Get<float>();
        AscendC::LocalTensor<float> tmpTensor1 = tmpBuf1.Get<float>();

        AscendC::Cast(tmpTensor0, xLocal, AscendC::RoundMode::CAST_NONE, this->tileLength);
        AscendC::Cast(tmpTensor1, broadcastTmpTensor, AscendC::RoundMode::CAST_NONE, this->tileLength);

        AscendC::Add(tmpTensor0, tmpTensor0, tmpTensor1, this->tileLength);
        AscendC::Cast(zLocal, tmpTensor0, AscendC::RoundMode::CAST_RINT, this->tileLength);

        outQueueZ.EnQue<bfloat16_t>(zLocal);
        inQueueX.FreeTensor(xLocal);
        inQueueY.FreeTensor(yLocal);
    }
    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<bfloat16_t> zLocal = outQueueZ.DeQue<bfloat16_t>();
        AscendC::DataCopyExtParams copyParams = {1, (uint32_t)(this->tileLength * sizeof(bfloat16_t)), 0, 0, 0};
        if (progress == (this->tileNum * BUFFER_NUM - 1)) {
            AscendC::DataCopyPad<bfloat16_t>(zGm[(progress - LAST_TWO_TILE) * this->tileLength + this->lastTileLength],
                                             zLocal, copyParams);
        } else {
            AscendC::DataCopyPad<bfloat16_t>(zGm[progress * this->tileLength], zLocal, copyParams);
        }
        outQueueZ.FreeTensor(zLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueY;
    AscendC::TQue<AscendC::TPosition::VECOUT, BUFFER_NUM> outQueueZ;

    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf0;
    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf1;
    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf2;

    AscendC::GlobalTensor<bfloat16_t> xGm;
    AscendC::GlobalTensor<bfloat16_t> yGm;
    AscendC::GlobalTensor<bfloat16_t> zGm;

    uint32_t coef;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t lastTileLength;
};

template <>
class KernelAdd<int8_t, 1> {
public:
    __aicore__ inline KernelAdd() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, GM_ADDR z, AddCustomTilingData tiling)
    {
        GM_ADDR longerInputPtr;
        GM_ADDR shorterInputPtr;
        if (tiling.xLen > tiling.yLen) {
            longerInputPtr = x;
            shorterInputPtr = y;
        } else {
            longerInputPtr = y;
            shorterInputPtr = x;
        }
        this->coef = tiling.coef;
        if (tiling.isEvenCore) {
            this->tileNum = tiling.tileNum;
            this->tileLength = tiling.tileLength / BUFFER_NUM;
            this->lastTileLength = tiling.lastTileLength;

            xGm.SetGlobalBuffer((__gm__ int8_t*)longerInputPtr + tiling.blockLength * AscendC::GetBlockIdx(),
                                tiling.blockLength);
            yGm.SetGlobalBuffer((__gm__ int8_t*)shorterInputPtr
                                    + tiling.blockLength * AscendC::GetBlockIdx() / this->coef,
                                tiling.blockLength / this->coef);
            zGm.SetGlobalBuffer((__gm__ int8_t*)z + tiling.blockLength * AscendC::GetBlockIdx(), tiling.blockLength);
        } else {
            if (AscendC::GetBlockIdx() < tiling.formerNum) {
                this->tileNum = tiling.formerTileNum;
                this->tileLength = tiling.formerTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.formerLastTileLength;

                xGm.SetGlobalBuffer((__gm__ int8_t*)longerInputPtr + tiling.formerLength * AscendC::GetBlockIdx(),
                                    tiling.formerLength);
                yGm.SetGlobalBuffer((__gm__ int8_t*)shorterInputPtr
                                        + tiling.formerLength * AscendC::GetBlockIdx() / this->coef,
                                    tiling.formerLength / this->coef);
                zGm.SetGlobalBuffer((__gm__ int8_t*)z + tiling.formerLength * AscendC::GetBlockIdx(),
                                    tiling.formerLength);
            } else {
                this->tileNum = tiling.tailTileNum;
                this->tileLength = tiling.tailTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.tailLastTileLength;

                xGm.SetGlobalBuffer((__gm__ int8_t*)longerInputPtr + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
                yGm.SetGlobalBuffer((__gm__ int8_t*)shorterInputPtr
                                        + tiling.formerLength * tiling.formerNum / this->coef
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum) / this->coef,
                                    tiling.tailLength / this->coef);
                zGm.SetGlobalBuffer((__gm__ int8_t*)z + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
            }
        }
        pipe.InitBuffer(inQueueX, BUFFER_NUM, this->tileLength * sizeof(int8_t));
        pipe.InitBuffer(inQueueY, BUFFER_NUM, this->coef * sizeof(int8_t));
        pipe.InitBuffer(outQueueZ, BUFFER_NUM, this->tileLength * sizeof(int8_t));

        pipe.InitBuffer(tmpBuf2, this->tileLength * sizeof(int8_t));

        pipe.InitBuffer(tmpBuf0, this->tileLength * sizeof(half));
        pipe.InitBuffer(tmpBuf1, this->tileLength * sizeof(half));
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum * BUFFER_NUM;
        for (int32_t i = 0; i < loopCount; i++) {
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<int8_t> xLocal = inQueueX.AllocTensor<int8_t>();
        AscendC::LocalTensor<int8_t> yLocal = inQueueY.AllocTensor<int8_t>();

        AscendC::DataCopyExtParams copyXParams = {1, (uint32_t)(this->tileLength * sizeof(int8_t)), 0, 0, 0};
        AscendC::DataCopyExtParams copyYParams = {1, (uint32_t)(this->tileLength * sizeof(int8_t) / this->coef), 0, 0,
                                                  0};
        AscendC::DataCopyPadExtParams<int8_t> padParams = {false, 0, 0, 0};

        if (progress == (this->tileNum * BUFFER_NUM - 1)) {
            AscendC::DataCopyPad<int8_t>(xLocal,
                                         xGm[(progress - LAST_TWO_TILE) * this->tileLength + this->lastTileLength],
                                         copyXParams, padParams);
            AscendC::DataCopyPad<int8_t>(
                yLocal, yGm[((progress - LAST_TWO_TILE) * this->tileLength + this->lastTileLength) / this->coef],
                copyYParams, padParams);
        } else {
            AscendC::DataCopyPad<int8_t>(xLocal, xGm[progress * this->tileLength], copyXParams, padParams);
            AscendC::DataCopyPad<int8_t>(yLocal, yGm[progress * this->tileLength / this->coef], copyYParams, padParams);
        }
        inQueueX.EnQue(xLocal);
        inQueueY.EnQue(yLocal);
    }
    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<int8_t> xLocal = inQueueX.DeQue<int8_t>();
        AscendC::LocalTensor<int8_t> yLocal = inQueueY.DeQue<int8_t>();
        AscendC::LocalTensor<int8_t> zLocal = outQueueZ.AllocTensor<int8_t>();

        AscendC::LocalTensor<int8_t> broadcastTmpTensor = tmpBuf2.Get<int8_t>();
        uint32_t dstShape[] = {this->tileLength / this->coef, this->coef};
        uint32_t srcShape[] = {this->tileLength / this->coef, 1};
        AscendC::Broadcast<int8_t, BROADCAST_DIM, BROADCAST_AXIS_ONE>(broadcastTmpTensor, yLocal, dstShape, srcShape);

        AscendC::LocalTensor<half> tmpTensor0 = tmpBuf0.Get<half>();
        AscendC::LocalTensor<half> tmpTensor1 = tmpBuf1.Get<half>();

        AscendC::Cast(tmpTensor0, xLocal, AscendC::RoundMode::CAST_NONE, this->tileLength);
        AscendC::Cast(tmpTensor1, broadcastTmpTensor, AscendC::RoundMode::CAST_NONE, this->tileLength);

        AscendC::Add(tmpTensor0, tmpTensor0, tmpTensor1, this->tileLength);
        AscendC::Cast(zLocal, tmpTensor0, AscendC::RoundMode::CAST_NONE, this->tileLength);

        outQueueZ.EnQue<int8_t>(zLocal);
        inQueueX.FreeTensor(xLocal);
        inQueueY.FreeTensor(yLocal);
    }
    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<int8_t> zLocal = outQueueZ.DeQue<int8_t>();
        AscendC::DataCopyExtParams copyParams = {1, (uint32_t)(this->tileLength * sizeof(int8_t)), 0, 0, 0};
        if (progress == (this->tileNum * BUFFER_NUM - 1)) {
            AscendC::DataCopyPad<int8_t>(zGm[(progress - LAST_TWO_TILE) * this->tileLength + this->lastTileLength],
                                         zLocal, copyParams);
        } else {
            AscendC::DataCopyPad<int8_t>(zGm[progress * this->tileLength], zLocal, copyParams);
        }
        outQueueZ.FreeTensor(zLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueY;
    AscendC::TQue<AscendC::TPosition::VECOUT, BUFFER_NUM> outQueueZ;

    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf0;
    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf1;
    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf2;

    AscendC::GlobalTensor<int8_t> xGm;
    AscendC::GlobalTensor<int8_t> yGm;
    AscendC::GlobalTensor<int8_t> zGm;

    uint32_t coef;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t lastTileLength;
};

template <typename T>
class KernelAdd<T, 1> {
public:
    __aicore__ inline KernelAdd() {}
    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, GM_ADDR z, AddCustomTilingData tiling)
    {
        GM_ADDR longerInputPtr;
        GM_ADDR shorterInputPtr;
        if (tiling.xLen > tiling.yLen) {
            longerInputPtr = x;
            shorterInputPtr = y;
        } else {
            longerInputPtr = y;
            shorterInputPtr = x;
        }
        this->coef = tiling.coef;
        if (tiling.isEvenCore) {
            this->tileNum = tiling.tileNum;
            this->tileLength = tiling.tileLength / BUFFER_NUM;
            this->lastTileLength = tiling.lastTileLength;

            xGm.SetGlobalBuffer((__gm__ T*)longerInputPtr + tiling.blockLength * AscendC::GetBlockIdx(),
                                tiling.blockLength);
            yGm.SetGlobalBuffer((__gm__ T*)shorterInputPtr + tiling.blockLength * AscendC::GetBlockIdx() / this->coef,
                                tiling.blockLength / this->coef);
            zGm.SetGlobalBuffer((__gm__ T*)z + tiling.blockLength * AscendC::GetBlockIdx(), tiling.blockLength);
        } else {
            if (AscendC::GetBlockIdx() < tiling.formerNum) {
                this->tileNum = tiling.formerTileNum;
                this->tileLength = tiling.formerTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.formerLastTileLength;

                xGm.SetGlobalBuffer((__gm__ T*)longerInputPtr + tiling.formerLength * AscendC::GetBlockIdx(),
                                    tiling.formerLength);
                yGm.SetGlobalBuffer((__gm__ T*)shorterInputPtr
                                        + tiling.formerLength * AscendC::GetBlockIdx() / this->coef,
                                    tiling.formerLength / this->coef);
                zGm.SetGlobalBuffer((__gm__ T*)z + tiling.formerLength * AscendC::GetBlockIdx(), tiling.formerLength);
            } else {
                this->tileNum = tiling.tailTileNum;
                this->tileLength = tiling.tailTileLength / BUFFER_NUM;
                this->lastTileLength = tiling.tailLastTileLength;

                xGm.SetGlobalBuffer((__gm__ T*)longerInputPtr + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
                yGm.SetGlobalBuffer((__gm__ T*)shorterInputPtr + tiling.formerLength * tiling.formerNum / this->coef
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum) / this->coef,
                                    tiling.tailLength / this->coef);
                zGm.SetGlobalBuffer((__gm__ T*)z + tiling.formerLength * tiling.formerNum
                                        + tiling.tailLength * (AscendC::GetBlockIdx() - tiling.formerNum),
                                    tiling.tailLength);
            }
        }
        pipe.InitBuffer(inQueueX, BUFFER_NUM, this->tileLength * sizeof(T));
        pipe.InitBuffer(inQueueY, BUFFER_NUM, this->coef * sizeof(T));
        pipe.InitBuffer(outQueueZ, BUFFER_NUM, this->tileLength * sizeof(T));

        pipe.InitBuffer(tmpBuf2, this->tileLength * sizeof(T));
    }
    __aicore__ inline void Process()
    {
        int32_t loopCount = this->tileNum * BUFFER_NUM;
        for (int32_t i = 0; i < loopCount; i++) {
            CopyIn(i);
            Compute(i);
            CopyOut(i);
        }
    }

private:
    __aicore__ inline void CopyIn(int32_t progress)
    {
        AscendC::LocalTensor<T> xLocal = inQueueX.AllocTensor<T>();
        AscendC::LocalTensor<T> yLocal = inQueueY.AllocTensor<T>();

        AscendC::DataCopyExtParams copyXParams = {1, (uint32_t)(this->tileLength * sizeof(T)), 0, 0, 0};
        AscendC::DataCopyExtParams copyYParams = {1, (uint32_t)(this->tileLength * sizeof(T) / this->coef), 0, 0, 0};
        AscendC::DataCopyPadExtParams<T> padParams = {false, 0, 0, 0};

        if (progress == (this->tileNum * BUFFER_NUM - 1)) {
            AscendC::DataCopyPad<T>(xLocal, xGm[(progress - LAST_TWO_TILE) * this->tileLength + this->lastTileLength],
                                    copyXParams, padParams);
            AscendC::DataCopyPad<T>(
                yLocal, yGm[((progress - LAST_TWO_TILE) * this->tileLength + this->lastTileLength) / this->coef],
                copyYParams, padParams);
        } else {
            AscendC::DataCopyPad<T>(xLocal, xGm[progress * this->tileLength], copyXParams, padParams);
            AscendC::DataCopyPad<T>(yLocal, yGm[progress * this->tileLength / this->coef], copyYParams, padParams);
        }
        inQueueX.EnQue(xLocal);
        inQueueY.EnQue(yLocal);
    }
    __aicore__ inline void Compute(int32_t progress)
    {
        AscendC::LocalTensor<T> xLocal = inQueueX.DeQue<T>();
        AscendC::LocalTensor<T> yLocal = inQueueY.DeQue<T>();
        AscendC::LocalTensor<T> zLocal = outQueueZ.AllocTensor<T>();

        AscendC::LocalTensor<T> broadcastTmpTensor = tmpBuf2.Get<T>();
        uint32_t dstShape[] = {this->tileLength / this->coef, this->coef};
        uint32_t srcShape[] = {this->tileLength / this->coef, 1};
        AscendC::Broadcast<T, BROADCAST_DIM, BROADCAST_AXIS_ONE>(broadcastTmpTensor, yLocal, dstShape, srcShape);

        AscendC::Add(zLocal, xLocal, broadcastTmpTensor, this->tileLength);

        outQueueZ.EnQue<T>(zLocal);
        inQueueX.FreeTensor(xLocal);
        inQueueY.FreeTensor(yLocal);
    }
    __aicore__ inline void CopyOut(int32_t progress)
    {
        AscendC::LocalTensor<T> zLocal = outQueueZ.DeQue<T>();
        AscendC::DataCopyExtParams copyParams = {1, (uint32_t)(this->tileLength * sizeof(T)), 0, 0, 0};
        if (progress == (this->tileNum * BUFFER_NUM - 1)) {
            AscendC::DataCopyPad<T>(zGm[(progress - LAST_TWO_TILE) * this->tileLength + this->lastTileLength], zLocal,
                                    copyParams);
        } else {
            AscendC::DataCopyPad<T>(zGm[progress * this->tileLength], zLocal, copyParams);
        }
        outQueueZ.FreeTensor(zLocal);
    }

private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, BUFFER_NUM> inQueueY;
    AscendC::TQue<AscendC::TPosition::VECOUT, BUFFER_NUM> outQueueZ;

    AscendC::TBuf<AscendC::TPosition::VECCALC> tmpBuf2;

    AscendC::GlobalTensor<T> xGm;
    AscendC::GlobalTensor<T> yGm;
    AscendC::GlobalTensor<T> zGm;

    uint32_t coef;
    uint32_t tileNum;
    uint32_t tileLength;
    uint32_t lastTileLength;
};

__global__ __aicore__ void add_custom(GM_ADDR x, GM_ADDR y, GM_ADDR z, AddCustomTilingData tiling)
{
    if (tiling.axis == 0) {
        if (tiling.dataType == ADD_BFLOAT16) {
            KernelAdd<bfloat16_t, 0> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else if (tiling.dataType == ADD_FLOAT16) {
            KernelAdd<half, 0> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else if (tiling.dataType == ADD_FLOAT32) {
            KernelAdd<float, 0> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else if (tiling.dataType == ADD_INT8) {
            KernelAdd<int8_t, 0> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else if (tiling.dataType == ADD_INT16) {
            KernelAdd<int16_t, 0> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else if (tiling.dataType == ADD_INT32) {
            KernelAdd<int32_t, 0> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else {
            return;
        }
    } else if (tiling.axis == 1) {
        if (tiling.dataType == ADD_BFLOAT16) {
            KernelAdd<bfloat16_t, 1> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else if (tiling.dataType == ADD_FLOAT16) {
            KernelAdd<half, 1> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else if (tiling.dataType == ADD_FLOAT32) {
            KernelAdd<float, 1> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else if (tiling.dataType == ADD_INT8) {
            KernelAdd<int8_t, 1> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else if (tiling.dataType == ADD_INT16) {
            KernelAdd<int16_t, 1> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else if (tiling.dataType == ADD_INT32) {
            KernelAdd<int32_t, 1> op;
            op.Init(x, y, z, tiling);
            op.Process();
        } else {
            return;
        }
    } else {
        return;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    constexpr uint32_t BLOCK_DIM = 8;
    constexpr uint32_t DATA_TYPE_SIZE[] = {2, 2, 4, 1, 2, 4};
    uint8_t* tiling = nullptr;
    size_t tilingSize = 20 * sizeof(uint32_t);

    aclInit(nullptr);
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *xHost, *yHost, *zHost;
    uint8_t *xDevice, *yDevice, *zDevice;

    aclrtMallocHost((void**)(&tiling), tilingSize);
    ReadFile("./input/input_tiling.bin", tilingSize, tiling, tilingSize);

    GenerateTilingData(tiling, BLOCK_DIM);
    uint32_t dataTypeSize = DATA_TYPE_SIZE[reinterpret_cast<AddCustomTilingData*>(tiling)->dataType];
    uint32_t xLen = reinterpret_cast<AddCustomTilingData*>(tiling)->xLen;
    uint32_t yLen = reinterpret_cast<AddCustomTilingData*>(tiling)->yLen;
    uint32_t totalLength = (xLen > yLen) ? xLen : yLen;

    size_t inputXByteSize = xLen * dataTypeSize;
    size_t inputYByteSize = yLen * dataTypeSize;
    size_t outputByteSize = totalLength * dataTypeSize;

    aclrtMallocHost((void**)(&xHost), inputXByteSize);
    aclrtMallocHost((void**)(&yHost), inputYByteSize);
    aclrtMallocHost((void**)(&zHost), outputByteSize);
    aclrtMalloc((void**)&xDevice, inputXByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&yDevice, inputYByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&zDevice, outputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/input_x.bin", inputXByteSize, xHost, inputXByteSize);
    ReadFile("./input/input_y.bin", inputYByteSize, yHost, inputYByteSize);

    aclrtMemcpy(xDevice, inputXByteSize, xHost, inputXByteSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(yDevice, inputYByteSize, yHost, inputYByteSize, ACL_MEMCPY_HOST_TO_DEVICE);

    add_custom<<<BLOCK_DIM, nullptr, stream>>>(xDevice, yDevice, zDevice,
                                               *reinterpret_cast<AddCustomTilingData*>(tiling));
    aclrtSynchronizeStream(stream);

    aclrtMemcpy(zHost, outputByteSize, zDevice, outputByteSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", zHost, outputByteSize);

    aclrtFree(xDevice);
    aclrtFree(yDevice);
    aclrtFree(zDevice);
    aclrtFreeHost(xHost);
    aclrtFreeHost(yHost);
    aclrtFreeHost(zHost);
    aclrtFreeHost(tiling);

    aclrtDestroyStream(stream);
    aclrtResetDevice(deviceId);
    aclFinalize();

    return 0;
}
