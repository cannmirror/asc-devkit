/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file gather_and_adds.asc
 * \brief
 */

#include <chrono>
#include <iostream>
#include <iterator>
#include <random>
#include <vector>
#include "acl/acl.h"
#include "kernel_operator.h"
#include "simt_api/asc_simt.h"

namespace {
    constexpr float ADDS_ADDEND = 1.0f;
    constexpr uint32_t THREAD_COUNT = 1024;
}

__simt_vf__ __launch_bounds__(THREAD_COUNT) inline void simt_gather(
    __gm__ float* input,
    __gm__ uint32_t* index,
    __ubuf__ float* gather_output,
    uint32_t input_total_length,
    uint32_t index_total_length,
    uint32_t output_total_length)
{
    if (threadIdx.x >= output_total_length) {
        return;
    }

    // calculate thread ID of current thread.
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= index_total_length) {
        return;
    }

    // calculate index of the number we need in input.
    uint32_t gather_idx = index[idx];
    if (gather_idx >= input_total_length) {
        return;
    }

    gather_output[threadIdx.x] = input[gather_idx];
}

__simd_vf__ inline void simd_adds(__ubuf__ float* output, __ubuf__ float* input,
    uint32_t count, uint32_t one_repeat_size, uint16_t repeat_times)
{
    AscendC::MicroAPI::RegTensor<float> src_reg0;
    AscendC::MicroAPI::RegTensor<float> dst_reg0;
    // asc_update_mask() will be supported later.
    // init MaskReg with the count of all numbers.
    AscendC::MicroAPI::MaskReg mask_reg;

    for (uint16_t i = 0; i < repeat_times; i++) {
        mask_reg = AscendC::MicroAPI::UpdateMask<float>(count);
        // asc_load, asc_adds and asc_store will be supported later.
        // load data from UB to RegTensor.
        AscendC::MicroAPI::LoadAlign(src_reg0, input + i * one_repeat_size);
        AscendC::MicroAPI::Adds(dst_reg0, src_reg0, ADDS_ADDEND, mask_reg);
        // store data from RegTensor to UB.
        AscendC::MicroAPI::StoreAlign(output + i * one_repeat_size, dst_reg0, mask_reg);
    }
}

__global__ __vector__ void gather_and_adds_kernel(__gm__ float* input, __gm__ uint32_t* index, __gm__ float* output,
    uint32_t input_total_length, uint32_t index_total_length)
{

    AscendC::LocalMemAllocator<AscendC::Hardware::UB> ub_allocator;

    // 1. use SIMT to gather numbers from input.
    uint32_t index_total_length_per_block = index_total_length / AscendC::GetBlockNum();
    AscendC::LocalTensor<float> gather_output = ub_allocator.Alloc<float>(index_total_length_per_block);
    asc_vf_call<simt_gather>(dim3(THREAD_COUNT), input, index,
                             (__ubuf__ float *)gather_output.GetPhyAddr(),
                             input_total_length,
                             index_total_length,
                             index_total_length_per_block);

    // 2. use SIMD Micro API to do addition.
    AscendC::LocalTensor<float> adds_output = ub_allocator.Alloc<float>(index_total_length_per_block);
    // asc_get_vf_len() will be supported later, use GetVecLen.
    constexpr uint32_t one_repeat_size = AscendC::GetVecLen() / sizeof(float);
    uint16_t repeat_times = (index_total_length_per_block + one_repeat_size - 1) / one_repeat_size;

    asc_vf_call<simd_adds>((__ubuf__ float *)adds_output.GetPhyAddr(),
        (__ubuf__ float *)gather_output.GetPhyAddr(), index_total_length_per_block, one_repeat_size, repeat_times);

    AscendC::SetFlag<AscendC::HardEvent::V_MTE3>(0);
    AscendC::WaitFlag<AscendC::HardEvent::V_MTE3>(0);

    // 3. copy data to global memory.
    AscendC::GlobalTensor<float> output_global_tensor;
    output_global_tensor.SetGlobalBuffer(output + index_total_length_per_block * AscendC::GetBlockIdx());
    AscendC::DataCopy(output_global_tensor, adds_output, index_total_length_per_block);
}

std::vector<float> gather_and_adds(std::vector<float>& input, std::vector<uint32_t>& index)
{
    constexpr uint32_t numBlocks = 8;
    constexpr uint32_t dynUBufSize = 2048;

    uint32_t input_total_length = input.size();
    size_t input_total_byte_size = input_total_length * sizeof(float);

    uint32_t index_total_length = index.size();
    uint32_t index_total_byte_size = index_total_length * sizeof(uint32_t);

    int32_t device_id = 0;
    aclrtStream stream = nullptr;

    uint8_t* input_host = reinterpret_cast<uint8_t *>(input.data());
    uint8_t* index_host = reinterpret_cast<uint8_t *>(index.data());
    uint8_t* output_host = nullptr;
    float* input_device = nullptr;
    uint32_t* index_device = nullptr;
    float* output_device = nullptr;

    aclInit(nullptr);
    aclrtSetDevice(device_id);
    aclrtCreateStream(&stream);

    aclrtMallocHost((void **)(&output_host), index_total_byte_size);
    aclrtMalloc((void **)&input_device, input_total_byte_size, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&index_device, index_total_byte_size, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&output_device, index_total_byte_size, ACL_MEM_MALLOC_HUGE_FIRST);

    aclrtMemcpy(input_device, input_total_byte_size, input_host, input_total_byte_size, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(index_device, index_total_byte_size, index_host, index_total_byte_size, ACL_MEMCPY_HOST_TO_DEVICE);

    // launch kernel with <<<>>>, dynUBufSize is UB byte size we will allocate in kernel.
    gather_and_adds_kernel<<<numBlocks, dynUBufSize, stream>>>(input_device, index_device, output_device, input_total_length, index_total_length);
    aclrtSynchronizeStream(stream);

    aclrtMemcpy(output_host, index_total_byte_size, output_device, index_total_byte_size, ACL_MEMCPY_DEVICE_TO_HOST);
    std::vector<float> output((float *)output_host, (float *)(output_host + index_total_byte_size));

    aclrtFree(input_device);
    aclrtFree(index_device);
    aclrtFree(output_device);
    aclrtFreeHost(output_host);

    aclrtDestroyStream(stream);
    aclrtResetDevice(device_id);
    aclFinalize();

    return output;
}

uint32_t verify_result(std::vector<float>& output, std::vector<float>& golden)
{
    auto print_tensor = [](std::vector<float>& tensor, const char* name) {
        constexpr size_t max_print_size = 20;
        std::cout << name << ": ";
        std::copy(tensor.begin(), tensor.begin() + std::min(tensor.size(), max_print_size),
            std::ostream_iterator<float>(std::cout, " "));
        if (tensor.size() > max_print_size) {
            std::cout << "...";
        }
        std::cout << std::endl;
    };
    print_tensor(output, "Output");
    print_tensor(golden, "Golden");
    if (std::equal(output.begin(), output.end(), golden.begin())) {
        std::cout << "[Success] Case accuracy is verification passed." << std::endl;
        return 0;
    } else {
        std::cout << "[Failed] Case accuracy is verification failed!" << std::endl;
        return 1;
    }
    return 0;
}

float random_float(float min, float max)
{
    static std::mt19937 engine(std::chrono::system_clock::now().time_since_epoch().count());
    std::uniform_real_distribution<float> dist(min, max);
    return dist(engine);
}

uint32_t random_uint32(uint32_t min, uint32_t max)
{
    static std::mt19937 engine(std::chrono::system_clock::now().time_since_epoch().count());
    std::uniform_int_distribution<uint32_t> dist(min, max);
    return dist(engine);
}

int32_t main(int32_t argc, char* argv[])
{
    constexpr uint32_t input_total_length = 100000;
    std::vector<float> input(input_total_length);
    for (uint32_t i = 0; i < input_total_length; i++) {
        input[i] = random_float(0.0f, 100.0f);
    }

    constexpr uint32_t index_total_length = 8 * 1024;
    std::vector<uint32_t> index(index_total_length);
    for (uint32_t i = 0; i < index_total_length; i++) {
        index[i] = random_uint32(0, input_total_length - 1);
    }

    std::vector<float> golden(index_total_length);
    for (uint32_t i = 0; i < index_total_length; i++) {
        golden[i] = input[index[i]] + ADDS_ADDEND;
    }

    std::vector<float> output = gather_and_adds(input, index);

    return verify_result(output, golden);
}