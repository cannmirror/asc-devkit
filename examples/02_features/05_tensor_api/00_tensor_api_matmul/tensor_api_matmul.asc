/**
* Copyright (c) 2026 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/

/* !
 * \file tensor_api_matmul.asc
 * \brief
 */

#include <cstdint>
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include "acl/acl.h"
#include "kernel_operator.h"
#include "data_utils.h"

constexpr AscendC::LoadDataTrait LOAD_DATA_B_TRAIT{true};

struct LoadData2BTrait {
    using TraitType = AscendC::LoadDataTrait;
    static constexpr const TraitType value = LOAD_DATA_B_TRAIT;
};
/**
  * @brief  matmul kernel function entry
  * @param  x: A matrix gm addr.
  * @param  y: B matrix gm addr.
  * @param  z: C matrix gm addr.
  * @param  m: The row dimension.
  * @param  n: The column dimension.
  * @param  k: The reduce dimension.
  * @retval None
  */
__cube__ __global__ void tensor_api_matmul_custom(__gm__ half* x, __gm__ half* y, __gm__ float* z, int32_t m, int32_t n, int32_t k)
{
    using namespace AscendC;

    //Usage 1： MakeLayout API constructs an ND Layout based on the input shape by default.
    auto layoutA = MakeLayout(MakeShape(m,k));
    auto layoutB = MakeLayout(MakeShape(k,n));
    auto layoutC = MakeLayout(MakeShape(m,n));

    //Usage 2： Customize the construction of the Layout in ND Format by shape and stride paramaters.
    // auto layoutA = MakeLayout(MakeShape(m,k), MakeStride(k, 1));
    // auto layoutB = MakeLayout(MakeShape(k,n), MakeStride(n, 1));
    // auto layoutC = MakeLayout(MakeShape(m,n), MakeStride(n, 1));

    auto gmPtrA = MakeGMmemPtr(x);
    auto gmPtrB = MakeGMmemPtr(y);
    auto gmPtrC = MakeGMmemPtr(z);

    auto globalA = MakeTensor(gmPtrA, layoutA);
    auto globalB = MakeTensor(gmPtrB, layoutB);
    auto globalC = MakeTensor(gmPtrC, layoutC);

    //Usage 1： MakeNZLayout API constructs an NZ Layout based on the row and column.
    auto l1ALayout = MakeNZLayout<half>(m, k);
    //Usage 2： Customize the construction of the Layout in NZ Format by shape and stride paramaters.
    // auto l1ALayout = MakeLayout(MakeShape(MakeShape(Std::Int<16>{}, m/16), MakeShape(Std::Int<32/sizeof(half)>{}, k/(32/sizeof(half)))), 
    //                             MakeStride(MakeStride(Std::Int<32/sizeof(half)>{}, Std::Int<512/sizeof(half)>{}), MakeStride(Std::Int<1>{}, 32/sizeof(half) * m)));
    auto l1BLayout = MakeNZLayout<half>(k, n);
    auto l0ALayout = MakeZZLayout<half>(m, k);
    auto l0BLayout = MakeZNLayout<half>(k, n);
    auto l0CLayout = MakeL0CLayout(m, n);

    constexpr int32_t  L1_MAX = 256*256*2;
    constexpr int32_t  L0_MAX = 128*128*2;
    constexpr int32_t  L0C_MAX = 128*128;

    __cbuf__ half l1AAddr[L1_MAX];
    __cbuf__ half l1BAddr[L1_MAX];
    __ca__ half l0AAddr[L0_MAX];
    __cb__ half l0BAddr[L0_MAX];
    __cc__ float l0CAddr[L0C_MAX];

    auto l1APtr = MakeL1memPtr(l1AAddr);
    auto l1BPtr = MakeL1memPtr(l1BAddr);
    auto l0APtr = MakeL0AmemPtr(l0AAddr);
    auto l0BPtr = MakeL0BmemPtr(l0BAddr);
    auto l0CPtr = MakeL0CmemPtr(l0CAddr);

    auto l1ABuff = l1APtr + 0;
    auto l1BBuff = l1BPtr + 0;
    auto l0ABuff = l0APtr + 0;
    auto l0BBuff = l0BPtr + 0;
    auto l0CBuff = l0CPtr + 0;

    auto l1ATensor = MakeTensor(l1ABuff, l1ALayout);
    auto l1BTensor = MakeTensor(l1BBuff, l1BLayout);
    auto l0ATensor = MakeTensor(l0ABuff, l0ALayout);
    auto l0BTensor = MakeTensor(l0BBuff, l0BLayout);
    auto l0CTensor = MakeTensor(l0CBuff, l0CLayout);

    //Usage1: Copy
    Copy(CopyAtom<CopyTraits<CopyGM2L1, DataCopyTraitDefault>>{}, l1ATensor, globalA);
    Copy(CopyAtom<CopyTraits<CopyGM2L1, DataCopyTraitDefault>>{}, l1BTensor, globalB);

    set_flag(PIPE_MTE2, PIPE_MTE1, EVENT_ID0);
    wait_flag(PIPE_MTE2, PIPE_MTE1, EVENT_ID0);

    Copy(CopyAtom<CopyTraits<CopyL12L0, LoadDataTraitDefault>>{}, l0ATensor, l1ATensor);
    Copy(CopyAtom<CopyTraits<CopyL12L0, LoadData2BTrait>>{}, l0BTensor, l1BTensor);

    set_flag(PIPE_MTE1, PIPE_M, EVENT_ID0);
    wait_flag(PIPE_MTE1, PIPE_M, EVENT_ID0);

    Mmad(l0CTensor, l0ATensor, l0BTensor);

    set_flag(PIPE_M, PIPE_FIX, EVENT_ID0);
    wait_flag(PIPE_M, PIPE_FIX, EVENT_ID0);    

    Copy(CopyAtom<CopyTraits<CopyL0C2GM, FixpipeTraitDefault>>{}, globalC, l0CTensor);

    // Usage2: CopyAtom<CopyTraits<>>{}.Call
    // CopyAtom<CopyTraits<CopyGM2L1, DataCopyTraitDefault>>{}.Call(l1ATensor, globalA);
    // CopyAtom<CopyTraits<CopyGM2L1, DataCopyTraitDefault>>{}.Call(l1BTensor, globalB);

    // set_flag(PIPE_MTE2, PIPE_MTE1, EVENT_ID0);
    // wait_flag(PIPE_MTE2, PIPE_MTE1, EVENT_ID0);

    // CopyAtom<CopyTraits<CopyL12L0, LoadDataTraitDefault>>{}.Call(l0ATensor, l1ATensor);
    // CopyAtom<CopyTraits<CopyL12L0, LoadData2BTrait>>{}.Call(l0BTensor, l1BTensor);

    // set_flag(PIPE_MTE1, PIPE_M, EVENT_ID0);
    // wait_flag(PIPE_MTE1, PIPE_M, EVENT_ID0);

    // Mmad(l0CTensor, l0ATensor, l0BTensor);

    // set_flag(PIPE_M, PIPE_FIX, EVENT_ID0);
    // wait_flag(PIPE_M, PIPE_FIX, EVENT_ID0);    

    // CopyAtom<CopyTraits<CopyL0C2GM, FixpipeTraitDefault>>{}.Call(globalC, l0CTensor);

    // Usage3: MakeCopy 
    // auto atomCopyGM2L1 = MakeCopy(CopyGM2L1{}, DataCopyTraitDefault{});
    // atomCopyGM2L1.Call(l1ATensor, globalA);
    // atomCopyGM2L1.Call(l1BTensor, globalB);

    // set_flag(PIPE_MTE2, PIPE_MTE1, EVENT_ID0);
    // wait_flag(PIPE_MTE2, PIPE_MTE1, EVENT_ID0);
    
    // auto atmoCopyL1A2L0A = MakeCopy(CopyL12L0{}, LoadDataTraitDefault{});
    // auto atmoCopyL1B2L0B = MakeCopy(CopyL12L0{}, LoadData2BTrait{});
    // atmoCopyL1A2L0A.Call(l0ATensor, l1ATensor);
    // atmoCopyL1B2L0B.Call(l0BTensor, l1BTensor);

    // set_flag(PIPE_MTE1, PIPE_M, EVENT_ID0);
    // wait_flag(PIPE_MTE1, PIPE_M, EVENT_ID0);

    // Mmad(l0CTensor, l0ATensor, l0BTensor);

    // set_flag(PIPE_M, PIPE_FIX, EVENT_ID0);
    // wait_flag(PIPE_M, PIPE_FIX, EVENT_ID0);    

    // auto atomCopyL0C2GM = MakeCopy(CopyL0C2GM{}, FixpipeTraitDefault{});
    // atomCopyL0C2GM.Call(globalC, l0CTensor);
}

int32_t main(int32_t argc, char *argv[])
{
    size_t param1FileSize = 128 * 128 * sizeof(half); 
    size_t param2FileSize = 128 * 128 * sizeof(half); 
    size_t param3FileSize = 128 * 128 * sizeof(float);
    uint32_t numBlocks = 1;
    int32_t m = 128;
    int32_t n = 128;
    int32_t k = 128;

    aclInit(nullptr);
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *xHost, *yHost, *zHost;
    half *xDevice, *yDevice;
    float *zDevice;

    aclrtMallocHost((void**)(&xHost), param1FileSize);
    aclrtMallocHost((void**)(&yHost), param2FileSize);
    aclrtMallocHost((void**)(&zHost), param3FileSize);
    aclrtMalloc((void**)&xDevice, param1FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&yDevice, param2FileSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&zDevice, param3FileSize, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/input_x.bin", param1FileSize, xHost, param1FileSize);
    ReadFile("./input/input_y.bin", param2FileSize, yHost, param2FileSize);

    aclrtMemcpy(xDevice, param1FileSize, xHost, param1FileSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(yDevice, param2FileSize, yHost, param2FileSize, ACL_MEMCPY_HOST_TO_DEVICE);

    tensor_api_matmul_custom<<<numBlocks, nullptr, stream>>>(xDevice, yDevice, zDevice, m, n, k);
    aclrtSynchronizeStream(stream);

    aclrtMemcpy(zHost, param3FileSize, zDevice, param3FileSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", zHost, param3FileSize);

    aclrtFree(xDevice);
    aclrtFree(yDevice);
    aclrtFree(zDevice);
    aclrtFreeHost(xHost);
    aclrtFreeHost(yHost);
    aclrtFreeHost(zHost);

    aclrtDestroyStream(stream);
    aclrtResetDevice(deviceId);
    aclFinalize();

    return 0;
}