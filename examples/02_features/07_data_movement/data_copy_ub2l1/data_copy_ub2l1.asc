/**
 * Copyright (c) 2025 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */

#include "acl/acl.h"
#include "kernel_operator.h"
#include "data_utils.h"

constexpr uint32_t CUBE_BLOCK = 16;
constexpr uint32_t CUBE_BLOCK_SIZE = 16 * 16;

class KernelMmad {
public:
    __aicore__ inline KernelMmad()
    {
        aSize = m * k;
        bSize = k * n;
        cSize = m * n;
    }

    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, GM_ADDR z, AscendC::TPipe* pipeIn)
    {
        this->pipe = pipeIn;
        aGM.SetGlobalBuffer((__gm__ half*)x);
        bGM.SetGlobalBuffer((__gm__ half*)y);
        cGM.SetGlobalBuffer((__gm__ float*)z);
        pipe->InitBuffer(inQueueA1, 1, aSize * sizeof(half));
        pipe->InitBuffer(inQueueA2, 1, aSize * sizeof(half));
        pipe->InitBuffer(inQueueB1, 1, bSize * sizeof(half));
        pipe->InitBuffer(inQueueB2, 1, bSize * sizeof(half));
        pipe->InitBuffer(inQueueTmp1, 1, aSize * sizeof(half));
        pipe->InitBuffer(inQueueTmp2, 1, bSize * sizeof(half));
        pipe->InitBuffer(outQueueCO1, 1, cSize * sizeof(float));
    }

    __aicore__ inline void Process()
    {
        if ASCEND_IS_AIV {
            CopyGM2UB();
            int32_t eventIDMTE2ToMTE3 =
                static_cast<int32_t>(GetTPipePtr()->FetchEventID(AscendC::HardEvent::MTE2_MTE3));
            AscendC::SetFlag<AscendC::HardEvent::MTE2_MTE3>(eventIDMTE2ToMTE3);
            AscendC::WaitFlag<AscendC::HardEvent::MTE2_MTE3>(eventIDMTE2ToMTE3);
            CopyUB2L1();
            AscendC::CrossCoreSetFlag<0x2, PIPE_MTE3>(0x8);
        }
        if ASCEND_IS_AIC {
            AscendC::CrossCoreWaitFlag(0x8);
            SplitA();
            SplitB();
            int32_t eventIDMTE1ToM = static_cast<int32_t>(GetTPipePtr()->FetchEventID(AscendC::HardEvent::MTE1_M));
            AscendC::SetFlag<AscendC::HardEvent::MTE1_M>(eventIDMTE1ToM);
            AscendC::WaitFlag<AscendC::HardEvent::MTE1_M>(eventIDMTE1ToM);
            Compute();
            int32_t eventIDMToFIX = static_cast<int32_t>(GetTPipePtr()->FetchEventID(AscendC::HardEvent::M_FIX));
            AscendC::SetFlag<AscendC::HardEvent::M_FIX>(eventIDMToFIX);
            AscendC::WaitFlag<AscendC::HardEvent::M_FIX>(eventIDMToFIX);
            CopyOut();
        }
        inQueueTmp1.FreeTensor(ubA1Local);
        inQueueTmp2.FreeTensor(ubB1Local);
        inQueueA1.FreeTensor(a1Local);
        inQueueB1.FreeTensor(b1Local);
        inQueueA2.FreeTensor(a2Local);
        inQueueB2.FreeTensor(b2Local);
        outQueueCO1.FreeTensor(co1Local);
    }

private:
    __aicore__ inline uint32_t CeilCubeBlock(uint32_t len)
    {
        return (len + CUBE_BLOCK - 1) / CUBE_BLOCK;
    }

    __aicore__ inline void CopyGM2UB()
    {
        ubA1Local = inQueueTmp1.AllocTensor<half>();
        ubB1Local = inQueueTmp2.AllocTensor<half>();
        AscendC::Nd2NzParams nd2nzA1Params;
        nd2nzA1Params.ndNum = 1;
        nd2nzA1Params.nValue = m;
        nd2nzA1Params.dValue = k;
        nd2nzA1Params.srcNdMatrixStride = 0;
        nd2nzA1Params.srcDValue = k;
        nd2nzA1Params.dstNzC0Stride = CeilCubeBlock(m) * CUBE_BLOCK;
        nd2nzA1Params.dstNzNStride = 1;
        nd2nzA1Params.dstNzMatrixStride = 0;
        AscendC::DataCopy(ubA1Local, aGM, nd2nzA1Params);
        AscendC::Nd2NzParams nd2nzB1Params;
        nd2nzB1Params.ndNum = 1;
        nd2nzB1Params.nValue = k;
        nd2nzB1Params.dValue = n;
        nd2nzB1Params.srcNdMatrixStride = 0;
        nd2nzB1Params.srcDValue = n;
        nd2nzB1Params.dstNzC0Stride = CeilCubeBlock(k) * CUBE_BLOCK;
        nd2nzB1Params.dstNzNStride = 1;
        nd2nzB1Params.dstNzMatrixStride = 0;
        AscendC::DataCopy(ubB1Local, bGM, nd2nzB1Params);
    }

    __aicore__ inline void CopyUB2L1()
    {
        a1Local = inQueueA1.AllocTensor<half>();
        b1Local = inQueueB1.AllocTensor<half>();
        AscendC::DataCopy(a1Local, ubA1Local, aSize);
        AscendC::DataCopy(b1Local, ubB1Local, bSize);
    }

    __aicore__ inline void SplitA()
    {
        a2Local = inQueueA2.AllocTensor<half>();
        AscendC::LoadData2DParamsV2 loadDataParams;
        loadDataParams.mStartPosition = 0;
        loadDataParams.kStartPosition = 0;
        loadDataParams.mStep = AscendC::CeilDivision(m, 16);
        loadDataParams.kStep = AscendC::CeilDivision(k * sizeof(half), 32);
        loadDataParams.srcStride = AscendC::CeilDivision(m, 16);
        loadDataParams.dstStride = AscendC::CeilDivision(m, 16);
        loadDataParams.sid = 0;
        loadDataParams.ifTranspose = false;
        AscendC::LoadData(a2Local, a1Local, loadDataParams);
    }

    __aicore__ inline void SplitB()
    {
        b2Local = inQueueB2.AllocTensor<half>();
        uint16_t nAlign = AscendC::CeilDivision(n * sizeof(half), 32);
        uint16_t kAlign = AscendC::CeilDivision(k, 16);
        AscendC::LoadData2DParamsV2 loadDataParams;
        loadDataParams.mStartPosition = 0;
        loadDataParams.kStartPosition = 0;
        loadDataParams.mStep = kAlign;
        loadDataParams.kStep = nAlign;
        loadDataParams.srcStride = kAlign;
        loadDataParams.dstStride = nAlign;
        loadDataParams.sid = 0;
        loadDataParams.ifTranspose = true;
        AscendC::LoadData(b2Local, b1Local, loadDataParams);
    }

    __aicore__ inline void Compute()
    {
        AscendC::MmadParams mmadParams;
        mmadParams.m = m;
        mmadParams.n = n;
        mmadParams.k = k;
        mmadParams.isBias = false;
        co1Local = outQueueCO1.AllocTensor<float>();
        AscendC::Mmad(co1Local, a2Local, b2Local, mmadParams);
    }
    
    __aicore__ inline void CopyOut()
    {
        AscendC::FixpipeParamsV220 fixpipeParams;
        fixpipeParams.nSize = n;
        fixpipeParams.mSize = m;
        fixpipeParams.srcStride = m;
        fixpipeParams.dstStride = n;
        fixpipeParams.ndNum = 1;
        fixpipeParams.srcNdStride = 2;
        fixpipeParams.dstNdStride = m * n;
        fixpipeParams.quantPre = QuantMode_t::NoQuant;
        AscendC::Fixpipe<float, float, AscendC::CFG_ROW_MAJOR>(cGM, co1Local, fixpipeParams);
    }

private:
    AscendC::TPipe* pipe = nullptr;
    AscendC::TQue<AscendC::TPosition::A1, 1> inQueueA1;
    AscendC::TQue<AscendC::TPosition::A2, 1> inQueueA2;
    AscendC::TQue<AscendC::TPosition::B1, 1> inQueueB1;
    AscendC::TQue<AscendC::TPosition::B2, 1> inQueueB2;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueTmp1, inQueueTmp2;
    AscendC::TQue<AscendC::TPosition::CO1, 1> outQueueCO1;
    AscendC::GlobalTensor<half> aGM, bGM;
    AscendC::GlobalTensor<float> cGM;
    AscendC::LocalTensor<half> ubA1Local, a1Local, a2Local, ubB1Local, b1Local, b2Local;
    AscendC::LocalTensor<float> co1Local;
    uint16_t m = 32;
    uint16_t n = 32;
    uint16_t k = 32;
    uint16_t aSize, bSize, cSize;
};

__global__ __mix__(1, 2) void data_copy_ub2l1(GM_ADDR x, GM_ADDR y, GM_ADDR z)
{
    AscendC::TPipe pipe;
    KernelMmad op;
    op.Init(x, y, z, &pipe);
    op.Process();
}

static bool CompareResult(const void* outputData, uint32_t outSize)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden.bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden.bin success!\n");
    } else {
        printf("test failed!\n");
        return false;
    }
    constexpr float EPS = 1e-4;
    int64_t wrongNum = 0;

    for (size_t i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult golden.bin failed output is %lf, golden is %lf\n", a, b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    if (wrongNum != 0) {
        return false;
    } else {
        printf("CompareResult golden.bin success!\n");
        return true;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    uint32_t numBlocks = 1;
    aclInit(nullptr);
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);
    int32_t m = 32, n = 32, k = 32;
    size_t aInputByteSize = static_cast<size_t>(1) * m * k * sizeof(half);
    size_t bInputByteSize = static_cast<size_t>(1) * k * n * sizeof(half);
    size_t outputByteSize = static_cast<size_t>(1) * m * n * sizeof(float);
    uint8_t *xHost, *yHost, *zHost;
    uint8_t *xDevice, *yDevice, *zDevice;
    aclrtMallocHost((void**)(&xHost), aInputByteSize);
    aclrtMallocHost((void**)(&yHost), bInputByteSize);
    aclrtMallocHost((void**)(&zHost), outputByteSize);
    aclrtMalloc((void**)&xDevice, aInputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&yDevice, bInputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&zDevice, outputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_x.bin", aInputByteSize, xHost, aInputByteSize);
    ReadFile("./input/input_y.bin", bInputByteSize, yHost, bInputByteSize);
    aclrtMemcpy(xDevice, aInputByteSize, xHost, aInputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(yDevice, bInputByteSize, yHost, bInputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);
    data_copy_ub2l1<<<numBlocks, nullptr, stream>>>(xDevice, yDevice, zDevice);
    aclrtSynchronizeStream(stream);
    aclrtMemcpy(zHost, outputByteSize, zDevice, outputByteSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", zHost, outputByteSize);
    bool goldenResult = true;
    goldenResult = CompareResult(zHost, outputByteSize);
    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }
    aclrtFree(xDevice);
    aclrtFree(yDevice);
    aclrtFree(zDevice);
    aclrtFreeHost(xHost);
    aclrtFreeHost(yHost);
    aclrtFreeHost(zHost);
    aclrtDestroyStream(stream);
    aclrtResetDevice(deviceId);
    aclFinalize();
    return 0;
}