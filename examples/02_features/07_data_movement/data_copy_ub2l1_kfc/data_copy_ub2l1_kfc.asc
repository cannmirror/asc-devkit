/**
 * Copyright (c) 2025 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
 */

#include "acl/acl.h"
#include "kernel_operator.h"
#include "data_utils.h"
#include "lib/matmul_intf.h"

// ceil div
__aicore__ inline uint16_t CeilDiv(uint16_t num1, uint16_t num2)
{
    return (num1 + num2 - 1) / num2;
}

// copy tiling
__aicore__ inline void CopyTiling(AscendC::tiling::TCubeTiling* tiling, GM_ADDR tilingGM)
{
    uint32_t* ptr = reinterpret_cast<uint32_t*>(tiling);
    auto tiling32 = reinterpret_cast<__gm__ uint32_t*>(tilingGM);

    for (uint32_t i = 0; i < sizeof(AscendC::tiling::TCubeTiling) / sizeof(uint32_t); i++, ptr++) {
        *ptr = *(tiling32 + i);
    }
    return;
}

// copy data from L1 Buffer to L0A Buffer
template <typename T>
__aicore__ inline void CopyA12A2(AscendC::LocalTensor<T>& dst, AscendC::LocalTensor<T>& src, uint16_t m, uint16_t k)
{
    AscendC::LoadData2DParamsV2 loadDataParams;
    loadDataParams.mStartPosition = 0;
    loadDataParams.kStartPosition = 0;
    loadDataParams.mStep = CeilDiv(m, 16);
    loadDataParams.kStep = CeilDiv(k * sizeof(half), 32);
    loadDataParams.srcStride = CeilDiv(m, 16);
    loadDataParams.dstStride = CeilDiv(m, 16);
    loadDataParams.sid = 0;
    loadDataParams.ifTranspose = false;
    AscendC::LoadData(dst, src, loadDataParams);
}

// copy data from L1 Buffer to L0B Buffer
template <typename T>
__aicore__ inline void CopyB12B2(AscendC::LocalTensor<T>& dst, AscendC::LocalTensor<T>& src, uint16_t k, uint16_t n)
{
    uint16_t nAlign = CeilDiv(n * sizeof(half), 32);
    uint16_t kAlign = CeilDiv(k, 16);
    AscendC::LoadData2DParamsV2 loadDataParams;
    loadDataParams.mStartPosition = 0;
    loadDataParams.kStartPosition = 0;
    loadDataParams.mStep = kAlign;
    loadDataParams.kStep = nAlign;
    loadDataParams.srcStride = kAlign;
    loadDataParams.dstStride = nAlign;
    loadDataParams.sid = 0;
    loadDataParams.ifTranspose = true;
    AscendC::LoadData(dst, src, loadDataParams);
}

// do mmad
template <typename T, typename U>
__aicore__ inline void Compute(AscendC::LocalTensor<T>& bufferA, AscendC::LocalTensor<T>& bufferB,
                               AscendC::LocalTensor<U>& bufferC, uint16_t m, uint16_t n, uint16_t k)
{
    AscendC::MmadParams mmadParams;
    mmadParams.m = m;
    mmadParams.n = n;
    mmadParams.k = k;
    mmadParams.isBias = false;
    AscendC::Mmad(bufferC, bufferA, bufferB, mmadParams);
}

// copy data from L0C to GM
template <typename T>
__aicore__ inline void L0C2GM(AscendC::GlobalTensor<T>& dst, AscendC::LocalTensor<T>& src, uint16_t m, uint16_t n,
                              uint16_t k)
{
    AscendC::FixpipeParamsV220 fixpipeParams;
    fixpipeParams.nSize = n;
    fixpipeParams.mSize = m;
    fixpipeParams.srcStride = m;
    fixpipeParams.dstStride = n;
    fixpipeParams.ndNum = 1;
    fixpipeParams.srcNdStride = 2;
    fixpipeParams.dstNdStride = m * n;
    fixpipeParams.quantPre = QuantMode_t::NoQuant;
    AscendC::Fixpipe<T, T, AscendC::CFG_ROW_MAJOR>(dst, src, fixpipeParams);
}

template <class A_TYPE, class B_TYPE, class C_TYPE>
class MatMulKernel {
    using A_T = typename A_TYPE::T;
    using B_T = typename B_TYPE::T;
    using C_T = typename C_TYPE::T;

public:
    __aicore__ inline void Init(GM_ADDR aGM, GM_ADDR bGM, GM_ADDR cGM, GM_ADDR tilingGM, AscendC::TPipe* pipeIn)
    {
        this->pipe = pipeIn;
        aGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ A_T*>(aGM), tiling.M * tiling.Ka);
        bGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ B_T*>(bGM), tiling.Kb * tiling.N);
        cGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ C_T*>(cGM), tiling.M * tiling.N);
        CopyTiling(&tiling, tilingGM);
    }

    __aicore__ inline void mmad()
    {
        // UB -> A1 & UB -> B1
        pipe->InitBuffer(inQueueA1, 1, tiling.M * tiling.Ka * 2);
        pipe->InitBuffer(inQueueB1, 1, tiling.Kb * tiling.N * 2);
        bufferA1 = inQueueA1.AllocTensor<A_T>();
        bufferB1 = inQueueB1.AllocTensor<B_T>();
        AscendC::DataCopy(bufferA1, bufferLeft, tiling.M * tiling.Ka);
        AscendC::DataCopy(bufferB1, bufferRight, tiling.Kb * tiling.N);
        AscendC::TEventID eventIdMTE2ToMTE1 =
            static_cast<AscendC::TEventID>(GetTPipePtr()->FetchEventID(AscendC::HardEvent::MTE2_MTE1));
        AscendC::SetFlag<AscendC::HardEvent::MTE2_MTE1>(eventIdMTE2ToMTE1);
        AscendC::WaitFlag<AscendC::HardEvent::MTE2_MTE1>(eventIdMTE2ToMTE1);
        // A1 -> A2 & B1 -> B2
        pipe->InitBuffer(inQueueA1, 1, tiling.M * tiling.Ka * 2);
        pipe->InitBuffer(inQueueA2, 1, tiling.M * tiling.Ka * 2);
        pipe->InitBuffer(inQueueB1, 1, tiling.Kb * tiling.N * 2);
        pipe->InitBuffer(inQueueB2, 1, tiling.Kb * tiling.N * 2);
        bufferA1 = inQueueA1.AllocTensor<A_T>();
        bufferA2 = inQueueA2.AllocTensor<A_T>();
        bufferB1 = inQueueB1.AllocTensor<B_T>();
        bufferB2 = inQueueB2.AllocTensor<B_T>();
        CopyA12A2(bufferA2, bufferA1, tiling.M, tiling.Ka);
        CopyB12B2(bufferB2, bufferB1, tiling.Kb, tiling.N);
        AscendC::TEventID eventIdMTE1ToM =
            static_cast<AscendC::TEventID>(GetTPipePtr()->FetchEventID(AscendC::HardEvent::MTE1_M));
        AscendC::SetFlag<AscendC::HardEvent::MTE1_M>(eventIdMTE1ToM);
        AscendC::WaitFlag<AscendC::HardEvent::MTE1_M>(eventIdMTE1ToM);
        // do mmad
        pipe->InitBuffer(inQueueCO1, 1, tiling.M * tiling.N * 4);
        bufferCO1 = inQueueCO1.AllocTensor<C_T>();
        Compute(bufferA2, bufferB2, bufferCO1, tiling.M, tiling.N, tiling.Ka);
        AscendC::TEventID eventIdMToFIX =
            static_cast<AscendC::TEventID>(GetTPipePtr()->FetchEventID(AscendC::HardEvent::M_FIX));
        AscendC::SetFlag<AscendC::HardEvent::M_FIX>(eventIdMToFIX);
        AscendC::WaitFlag<AscendC::HardEvent::M_FIX>(eventIdMToFIX);
        // CO1 -> GM
        L0C2GM(cGlobal, bufferCO1, tiling.N, tiling.N, tiling.Ka);
    }

    __aicore__ inline void Process(GM_ADDR workspaceGM)
    {
        AscendC::SetSysWorkspace(workspaceGM);
        if (GetSysWorkSpacePtr() == nullptr) {
            return;
        }
        REGIST_MATMUL_OBJ(pipe, GetSysWorkSpacePtr(), mm);
        // init
        mm.Init(&tiling);
        // set A
        pipe->InitBuffer(inQueueX, 1, tiling.M * tiling.Ka * 2);
        bufferLeft = inQueueX.AllocTensor<A_T>();
        AscendC::DataCopy(bufferLeft, aGlobal, tiling.M * tiling.Ka);

        int32_t eventID1 = static_cast<AscendC::TEventID>(GetTPipePtr()->FetchEventID(AscendC::HardEvent::MTE2_MTE3));
        AscendC::SetFlag<AscendC::HardEvent::MTE2_MTE3>(eventID1);
        AscendC::WaitFlag<AscendC::HardEvent::MTE2_MTE3>(eventID1);
        mm.SetTensorA(bufferLeft);
        // set B
        pipe->InitBuffer(inQueueY, 1, tiling.Kb * tiling.N * 2);
        bufferRight = inQueueY.AllocTensor<B_T>();
        AscendC::DataCopy(bufferRight, bGlobal, tiling.Kb * tiling.N);
        int32_t eventID2 = static_cast<AscendC::TEventID>(GetTPipePtr()->FetchEventID(AscendC::HardEvent::MTE2_MTE3));
        AscendC::SetFlag<AscendC::HardEvent::MTE2_MTE3>(eventID2);
        AscendC::WaitFlag<AscendC::HardEvent::MTE2_MTE3>(eventID2);
        mm.SetTensorB(bufferRight);
        mm.IterateAll(cGlobal);
        mmad();
        // free tensor
        inQueueX.FreeTensor(bufferLeft);
        inQueueY.FreeTensor(bufferRight);
        inQueueA1.FreeTensor(bufferA1);
        inQueueA2.FreeTensor(bufferA2);
        inQueueB1.FreeTensor(bufferB1);
        inQueueB2.FreeTensor(bufferB2);
        inQueueCO1.FreeTensor(bufferCO1);
    }

private:
    AscendC::TPipe* pipe;
    AscendC::tiling::TCubeTiling tiling;
    AscendC::Matmul<A_TYPE, B_TYPE, C_TYPE> mm;
    AscendC::GlobalTensor<A_T> aGlobal;
    AscendC::GlobalTensor<B_T> bGlobal;
    AscendC::GlobalTensor<C_T> cGlobal;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueX;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueY;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueZ;
    AscendC::TQue<AscendC::TPosition::A1, 1> inQueueA1;
    AscendC::TQue<AscendC::TPosition::B1, 1> inQueueB1;
    AscendC::TQue<AscendC::TPosition::A2, 1> inQueueA2;
    AscendC::TQue<AscendC::TPosition::B2, 1> inQueueB2;
    AscendC::TQue<AscendC::TPosition::CO1, 1> inQueueCO1;
    AscendC::LocalTensor<A_T> bufferA1;
    AscendC::LocalTensor<B_T> bufferB1;
    AscendC::LocalTensor<A_T> bufferA2;
    AscendC::LocalTensor<B_T> bufferB2;
    AscendC::LocalTensor<C_T> bufferCO1;
    AscendC::LocalTensor<A_T> bufferLeft;
    AscendC::LocalTensor<B_T> bufferRight;
};

__global__ __aicore__ void data_copy_ub2l1_kfc(GM_ADDR aGM, GM_ADDR bGM, GM_ADDR cGM, GM_ADDR tilingGM,
                                               __kfc_workspace__ GM_ADDR workspaceGM)
{
    typedef AscendC::MatmulType<AscendC::TPosition::VECCALC, CubeFormat::ND, half, false> aType;
    typedef AscendC::MatmulType<AscendC::TPosition::VECCALC, CubeFormat::ND, half, false> bType;
    typedef AscendC::MatmulType<AscendC::TPosition::GM, CubeFormat::ND, float> cType;
    AscendC::TPipe pipe;
    MatMulKernel<aType, bType, cType> kernel;
    kernel.Init(aGM, bGM, cGM, tilingGM, &pipe);
    kernel.Process(workspaceGM);
}

static bool CompareResult(const void* outputData, uint32_t outSize)
{
    void* goldenData;
    aclrtMallocHost((void**)(&goldenData), outSize);
    size_t goldenSize = outSize;
    bool ret = ReadFile("./output/golden.bin", goldenSize, goldenData, goldenSize);
    if (ret) {
        printf("ReadFile golden.bin success!\n");
    } else {
        printf("test failed!\n");
        return false;
    }
    constexpr float EPS = 1e-4;
    int64_t wrongNum = 0;

    for (size_t i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult golden.bin failed output is %lf, golden is %lf\n", a, b);
            wrongNum++;
        }
    }
    aclrtFreeHost(goldenData);
    if (wrongNum != 0) {
        return false;
    } else {
        printf("CompareResult golden.bin success!\n");
        return true;
    }
}

int32_t main(int32_t argc, char* argv[])
{
    uint32_t numBlocks = 1;
    aclInit(nullptr);
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);
    int32_t m = 32, n = 32, k = 32;
    size_t aInputByteSize = static_cast<size_t>(1) * m * k * sizeof(uint16_t);
    size_t bInputByteSize = static_cast<size_t>(1) * k * n * sizeof(uint16_t);
    size_t outputByteSize = static_cast<size_t>(1) * m * n * sizeof(float);
    size_t tilingInputByteSize = static_cast<size_t>(1) * 64 * sizeof(float);
    size_t workspaceInputByteSize = static_cast<size_t>(1) * 131072 * sizeof(float);
    uint8_t *xHost, *yHost, *zHost, *tilingHost, *workspaceHost;
    uint8_t *xDevice, *yDevice, *zDevice, *tilingDevice, *workspaceDevice;
    aclrtMallocHost((void**)(&xHost), aInputByteSize);
    aclrtMallocHost((void**)(&yHost), bInputByteSize);
    aclrtMallocHost((void**)(&zHost), outputByteSize);
    aclrtMallocHost((void**)(&tilingHost), tilingInputByteSize);
    aclrtMallocHost((void**)(&workspaceHost), workspaceInputByteSize);
    aclrtMalloc((void**)&xDevice, aInputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&yDevice, bInputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&zDevice, outputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&tilingDevice, tilingInputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&workspaceDevice, workspaceInputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    ReadFile("./input/input_x.bin", aInputByteSize, xHost, aInputByteSize);
    ReadFile("./input/input_y.bin", bInputByteSize, yHost, bInputByteSize);
    ReadFile("./input/tiling.bin", tilingInputByteSize, tilingHost, tilingInputByteSize);
    ReadFile("./input/workspace.bin", workspaceInputByteSize, workspaceHost, workspaceInputByteSize);
    aclrtMemcpy(xDevice, aInputByteSize, xHost, aInputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(yDevice, bInputByteSize, yHost, bInputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(tilingDevice, tilingInputByteSize, tilingHost, tilingInputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(workspaceDevice, workspaceInputByteSize, workspaceHost, workspaceInputByteSize,
                ACL_MEMCPY_HOST_TO_DEVICE);
    data_copy_ub2l1_kfc<<<numBlocks, nullptr, stream>>>(xDevice, yDevice, zDevice, tilingDevice, workspaceDevice);
    aclrtSynchronizeStream(stream);
    aclrtMemcpy(zHost, outputByteSize, zDevice, outputByteSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", zHost, outputByteSize);
    bool goldenResult = true;
    goldenResult = CompareResult(zHost, outputByteSize);
    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }
    aclrtFree(xDevice);
    aclrtFree(yDevice);
    aclrtFree(tilingDevice);
    aclrtFree(workspaceDevice);
    aclrtFree(zDevice);
    aclrtFreeHost(xHost);
    aclrtFreeHost(yHost);
    aclrtFreeHost(tilingHost);
    aclrtFreeHost(workspaceHost);
    aclrtFreeHost(zHost);
    aclrtDestroyStream(stream);
    aclrtResetDevice(deviceId);
    aclFinalize();
    return 0;
}