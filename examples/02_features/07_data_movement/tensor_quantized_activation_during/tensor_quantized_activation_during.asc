/**
* Copyright (c) 2026 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/

/*!
 * \file scalar_quantized_activation_during.asc
 * \brief
 */
#include <cstdint>
#include "data_utils.h"
#include "kernel_operator.h"
#include "acl/acl.h"


struct MmadInputParams {
    __aicore__ MmadInputParams() {}
    
    __aicore__ MmadInputParams(uint16_t c1, uint16_t height, uint16_t width, 
                               uint8_t kernelHeight, uint8_t kernelWidth, 
                               uint16_t cout, uint16_t c0, 
                               uint16_t dilationHeight, uint16_t dilationWidth)
    {
        mC1 = c1;
        mH = height;
        mW = width;
        mKh = kernelHeight;
        mKw = kernelWidth;
        mCout = cout;
        mC0 = c0;
        mDilationH = dilationHeight;
        mDilationW = dilationWidth;
        mChannelSize = mC0 * mC1;

        mCoutBlocks = (mCout + 16 - 1) / 16;
        mHo = mH - mDilationH * (mKh - 1);
        mWo = mW - mDilationW * (mKw - 1);
        mHowo = mHo * mWo;
        mHowoRound = ((mHowo + 16 - 1) / 16) * 16;

        mFeatureMapSize = mC1 * mH * mW * mC0;           // [C1, H, W, C0]
        mWeightSize = mC1 * mKh * mKw * mCout * mC0;     // [C1, Kh, Kw, Cout, C0]
        mFeatureMapL0aSize = mHowoRound * (mC1 * mKh * mKw * mC0);
        mWeightL0bSize = (mC1 * mKh * mKw * mC0) * mCoutBlocks * 16;
        mM = mHowo;
        mK = mC1 * mKh * mKw * mC0;
        mN = mCout;
        mDeqSize = mCout;                            // [Cout]
        mDstSize = mCoutBlocks * mHowo * 16;          // [coutBlocks, howo, 16]
        mDstL0cSize = mCoutBlocks * mHowoRound * 16;

        mFmRepeat = mFeatureMapL0aSize / (16 * mC0);
        mWeRepeat = mWeightL0bSize / (16 * mC0);
    }

    uint16_t mC1;
    uint16_t mH;
    uint16_t mW;
    uint8_t mKh;
    uint8_t mKw;
    uint16_t mCout;
    uint16_t mC0;
    uint8_t mDilationH;
    uint8_t mDilationW;
    uint16_t mChannelSize;

    uint16_t mCoutBlocks;
    uint16_t mHo;
    uint16_t mWo;
    uint16_t mHowo;
    uint16_t mHowoRound;

    uint32_t mFeatureMapSize;
    uint32_t mWeightSize;
    uint32_t mFeatureMapL0aSize;
    uint32_t mWeightL0bSize;
    uint16_t mM;
    uint16_t mK;
    uint16_t mN;
    uint32_t mDeqSize;
    uint32_t mDstSize;
    uint32_t mDstL0cSize;

    uint8_t mFmRepeat;
    uint8_t mWeRepeat;
};

template <typename FeatureMapT, typename WeightT, typename L1OutT, typename DstT>
class TestDataCopyL0c2Gm {
public:
    __aicore__ inline void Init(GM_ADDR fmData, GM_ADDR weData, 
                                GM_ADDR deqTensor, GM_ADDR elewiseTensor, 
                                GM_ADDR tiling, GM_ADDR outputData, AscendC::TPipe* pipeIn)
    {
        mPipe = pipeIn;
        mFeatureMapTSize = sizeof(FeatureMapT);
        mWeightTSize = sizeof(WeightT);
        mL1OutTSize = sizeof(L1OutT);
        mDstTSize = sizeof(DstT);
        
        mTilingGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ uint32_t*>(tiling), 16);
        mC1 = static_cast<uint16_t>(mTilingGlobal.GetValue(0));
        mH = static_cast<uint16_t>(mTilingGlobal.GetValue(1));
        mW = static_cast<uint16_t>(mTilingGlobal.GetValue(2));
        mKh = static_cast<uint8_t>(mTilingGlobal.GetValue(3));
        mKw = static_cast<uint8_t>(mTilingGlobal.GetValue(4));
        mCout = static_cast<uint16_t>(mTilingGlobal.GetValue(5));
        mC0 = static_cast<uint16_t>(mTilingGlobal.GetValue(6));
        mDilationH = static_cast<uint8_t>(mTilingGlobal.GetValue(7));
        mDilationW = static_cast<uint8_t>(mTilingGlobal.GetValue(8));
        mQuantMode = static_cast<uint8_t>(mTilingGlobal.GetValue(9));
        mEnRelu = static_cast<bool>(mTilingGlobal.GetValue(10));
        mEnNz2nd = static_cast<bool>(mTilingGlobal.GetValue(11));
        mEnSplit = static_cast<bool>(mTilingGlobal.GetValue(12));
        mClipRelu = static_cast<uint8_t>(mTilingGlobal.GetValue(13));
        mElewiseOp = static_cast<uint8_t>(mTilingGlobal.GetValue(14));

        MmadInputParams inputParams(mC1, mH, mW, mKh, mKw, mCout, mC0, mDilationH, mDilationW);
        mCoutBlocks = inputParams.mCoutBlocks;
        mWo = inputParams.mWo;
        mHowo = inputParams.mHowo;
        mHowoRound = inputParams.mHowoRound;
        mFeatureMapSize = inputParams.mFeatureMapSize;
        mWeightSize = inputParams.mWeightSize;
        mFeatureMapL0aSize = inputParams.mFeatureMapL0aSize;
        mWeightL0bSize = inputParams.mWeightL0bSize;
        mM = inputParams.mM;
        mK = inputParams.mK;
        mN = inputParams.mN;
        mDeqSize = inputParams.mDeqSize;
        mDstSize = inputParams.mDstSize;
        mDstL0cSize = inputParams.mDstL0cSize;
        deqDataSize = AscendC::DivCeil(mDeqSize * sizeof(uint64_t), 128) * 128;

        mFmRepeat = inputParams.mFmRepeat;
        mWeRepeat = inputParams.mWeRepeat;
        
        mFeatureMapGm.SetGlobalBuffer(reinterpret_cast<__gm__ FeatureMapT*>(fmData), mFeatureMapSize);
        mWeightGm.SetGlobalBuffer(reinterpret_cast<__gm__ WeightT*>(weData), mWeightSize);
        mDeqTensorGm.SetGlobalBuffer(reinterpret_cast<__gm__ uint64_t*>(deqTensor), mDeqSize);
        mElewiseGm.SetGlobalBuffer(reinterpret_cast<__gm__ half*>(elewiseTensor), mDstSize);
        mOutputGm.SetGlobalBuffer(reinterpret_cast<__gm__ DstT*>(outputData), mDstSize);
        
        mPipe->InitBuffer(mInQueueFmA1, 1, mFeatureMapSize * sizeof(FeatureMapT));
        mPipe->InitBuffer(mInQueueFmA2, 1, mFeatureMapL0aSize * sizeof(FeatureMapT));
        mPipe->InitBuffer(mInQueueWeB1, 1, mWeightSize * sizeof(WeightT));
        mPipe->InitBuffer(mInQueueWeB2, 1, mWeightL0bSize * sizeof(WeightT));
        mPipe->InitBuffer(mOutQueueC1, 1, mDstL0cSize * sizeof(L1OutT));

        mPipe->InitBuffer(inQueueDeqFB, 1, deqDataSize);
        mPipe->InitBuffer(inQueueEleWise, 1, mDstL0cSize * sizeof(half));
        mPipe->InitBuffer(inQueueCubeWorkspace, 1, mDeqSize * sizeof(uint64_t));
    }
    
    __aicore__ inline void Process()
    {
        CopyIn();
        Split();
        Compute();
        CopyOut();
    }
    
private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<FeatureMapT> featureMapA1 = mInQueueFmA1.AllocTensor<FeatureMapT>();
        AscendC::LocalTensor<WeightT> weightB1 = mInQueueWeB1.AllocTensor<WeightT>();
        
        AscendC::DataCopy(featureMapA1, mFeatureMapGm, 
                {1, static_cast<uint16_t>(mFeatureMapSize * sizeof(FeatureMapT) / 32), 0, 0});
        AscendC::DataCopy(weightB1, mWeightGm, 
                {1, static_cast<uint16_t>(mWeightSize * sizeof(WeightT) / 32), 0, 0});
        
        mInQueueFmA1.EnQue(featureMapA1);
        mInQueueWeB1.EnQue(weightB1);
    }
    
    __aicore__ inline void Split()
    {
        AscendC::LocalTensor<FeatureMapT> featureMapA1 = mInQueueFmA1.DeQue<FeatureMapT>();
        AscendC::LocalTensor<WeightT> weightB1 = mInQueueWeB1.DeQue<WeightT>();
        AscendC::LocalTensor<FeatureMapT> featureMapA2 = mInQueueFmA2.AllocTensor<FeatureMapT>();
        AscendC::LocalTensor<WeightT> weightB2 = mInQueueWeB2.AllocTensor<WeightT>();
        
        uint8_t padList[] = {0, 0, 0, 0};
        // load3dv2
        AscendC::LoadData(featureMapA2, featureMapA1, 
                {padList, mH, mW, 36, mK, mHowoRound, 0, 0, 1, 1, mKw, 
                 mKh, mDilationW, mDilationH, false, false, 0});
        // load2d
        AscendC::LoadData(weightB2, weightB1, {0, mWeRepeat, 1, 0, 0, false, 0});
        
        mInQueueFmA2.EnQue<FeatureMapT>(featureMapA2);
        mInQueueWeB2.EnQue<WeightT>(weightB2);
        mInQueueFmA1.FreeTensor(featureMapA1);
        mInQueueWeB1.FreeTensor(weightB1);
    }
    
    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<FeatureMapT> featureMapA2 = mInQueueFmA2.DeQue<FeatureMapT>();
        AscendC::LocalTensor<WeightT> weightB2 = mInQueueWeB2.DeQue<WeightT>();
        AscendC::LocalTensor<L1OutT> dstL0c = mOutQueueC1.AllocTensor<L1OutT>();

        AscendC::Mmad(dstL0c, featureMapA2, weightB2, {mM, mN, mK, 0, false, true});
        
        mOutQueueC1.EnQue<L1OutT>(dstL0c);
        mInQueueFmA2.FreeTensor(featureMapA2);
        mInQueueWeB2.FreeTensor(weightB2);
    }
    
    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<L1OutT> dstL0c = mOutQueueC1.DeQue<L1OutT>();
        AscendC::LocalTensor<uint64_t> cbufWorkspace = inQueueCubeWorkspace.AllocTensor<uint64_t>();
        
        float tmp = 0.5f;
        uint64_t deqScalar = static_cast<uint64_t>(*reinterpret_cast<int32_t*>(&tmp));
        
        uint16_t nSize = mCoutBlocks * AscendC::BLOCK_CUBE;
        uint16_t mSize = mM;
        uint16_t srcStride = AscendC::DivCeil(mM, AscendC::BLOCK_CUBE) * AscendC::BLOCK_CUBE;
        uint32_t dstStride = mM * sizeof(DstT) * AscendC::BLOCK_CUBE / AscendC::ONE_BLK_SIZE;
        
        if (mEnSplit) {
            dstStride = dstStride / 2;
        }
        
        if (mEnNz2nd) {
            AscendC::SetFixpipeNz2ndFlag(1, 0, 0);
            nSize = mN;
            dstStride = nSize;
        }
        
        if (static_cast<QuantMode_t>(mQuantMode) == QuantMode_t::VDEQF16) {
            AscendC::DataCopy(cbufWorkspace, mDeqTensorGm, 
                    {1, static_cast<uint16_t>(deqDataSize / AscendC::ONE_BLK_SIZE), 0, 0});
            set_flag(PIPE_MTE2, PIPE_FIX, EVENT_ID3);
            wait_flag(PIPE_MTE2, PIPE_FIX, EVENT_ID3);
            
            AscendC::LocalTensor<uint64_t> deqTensorTempBuf = inQueueDeqFB.AllocTensor<uint64_t>();
            uint16_t fbufBurstLen = deqDataSize / 128;
            AscendC::DataCopyParams dataCopyParams(1, fbufBurstLen, 0, 0);
            AscendC::DataCopy(deqTensorTempBuf, cbufWorkspace, dataCopyParams);
            AscendC::SetFixPipeConfig(deqTensorTempBuf);
            AscendC::PipeBarrier<PIPE_FIX>();
            inQueueDeqFB.FreeTensor(deqTensorTempBuf);
            inQueueCubeWorkspace.FreeTensor(cbufWorkspace);
        } else {
            AscendC::SetFixpipePreQuantFlag(deqScalar);
            AscendC::PipeBarrier<PIPE_FIX>();
        }
        
        AscendC::DataCopyCO12DstParams intriParams(nSize, mSize, dstStride, srcStride,
                                                   static_cast<QuantMode_t>(mQuantMode), 
                                                   static_cast<uint8_t>(mEnRelu), 
                                                   mEnSplit, mEnNz2nd);
        
#if defined(__NPU_ARCH__) && (__NPU_ARCH__ == 3003 || __NPU_ARCH__ == 3002)
        intriParams.eltWiseOp = mElewiseOp;
        intriParams.clipReluPre = mClipRelu;
        
        AscendC::LocalTensor<half> elewiseTensorBuffer = inQueueEleWise.AllocTensor<half>();
        
        AscendC::DataCopy(elewiseTensorBuffer, mElewiseGm, 
                {1, static_cast<uint16_t>(sizeof(half) * mDstSize / 32), 0, 0});
        AscendC::PipeBarrier<PIPE_ALL>();
        AscendC::SetFixPipeAddr(elewiseTensorBuffer, 1);
        
        uint64_t clipReluVal = 0x3c00; // value 1, half
        AscendC::SetFixPipeClipRelu(clipReluVal);
        inQueueEleWise.FreeTensor(elewiseTensorBuffer);
#endif
        
        AscendC::DataCopy(mOutputGm, dstL0c, intriParams);
        AscendC::PipeBarrier<PIPE_ALL>();
        mOutQueueC1.FreeTensor(dstL0c);
    }
    
private:
    AscendC::TPipe* mPipe;
    // feature map queue
    AscendC::TQue<AscendC::TPosition::A1, 1> mInQueueFmA1;
    AscendC::TQue<AscendC::TPosition::A2, 1> mInQueueFmA2;
    // weight queue
    AscendC::TQue<AscendC::TPosition::B1, 1> mInQueueWeB1;
    AscendC::TQue<AscendC::TPosition::B2, 1> mInQueueWeB2;
    // dst queue
    AscendC::TQue<AscendC::TPosition::CO1, 1> mOutQueueC1;

    AscendC::TQue<AscendC::TPosition::C2PIPE2GM, 1> inQueueDeqFB;
    AscendC::TQue<AscendC::TPosition::C1, 1> inQueueEleWise;
    AscendC::TQue<AscendC::TPosition::C1, 1> inQueueCubeWorkspace;

    uint16_t mC1;
    uint16_t mH;
    uint16_t mW;
    uint8_t mKh;
    uint8_t mKw;
    uint16_t mCout;
    uint16_t mC0;
    uint8_t mDilationH;
    uint8_t mDilationW;
    uint8_t mQuantMode;
    bool mEnRelu;
    bool mEnNz2nd;
    bool mEnSplit;
    uint8_t mClipRelu;
    uint8_t mElewiseOp;
    
    uint16_t mCoutBlocks;
    uint16_t mWo;
    uint16_t mHowo;
    uint16_t mHowoRound;
    uint32_t mFeatureMapSize;
    uint32_t mWeightSize;
    uint32_t mFeatureMapL0aSize;
    uint32_t mWeightL0bSize;
    uint16_t mM;
    uint16_t mK;
    uint16_t mN;
    uint32_t mDeqSize;
    uint32_t mDstSize;
    uint32_t mDstL0cSize;
    
    uint8_t mFmRepeat;
    uint8_t mWeRepeat;
    uint8_t mFeatureMapTSize;
    uint8_t mWeightTSize;
    uint8_t mL1OutTSize;
    uint8_t mDstTSize;
    uint16_t deqDataSize;
    
    AscendC::GlobalTensor<FeatureMapT> mFeatureMapGm;
    AscendC::GlobalTensor<WeightT> mWeightGm;
    AscendC::GlobalTensor<uint64_t> mDeqTensorGm;
    AscendC::GlobalTensor<half> mElewiseGm;
    AscendC::GlobalTensor<DstT> mOutputGm;
    AscendC::GlobalTensor<uint32_t> mTilingGlobal;
};

__cube__ __global__ void KernelFixpipeCustom(GM_ADDR fmData, GM_ADDR weData, 
                                             GM_ADDR deqTensor, GM_ADDR elewiseTensor, 
                                             GM_ADDR tiling, GM_ADDR outputData) 
{
    TestDataCopyL0c2Gm<int8_t, int8_t, int32_t, half> op;
    AscendC::TPipe pipe;
    op.Init(fmData, weData, deqTensor, elewiseTensor, tiling, outputData, &pipe);
    op.Process();
}

int32_t main(int32_t argc, char* argv[]) 
{
    uint32_t blockDim = 1;
    size_t FM_SIZE = 1 * 4 * 4 * 32 * sizeof(int8_t);
    size_t WE_SIZE = 1 * 2 * 2 * 128 * 32 * sizeof(int8_t);
    size_t DEQ_SIZE = 8 * 16 * sizeof(uint64_t);
    size_t ELEWISE_SIZE = 8 * 9 * 16 * sizeof(half);
    size_t TILING_SIZE = 16 * sizeof(uint32_t);
    size_t GOLDEN_SIZE = 8 * 9 * 16 * sizeof(half);

    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *fmHost, *weHost, *deqHost, *elewiseHost, *tilingHost, *outHost;
    uint8_t *fmDevice, *weDevice, *deqDevice, *elewiseDevice, *tilingDevice, *outDevice;

    aclrtMallocHost(reinterpret_cast<void**>(&fmHost), FM_SIZE);
    aclrtMallocHost(reinterpret_cast<void**>(&weHost), WE_SIZE);
    aclrtMallocHost(reinterpret_cast<void**>(&deqHost), DEQ_SIZE);
    aclrtMallocHost(reinterpret_cast<void**>(&elewiseHost), ELEWISE_SIZE);
    aclrtMallocHost(reinterpret_cast<void**>(&tilingHost), TILING_SIZE);
    aclrtMallocHost(reinterpret_cast<void**>(&outHost), GOLDEN_SIZE);

    aclrtMalloc(reinterpret_cast<void**>(&fmDevice), FM_SIZE, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc(reinterpret_cast<void**>(&weDevice), WE_SIZE, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc(reinterpret_cast<void**>(&deqDevice), DEQ_SIZE, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc(reinterpret_cast<void**>(&elewiseDevice), ELEWISE_SIZE, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc(reinterpret_cast<void**>(&tilingDevice), TILING_SIZE, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc(reinterpret_cast<void**>(&outDevice), GOLDEN_SIZE, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/fm_data.bin", FM_SIZE, fmHost, FM_SIZE);
    ReadFile("./input/we_data.bin", WE_SIZE, weHost, WE_SIZE);
    ReadFile("./input/deq_data.bin", DEQ_SIZE, deqHost, DEQ_SIZE);
    ReadFile("./input/elewise_data.bin", ELEWISE_SIZE, elewiseHost, ELEWISE_SIZE);
    ReadFile("./input/tiling_data.bin", TILING_SIZE, tilingHost, TILING_SIZE);

    aclrtMemcpy(fmDevice, FM_SIZE, fmHost, FM_SIZE, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(weDevice, WE_SIZE, weHost, WE_SIZE, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(deqDevice, DEQ_SIZE, deqHost, DEQ_SIZE, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(elewiseDevice, ELEWISE_SIZE, elewiseHost, ELEWISE_SIZE, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(tilingDevice, TILING_SIZE, tilingHost, TILING_SIZE, ACL_MEMCPY_HOST_TO_DEVICE);

    KernelFixpipeCustom<<<blockDim, nullptr, stream>>>(fmDevice, weDevice, deqDevice, 
                                                        elewiseDevice, tilingDevice, outDevice);
    aclrtSynchronizeStream(stream);

    aclrtMemcpy(outHost, GOLDEN_SIZE, outDevice, GOLDEN_SIZE, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", outHost, GOLDEN_SIZE);

    aclrtFree(fmDevice);
    aclrtFree(weDevice);
    aclrtFree(deqDevice);
    aclrtFree(elewiseDevice);
    aclrtFree(tilingDevice);
    aclrtFree(outDevice);

    aclrtFreeHost(fmHost);
    aclrtFreeHost(weHost);
    aclrtFreeHost(deqHost);
    aclrtFreeHost(elewiseHost);
    aclrtFreeHost(tilingHost);
    aclrtFreeHost(outHost);

    aclrtDestroyStream(stream);
    aclrtResetDevice(deviceId);
    aclFinalize();

    return 0;
}