/**
* Copyright (c) 2026 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file pipe_barrier.asc
 * \brief
 */
#include <random>
#include "acl/acl.h"
#include "kernel_operator.h"
class KernelPipeBarrier{
public:
    __aicore__ inline KernelPipeBarrier() {}
    __aicore__ inline void Init(__gm__ uint8_t* src0Gm, __gm__ uint8_t* src1Gm,  __gm__ uint8_t* src2Gm, __gm__ uint8_t* dstGm)
    {
        src0Global.SetGlobalBuffer((__gm__ float*)src0Gm, srcDataSize);
        src1Global.SetGlobalBuffer((__gm__ float*)src1Gm, srcDataSize);
        src2Global.SetGlobalBuffer((__gm__ float*)src2Gm, srcDataSize);
        dstGlobal.SetGlobalBuffer((__gm__ float*)dstGm, dstDataSize);
    }
    __aicore__ inline void Process()
    {
        AscendC::LocalTensor<float> src0Local(AscendC::TPosition::VECCALC, src0Addr, srcDataSize);
        AscendC::LocalTensor<float> src1Local(AscendC::TPosition::VECCALC, src1Addr, srcDataSize);
        AscendC::LocalTensor<float> src2Local(AscendC::TPosition::VECCALC, src2Addr, srcDataSize);
        AscendC::LocalTensor<float> dstLocal(AscendC::TPosition::VECCALC, dstAddr, srcDataSize);

        AscendC::DataCopy(src0Local, src0Global, srcDataSize);
        AscendC::DataCopy(src2Local, src2Global, srcDataSize);
        // 两条搬运指令之间需要调用PipeBarrier<PIPE_MTE2>()添加MTE2搬入流水的同步
        AscendC::PipeBarrier<PIPE_MTE2>();
        AscendC::DataCopy(src1Local, src1Global, srcDataSize);
        // 输入src1和src2在UB上分配的地址区间有重叠
        // 为了保证了src2的数据不会覆盖src1在重叠区间的值，必须保证先搬入src2，后搬入src1

        // 确保先搬入，后进行vector计算
        AscendC::SetFlag<AscendC::HardEvent::MTE2_V>(EVENT_ID0);
        AscendC::WaitFlag<AscendC::HardEvent::MTE2_V>(EVENT_ID0);

        AscendC::Add(dstLocal, src0Local, src1Local, srcDataSize);

        // 确保先进行vector计算，然后搬出
        AscendC::SetFlag<AscendC::HardEvent::V_MTE3>(EVENT_ID0);
        AscendC::WaitFlag<AscendC::HardEvent::V_MTE3>(EVENT_ID0);

        AscendC::DataCopy(dstGlobal, dstLocal, dstDataSize);
    }
private:
    static constexpr uint32_t src0Addr = 0;
    // 输入src1和src2在UB上分配的地址区间有重叠
    // 为了保证了src2的数据不会覆盖src1在重叠区间的值，必须保证先搬入src2，后搬入src1
    static constexpr uint32_t src1Addr = 256 * sizeof(float); // src1起始地址，长度为256
    static constexpr uint32_t src2Addr = (256 + 128) * sizeof(float); // src2起始地址，长度为256
    static constexpr uint32_t dstAddr = 256 * 3 * sizeof(float);
    AscendC::GlobalTensor<float> src0Global, src1Global, src2Global;
    AscendC::GlobalTensor<float> dstGlobal;
    uint32_t srcDataSize = 256;
    uint32_t dstDataSize = srcDataSize;
};

__global__ __vector__ void pipe_barrier_custom(GM_ADDR src0, GM_ADDR src1, GM_ADDR src2, GM_ADDR dst) 
{
    AscendC::InitSocState();
    KernelPipeBarrier op;
    op.Init(src0, src1, src2, dst);
    op.Process();
}

static bool CompareResult(const void* outputData, const void* goldenData, uint32_t outSize)
{
    size_t goldenSize = outSize;
    constexpr float EPS = 1e-4;
    int64_t wrongNum = 0;

    for (size_t i = 0; i < outSize / sizeof(float); i++) {
        float a = (reinterpret_cast<const float*>(outputData))[i];
        float b = (reinterpret_cast<const float*>(goldenData))[i];
        float ae = std::abs(a - b);
        float re = ae / std::abs(b);
        if (ae > EPS && re > EPS) {
            printf("CompareResult failed output is %lf, golden is %lf\n", a, b);
            wrongNum++;
        }
    }
    if (wrongNum != 0) {
        return false;
    } else {
        return true;
    }
}

// 定义返回结构体
struct GoldenData {
    std::vector<float> src0;
    std::vector<float> src1;
    std::vector<float> src2;
    std::vector<float> golden;
};

GoldenData gen_golden_data()
{
    const int totalLength = 256;
    std::vector<float> src0(totalLength, 1);
    std::vector<float> src1(totalLength, 1);
    std::vector<float> src2(totalLength, -3);
    std::vector<float> golden(totalLength);
    for (size_t i = 0; i < golden.size(); ++i) {
        golden[i] = src0[i] + src1[i];
    }
    return {src0, src1, src2, golden};
}

int32_t main(int32_t argc, char* argv[]) 
{
    uint32_t numBlocks = 1;
    size_t inputByteSize = 256 * sizeof(float);
    size_t outputByteSize = 256 * sizeof(float);

    auto genData = gen_golden_data();
    auto src0 = genData.src0;
    auto src1 = genData.src1;
    auto src2 = genData.src2;
    auto golden = genData.golden;
    uint8_t* goldenHost = reinterpret_cast<uint8_t*>(golden.data());

    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    uint8_t *dstHost;
    uint8_t *src0Device, *src1Device, *src2Device, *dstDevice;

    aclrtMallocHost((void **)(&dstHost), outputByteSize);
    aclrtMalloc((void **)&src0Device, inputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&src1Device, inputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&src2Device, inputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&dstDevice, outputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);

    uint8_t* src0Host = reinterpret_cast<uint8_t*>(src0.data());
    uint8_t* src1Host = reinterpret_cast<uint8_t*>(src1.data());
    uint8_t* src2Host = reinterpret_cast<uint8_t*>(src2.data());

    aclrtMemcpy(src0Device, inputByteSize, src0Host, inputByteSize,
                ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(src1Device, inputByteSize, src1Host, inputByteSize,
                ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(src2Device, inputByteSize, src2Host, inputByteSize,
                ACL_MEMCPY_HOST_TO_DEVICE);

    pipe_barrier_custom<<<numBlocks, nullptr, stream>>>(src0Device, src1Device, src2Device, dstDevice);
    aclrtSynchronizeStream(stream);

    aclrtMemcpy(dstHost, outputByteSize, dstDevice, outputByteSize,
                ACL_MEMCPY_DEVICE_TO_HOST);
    bool goldenResult = true;
    goldenResult = CompareResult(dstHost, goldenHost, outputByteSize);
    if (goldenResult) {
        printf("test pass!\n");
    } else {
        printf("test failed!\n");
    }
    aclrtFree(src0Device);
    aclrtFree(src1Device);
    aclrtFree(src2Device);
    aclrtFree(dstDevice);
    aclrtFreeHost(src0Host);
    aclrtFreeHost(src1Host);
    aclrtFreeHost(src2Host);
    aclrtFreeHost(dstHost);
    aclrtDestroyStream(stream);
    aclrtResetDevice(deviceId);
    aclFinalize();

    return 0;
}
