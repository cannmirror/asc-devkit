/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file mutex.asc
 * \brief
 */

#include "acl/acl.h"
#include "data_utils.h"
#include "kernel_operator.h"

constexpr int BLOCK_LENGTH = 2048;
constexpr int TILE_LENGTH = 2048 / 8;
class KernelAdd {
public:
    __aicore__ inline KernelAdd() {}
    __aicore__ inline void Init(__gm__ uint8_t* src0Gm, __gm__ uint8_t* src1Gm, __gm__ uint8_t* dstGm, AscendC::TPipe* pipeIn)
    {
        pipe = pipeIn;
        src0Global.SetGlobalBuffer((__gm__ float*)src0Gm, BLOCK_LENGTH);
        src1Global.SetGlobalBuffer((__gm__ float*)src1Gm, BLOCK_LENGTH);
        dstGlobal.SetGlobalBuffer((__gm__ float*)dstGm, BLOCK_LENGTH);
        pipe->InitBuffer(tmpBufInX[0], TILE_LENGTH * sizeof(float));
        pipe->InitBuffer(tmpBufInY[0], TILE_LENGTH * sizeof(float));
        pipe->InitBuffer(tmpBufOutZ[0], TILE_LENGTH * sizeof(float));
        pipe->InitBuffer(tmpBufInX[1], TILE_LENGTH * sizeof(float));
        pipe->InitBuffer(tmpBufInY[1], TILE_LENGTH * sizeof(float));
        pipe->InitBuffer(tmpBufOutZ[1], TILE_LENGTH * sizeof(float));
    }
    __aicore__ inline void Process()
    {
        constexpr int32_t loopCount = 8;
        uint8_t mutexId = 0;
        for (int32_t i = 0 ; i<loopCount; i++) {
            if (i % 2 == 0) {
                mutexId = 0;
            } else {
                mutexId = 1;
            }
            CopyIn(i, mutexId);
            Compute(i, mutexId);
            CopyOut(i, mutexId);
        }
    }
    __aicore__ inline void CopyIn(int32_t progress, uint8_t mutexId)
    {
        AscendC::LocalTensor<float> xLocal = tmpBufInX[mutexId].Get<float>();
        AscendC::LocalTensor<float> yLocal = tmpBufInY[mutexId].Get<float>();
        AscendC::Mutex::Lock<PIPE_MTE2>(mutexId);
        AscendC::DataCopy(xLocal, src0Global[TILE_LENGTH * progress], TILE_LENGTH);
        AscendC::DataCopy(yLocal, src1Global[TILE_LENGTH * progress], TILE_LENGTH);
        AscendC::Mutex::Unlock<PIPE_MTE2>(mutexId);
    }
    __aicore__ inline void Compute(int32_t progress, uint8_t mutexId)
    {
        AscendC::LocalTensor<float> xLocal = tmpBufInX[mutexId].Get<float>();
        AscendC::LocalTensor<float> yLocal = tmpBufInY[mutexId].Get<float>();
        AscendC::LocalTensor<float> zLocal = tmpBufOutZ[mutexId].Get<float>();
        AscendC::Mutex::Lock<PIPE_V>(mutexId);
        AscendC::Add(zLocal, xLocal, yLocal, TILE_LENGTH);
        AscendC::Mutex::Unlock<PIPE_V>(mutexId);
    }
    __aicore__ inline void CopyOut(int32_t progress, uint8_t mutexId)
    {
        AscendC::LocalTensor<float> zLocal = tmpBufOutZ[mutexId].Get<float>();
        AscendC::Mutex::Lock<PIPE_MTE3>(mutexId);
        AscendC::DataCopy(dstGlobal[TILE_LENGTH * progress], zLocal, TILE_LENGTH);
        AscendC::Mutex::Unlock<PIPE_MTE3>(mutexId);
    }
private:
    AscendC::TPipe* pipe;
    AscendC::TBuf<> tmpBufInX[2];
    AscendC::TBuf<> tmpBufInY[2];
    AscendC::TBuf<> tmpBufOutZ[2];
    AscendC::GlobalTensor<float> src0Global, src1Global, dstGlobal;
};

__vector__ __global__ void mutex_custom(GM_ADDR x, GM_ADDR y, GM_ADDR z) 
{
  AscendC::TPipe pipe;
  KernelAdd op;
  op.Init(x, y, z, &pipe);
  op.Process();
}

int32_t main(int32_t argc, char* argv[]) 
{
  uint32_t numBlocks = 1;
  size_t inputByteSize = BLOCK_LENGTH * sizeof(float);
  size_t outputByteSize = BLOCK_LENGTH * sizeof(float);

  int32_t deviceId = 0;
  aclrtSetDevice(deviceId);
  aclrtStream stream = nullptr;
  aclrtCreateStream(&stream);

  uint8_t *xHost, *yHost, *zHost;
  uint8_t *xDevice, *yDevice, *zDevice;

  aclrtMallocHost((void **)(&xHost), inputByteSize);
  aclrtMallocHost((void **)(&yHost), inputByteSize);
  aclrtMallocHost((void **)(&zHost), outputByteSize);
  aclrtMalloc((void **)&xDevice, inputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
  aclrtMalloc((void **)&yDevice, inputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
  aclrtMalloc((void **)&zDevice, outputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);

  ReadFile("./input/input_x.bin", inputByteSize, xHost, inputByteSize);
  ReadFile("./input/input_y.bin", inputByteSize, yHost, inputByteSize);

  aclrtMemcpy(xDevice, inputByteSize, xHost, inputByteSize,
              ACL_MEMCPY_HOST_TO_DEVICE);
  aclrtMemcpy(yDevice, inputByteSize, yHost, inputByteSize,
              ACL_MEMCPY_HOST_TO_DEVICE);

  mutex_custom<<<numBlocks, nullptr, stream>>>(xDevice, yDevice, zDevice);
  aclrtSynchronizeStream(stream);

  aclrtMemcpy(zHost, outputByteSize, zDevice, outputByteSize,
              ACL_MEMCPY_DEVICE_TO_HOST);
  WriteFile("./output/output.bin", zHost, outputByteSize);

  aclrtFree(xDevice);
  aclrtFree(yDevice);
  aclrtFree(zDevice);
  aclrtFreeHost(xHost);
  aclrtFreeHost(yHost);
  aclrtFreeHost(zHost);

  aclrtDestroyStream(stream);
  aclrtResetDevice(deviceId);
  aclFinalize();

  return 0;
}

