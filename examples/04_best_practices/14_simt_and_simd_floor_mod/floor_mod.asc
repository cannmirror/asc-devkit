/**
* Copyright (c) 2026 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/


/* !
 * \file floor_mod.asc
 * \brief
 */

#include <chrono>
#include <iostream>
#include <iterator>
#include <random>
#include <vector>
#include "acl/acl.h"
#include "kernel_operator.h"
#include "simt_api/asc_simt.h"

namespace {
    constexpr float ADDS_ADDEND = 1.0f;
    constexpr uint32_t THREAD_COUNT = 1024;
    constexpr uint32_t FMOD_B32_SIGN = 0x80000000;
    constexpr uint32_t DATA_LEN_PER_CORE = 1024;
    constexpr uint32_t VECTOR_LENGTH = 256U; // 256: Reg length
}

template <typename T>
__simd_vf__ inline void floor_mod_float_simd(__ubuf__ T* fmodResAddr, __ubuf__ T* otherAddr, __ubuf__ T* dstAddr, const uint32_t count)
{
    uint32_t vecLen = VECTOR_LENGTH / sizeof(T);
    uint16_t loopTimes = (count + vecLen - 1) / vecLen;

    AscendC::MicroAPI::RegTensor<T> zeroValue;
    AscendC::MicroAPI::RegTensor<T> fmodResValue;
    AscendC::MicroAPI::RegTensor<T> inputX2Value;
    AscendC::MicroAPI::RegTensor<T> addValue;
    AscendC::MicroAPI::RegTensor<T> resValue;

    AscendC::MicroAPI::RegTensor<uint32_t> signValue;
    AscendC::MicroAPI::RegTensor<uint32_t> fmodSignValue;
    AscendC::MicroAPI::RegTensor<uint32_t> inputX2signValue;

    AscendC::MicroAPI::MaskReg preg;
    AscendC::MicroAPI::MaskReg negValue;
    AscendC::MicroAPI::MaskReg signNegValue;
    AscendC::MicroAPI::MaskReg resMaskValue;
    uint32_t sregMask = count;

    AscendC::MicroAPI::Duplicate(zeroValue, T(0));
    AscendC::MicroAPI::Duplicate(signValue, FMOD_B32_SIGN);

    for (uint16_t j = 0; j < loopTimes; j++) {
        preg = AscendC::MicroAPI::UpdateMask<T>(sregMask);
        AscendC::MicroAPI::DataCopy<T, AscendC::MicroAPI::LoadDist::DIST_NORM>(fmodResValue, fmodResAddr + vecLen * j);
        AscendC::MicroAPI::Compare<T, AscendC::CMPMODE::NE>(negValue, fmodResValue, zeroValue, preg);

        AscendC::MicroAPI::And(fmodSignValue, (AscendC::MicroAPI::RegTensor<uint32_t>&)fmodResValue, signValue, preg);
        AscendC::MicroAPI::DataCopy<T, AscendC::MicroAPI::LoadDist::DIST_NORM>(inputX2Value, otherAddr + vecLen * j);
        AscendC::MicroAPI::Add(addValue, fmodResValue, inputX2Value, preg);
        AscendC::MicroAPI::And(inputX2signValue, (AscendC::MicroAPI::RegTensor<uint32_t>&)inputX2Value, signValue, preg);
        AscendC::MicroAPI::Compare<uint32_t, AscendC::CMPMODE::NE>(signNegValue, fmodSignValue, inputX2signValue, preg);

        AscendC::MicroAPI::MaskAnd(resMaskValue, signNegValue, negValue, preg);
        AscendC::MicroAPI::Select(resValue, addValue, fmodResValue, resMaskValue);
        AscendC::MicroAPI::DataCopy<T, AscendC::MicroAPI::StoreDist::DIST_NORM>(dstAddr + vecLen * j, resValue, preg);
    }
}

template <typename T>
__simd_vf__ inline void floor_mod_int_simd(__ubuf__ T* dstAddr, __ubuf__ T* input1Addr, __ubuf__ T* input2Addr,
    __ubuf__ T* divAddr, const uint32_t count)
{
    uint32_t vecLen = VECTOR_LENGTH / sizeof(T);
    uint16_t loopTimes = (count + vecLen - 1) / vecLen;

    AscendC::MicroAPI::RegTensor<T> zeroValue;
    AscendC::MicroAPI::RegTensor<T> defaultValue;
    AscendC::MicroAPI::RegTensor<T> signValue;
    AscendC::MicroAPI::RegTensor<T> input1Value;
    AscendC::MicroAPI::RegTensor<T> input2Value;
    AscendC::MicroAPI::RegTensor<T> divValue;
    AscendC::MicroAPI::RegTensor<T> mulValue;
    AscendC::MicroAPI::RegTensor<T> subValue;
    AscendC::MicroAPI::RegTensor<T> modValue;
    AscendC::MicroAPI::RegTensor<T> modSignValue;
    AscendC::MicroAPI::RegTensor<T> addValue;
    AscendC::MicroAPI::RegTensor<T> input2SignValue;
    AscendC::MicroAPI::RegTensor<T> resValue;

    AscendC::MicroAPI::MaskReg preg;
    AscendC::MicroAPI::MaskReg cmpValue;
    AscendC::MicroAPI::MaskReg negValue;
    AscendC::MicroAPI::MaskReg signNegValue;
    AscendC::MicroAPI::MaskReg resMaskValue;
    uint32_t sregMask = count;

    AscendC::MicroAPI::Duplicate(zeroValue, T(0));
    AscendC::MicroAPI::Duplicate(defaultValue, T(-1));
    AscendC::MicroAPI::Duplicate(signValue, FMOD_B32_SIGN);

    for (uint16_t j = 0; j < loopTimes; j++) {
        // handel -1
        preg = AscendC::MicroAPI::UpdateMask<T>(sregMask);
        AscendC::MicroAPI::DataCopy<T, AscendC::MicroAPI::LoadDist::DIST_NORM>(input2Value, input2Addr + vecLen * j);
        AscendC::MicroAPI::DataCopy<T, AscendC::MicroAPI::LoadDist::DIST_NORM>(divValue, divAddr + vecLen * j);
        AscendC::MicroAPI::Mul(mulValue, input2Value, divValue, preg);
        AscendC::MicroAPI::DataCopy<T, AscendC::MicroAPI::LoadDist::DIST_NORM>(input1Value, input1Addr + vecLen * j);
        AscendC::MicroAPI::Sub(subValue, input1Value, mulValue, preg);
        AscendC::MicroAPI::Compare<T, AscendC::CMPMODE::NE>(cmpValue, input2Value, zeroValue, preg);
        AscendC::MicroAPI::Select(modValue, subValue, defaultValue, cmpValue);

        // post handel
        AscendC::MicroAPI::Add(addValue, modValue, input2Value, preg);
        AscendC::MicroAPI::Compare<T, AscendC::CMPMODE::NE>(negValue, modValue, zeroValue, preg);
        AscendC::MicroAPI::And(input2SignValue, input2Value, signValue, preg);
        AscendC::MicroAPI::And(modSignValue, modValue, signValue, preg);
        AscendC::MicroAPI::Compare<T, AscendC::CMPMODE::NE>(signNegValue, modSignValue, input2SignValue, preg);
        AscendC::MicroAPI::MaskAnd(resMaskValue, signNegValue, negValue, preg);
        AscendC::MicroAPI::Select(resValue, addValue, modValue, resMaskValue);
        AscendC::MicroAPI::DataCopy<T, AscendC::MicroAPI::StoreDist::DIST_NORM>(dstAddr + vecLen * j, resValue, preg);
    }
}

template <typename T>
__simt_vf__ inline void floor_mod_simt(
    __ubuf__ T* self,
    __ubuf__ T* other,
    __ubuf__ T* out,
    uint32_t input_total_length)
{
    uint32_t index = threadIdx.x;
    auto rem = self[index] % other[index];
    bool signs_differ = ((rem < 0) != (other[index] < 0));
    if (signs_differ && (rem != 0)) {
        out[index] = rem + other[index];
    } else {
        out[index] = rem;
    }
}

template <typename T>
class Kernel {
public:
    __aicore__ inline void Init(GM_ADDR self, GM_ADDR other, GM_ADDR out, AscendC::TPipe* pipeIn, uint32_t total_count)
    {
        this->pipe = pipeIn;
        this->selfGm.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(self) + AscendC::GetBlockIdx() * DATA_LEN_PER_CORE);
        this->otherGm.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(other) + AscendC::GetBlockIdx() * DATA_LEN_PER_CORE);
        this->outGm.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(out) + AscendC::GetBlockIdx() * DATA_LEN_PER_CORE);
        this->pipe->InitBuffer(inQueueSelf, 1, sizeof(T) * count_per_block);
        this->pipe->InitBuffer(inQueueOther, 1, sizeof(T) * count_per_block);
        this->pipe->InitBuffer(outQueue, 1, sizeof(T) * count_per_block);
    }

    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<T> selfLocal = inQueueSelf.AllocTensor<T>();
        AscendC::DataCopy(selfLocal, selfGm, count_per_block);
        inQueueSelf.EnQue<T>(selfLocal);
        AscendC::LocalTensor<T> otherLocal = inQueueOther.AllocTensor<T>();
        AscendC::DataCopy(otherLocal, otherGm, count_per_block);
        inQueueOther.EnQue<T>(otherLocal);
        AscendC::SetFlag<AscendC::HardEvent::MTE2_V>(0);
        AscendC::WaitFlag<AscendC::HardEvent::MTE2_V>(0);
    }

    __aicore__ inline void Compute()
    {
        AscendC::LocalTensor<T> selfLocal = inQueueSelf.DeQue<T>();
        AscendC::LocalTensor<T> otherLocal = inQueueOther.DeQue<T>();
        AscendC::LocalTensor<T> outLocal = outQueue.AllocTensor<T>();

        if constexpr (std::is_same_v<T, int32_t>) { // simt vf call
            __ubuf__ T* selfAddr = (__ubuf__ T*)selfLocal.GetPhyAddr();
            __ubuf__ T* otherAddr = (__ubuf__ T*)otherLocal.GetPhyAddr();
            __ubuf__ T* dstAddr = (__ubuf__ T*)outLocal.GetPhyAddr();
            asc_vf_call<floor_mod_simt<T>>(dim3(THREAD_COUNT), selfAddr, otherAddr, dstAddr, count_per_block);
        } else if constexpr (std::is_same_v<T, float>){ // simd 执行
            static constexpr uint32_t ITERATION_NUM = 11;
            AscendC::LocalMemAllocator<AscendC::Hardware::UB> ub_allocator;
            AscendC::LocalTensor<float> fmodRes = ub_allocator.Alloc<float>(count_per_block);
            static constexpr AscendC::FmodConfig config = {AscendC::FmodAlgo::ITERATION_COMPENSATION, ITERATION_NUM};
            AscendC::Fmod<T, false, config>(fmodRes, selfLocal, otherLocal);
            __ubuf__ T* otherAddr = (__ubuf__ T*)otherLocal.GetPhyAddr();
            __ubuf__ T* dstAddr = (__ubuf__ T*)outLocal.GetPhyAddr();
            __ubuf__ T* fmodResAddr = (__ubuf__ T*)fmodRes.GetPhyAddr();
            asc_vf_call<floor_mod_float_simd<T>>(fmodResAddr, otherAddr, dstAddr, count_per_block);
        }
        outQueue.EnQue<T>(outLocal);
    }

    __aicore__ inline void CopyOut()
    {
        AscendC::SetFlag<AscendC::HardEvent::V_MTE3>(0);
        AscendC::WaitFlag<AscendC::HardEvent::V_MTE3>(0);
        AscendC::LocalTensor<T> outLocal = outQueue.DeQue<T>();
        AscendC::DataCopy(outGm, outLocal, count_per_block);
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        Compute();
        CopyOut();
    }

private:
    AscendC::TPipe* pipe = nullptr;
    uint32_t count_per_block = DATA_LEN_PER_CORE;
    AscendC::GlobalTensor<T> selfGm;
    AscendC::GlobalTensor<T> otherGm;
    AscendC::GlobalTensor<T> outGm;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueSelf;
    AscendC::TQue<AscendC::TPosition::VECOUT, 1> inQueueOther;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> outQueue;
};

template <typename T>
__global__ __vector__ void floor_mod(GM_ADDR self, GM_ADDR other, GM_ADDR output, uint32_t total_count)
{
    AscendC::TPipe pipe;
    Kernel<T> kernel;
    kernel.Init(self, other, output, &pipe, total_count);
    kernel.Process();
}

template <typename T>
std::vector<T> floor_mod_host(std::vector<T>& self, std::vector<T>& other)
{
    constexpr uint32_t dynUBufSize = DATA_LEN_PER_CORE * sizeof(T) * 3; // 3: total input output number

    uint32_t input_total_length = self.size();
    size_t input_total_byte_size = input_total_length * sizeof(T);

    uint32_t numBlocks = (input_total_length + DATA_LEN_PER_CORE - 1) / DATA_LEN_PER_CORE;

    int32_t device_id = 0;
    aclrtStream stream = nullptr;

    uint8_t* input_host = reinterpret_cast<uint8_t *>(self.data());
    uint8_t* index_host = reinterpret_cast<uint8_t *>(other.data());
    uint8_t* output_host = nullptr;
    uint8_t* input_device = nullptr;
    uint8_t* index_device = nullptr;
    uint8_t* output_device = nullptr;

    aclInit(nullptr);
    aclrtSetDevice(device_id);
    aclrtCreateStream(&stream);

    aclrtMallocHost((void **)(&output_host), input_total_byte_size);
    aclrtMalloc((void **)&input_device, input_total_byte_size, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&index_device, input_total_byte_size, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void **)&output_device, input_total_byte_size, ACL_MEM_MALLOC_HUGE_FIRST);

    aclrtMemcpy(input_device, input_total_byte_size, input_host, input_total_byte_size, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(index_device, input_total_byte_size, index_host, input_total_byte_size, ACL_MEMCPY_HOST_TO_DEVICE);

    // launch kernel with <<<>>>, dynUBufSize is UB byte size we will allocate in kernel.
    floor_mod<T><<<numBlocks, dynUBufSize, stream>>>(input_device, index_device, output_device, input_total_length);
    aclrtSynchronizeStream(stream);

    aclrtMemcpy(output_host, input_total_byte_size, output_device, input_total_byte_size, ACL_MEMCPY_DEVICE_TO_HOST);
    std::vector<T> output((T *)output_host, ((T *)output_host + input_total_length));
    std::cout<< "input_total_length: " << input_total_length<< "  output.size:"<< output.size()<<std::endl;
    aclrtFree(input_device);
    aclrtFree(index_device);
    aclrtFree(output_device);
    aclrtFreeHost(output_host);

    aclrtDestroyStream(stream);
    aclrtResetDevice(device_id);
    aclFinalize();

    return output;
}

template <typename T>
uint32_t verify_result(std::vector<T>& output, std::vector<T>& golden)
{
    auto print_tensor = [](std::vector<T>& tensor, const char* name) {
        constexpr size_t max_print_size = 20;
        std::cout << name << ": ";
        std::copy(tensor.begin(), tensor.begin() + std::min(tensor.size(), max_print_size),
            std::ostream_iterator<T>(std::cout, " "));
        if (tensor.size() > max_print_size) {
            std::cout << "...";
        }
        std::cout << std::endl;
    };
    print_tensor(output, "Output");
    print_tensor(golden, "Golden");
    std::cout << "output size: " << output.size()<< std::endl;
    std::cout << "golden size: " << golden.size()<< std::endl;
    if (std::equal(output.begin(), output.end(), golden.begin())) {
        std::cout << "[Success] Case accuracy is verification passed." << std::endl;
        return 0;
    } else {
        std::cout << "[Failed] Case accuracy is verification failed!" << std::endl;
        return 1;
    }
    return 0;
}


float random_float(float min, float max)
{
    static std::mt19937 engine(std::chrono::system_clock::now().time_since_epoch().count());
    std::uniform_real_distribution<float> dist(min, max);
    return dist(engine);
}

int32_t random_int(int32_t min, int32_t max)
{
    static std::mt19937 engine(std::chrono::system_clock::now().time_since_epoch().count());
    std::uniform_int_distribution<int32_t> dist(min, max);
    return dist(engine);
}

uint32_t random_int32(uint32_t min, uint32_t max)
{
    static std::mt19937 engine(std::chrono::system_clock::now().time_since_epoch().count());
    std::uniform_int_distribution<uint32_t> dist(min, max);
    return dist(engine);
}

int32_t process_float()
{
    constexpr uint32_t input_total_length = 6400;
    std::vector<float> self(input_total_length);
    for (uint32_t i = 0; i < input_total_length; i++) {
        self[i] = random_float(0.0f, 100.0f);
    }

    std::vector<float> other(input_total_length);
    for (uint32_t i = 0; i < input_total_length; i++) {
        other[i] = random_float(0.0f, 100.0f);
    }

    std::vector<float> golden(input_total_length);
    for (uint32_t i = 0; i < input_total_length; i++) {
        auto rem = fmod(self[i], other[i]);
        bool signs_differ = ((rem < 0) != (other[i] < 0));
        if (signs_differ && (std::abs(rem) >0.000001f)) {
            golden[i] = rem + other[i];
        } else {
            golden[i] = rem;
        }
    }

    std::vector<float> output = floor_mod_host(self, other);

    return verify_result(output, golden);
}


int32_t process_int()
{
    constexpr uint32_t input_total_length = 6400;
    std::vector<int32_t> self(input_total_length);
    for (uint32_t i = 0; i < input_total_length; i++) {
        self[i] = i + 2;
    }

    std::vector<int32_t> other(input_total_length);
    for (uint32_t i = 0; i < input_total_length; i++) {
        other[i] = 3;
    }

    std::vector<int32_t> golden(input_total_length);
    for (uint32_t i = 0; i < input_total_length; i++) {
        auto rem = self[i] % other[i];
        bool signs_differ = ((rem < 0) != (other[i] < 0));
        if (signs_differ && (rem != 0)) {
            golden[i] = rem + other[i];
        } else {
            golden[i] = rem;
        }
    }

    std::vector<int32_t> output = floor_mod_host(self, other);
    return verify_result(output, golden);
}

int32_t main()
{
    // process_float:  test float function
    // process_int:  test int32_t function
    return process_int();
}