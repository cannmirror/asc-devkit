/**
* Copyright (c) 2025 Huawei Technologies Co., Ltd.
* This program is free software, you can redistribute it and/or modify it under the terms and conditions of
* CANN Open Software License Agreement Version 2.0 (the "License").
* Please refer to the License for details. You may not use this file except in compliance with the License.
* THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED,
* INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
* See LICENSE in the root of the software repository for the full text of the License.
*/

#include "acl/acl.h"
#include "kernel_operator.h"
#include "data_utils.h"

enum class CubeFormat { ND = 0, NZ, ZN, ZZ, NN, ND_ALIGN, SCALAR, VECTOR };

template <AscendC::TPosition POSITION, CubeFormat FORMAT, typename TYPE>
struct InputInfo {
    constexpr static AscendC::TPosition pos = POSITION;
    constexpr static CubeFormat format = FORMAT;
    using T = TYPE;
};

constexpr int32_t NZ_MASK_VALUE = 2;
int32_t constexpr GetNdNzMask(CubeFormat dstFormat, CubeFormat srcFormat)
{
    if ((srcFormat == CubeFormat::ND) && (dstFormat == CubeFormat::NZ)) {
        return 1;
    } else if ((srcFormat == CubeFormat::NZ) && (dstFormat == CubeFormat::ND)) {
        return NZ_MASK_VALUE;
    }
    return 0;
}

template <class A_TYPE, class B_TYPE, class C_TYPE, class L0C_TYPE>
class E2eCase {
    using T = typename A_TYPE::T;
    using U = typename B_TYPE::T;
    using S = typename C_TYPE::T;
    using V = typename L0C_TYPE::T;

public:
    __aicore__ inline E2eCase() {}
    __aicore__ inline void Init(AscendC::TPipe* tpipe, int32_t m, int32_t n, int32_t k)
    {
        pipe = tpipe;
        mLength = m;
        nLength = n;
        kLength = k;
        pipe->InitBuffer(qidA1_, 1, m * k * sizeof(T));
        pipe->InitBuffer(qidB1_, 1, n * k * sizeof(U));
        pipe->InitBuffer(qidA2_, 1, m * k * sizeof(T));
        pipe->InitBuffer(qidB2_, 1, n * k * sizeof(U));
        pipe->InitBuffer(qidCO1_, 1, m * n * sizeof(V));
    }

    __aicore__ inline void SetTensorA(const AscendC::GlobalTensor<T>& gm)
    {
        aGlobal_ = gm;
    }

    __aicore__ inline void SetTensorB(const AscendC::GlobalTensor<U>& gm)
    {
        bGlobal_ = gm;
    }

    __aicore__ inline void CopyGmToA1Nd2Nz()
    {
        AscendC::LocalTensor<T> leftMatrix = qidA1_.template AllocTensor<T>();
        AscendC::Nd2NzParams nd2nzParams;
        nd2nzParams.ndNum = 1;
        nd2nzParams.nValue = mLength;
        nd2nzParams.dValue = kLength;
        nd2nzParams.srcNdMatrixStride = 0;
        nd2nzParams.srcDValue = kLength;
        nd2nzParams.dstNzC0Stride = mLength;
        nd2nzParams.dstNzNStride = 1;
        nd2nzParams.dstNzMatrixStride = 0;
        AscendC::DataCopy(leftMatrix, aGlobal_, nd2nzParams);
        qidA1_.EnQue(leftMatrix);
    }

    __aicore__ inline void CopyGmToB1Nd2Nz()
    {
        AscendC::LocalTensor<U> rightMatrix = qidB1_.template AllocTensor<U>();
        AscendC::Nd2NzParams nd2nzParams;
        nd2nzParams.ndNum = 1;
        nd2nzParams.nValue = kLength;
        nd2nzParams.dValue = nLength;
        nd2nzParams.srcNdMatrixStride = 0;
        nd2nzParams.srcDValue = nLength;
        nd2nzParams.dstNzC0Stride = kLength;
        nd2nzParams.dstNzNStride = 1;
        nd2nzParams.dstNzMatrixStride = 0;
        AscendC::DataCopy(rightMatrix, bGlobal_, nd2nzParams);
        qidB1_.EnQue(rightMatrix);
    }

    __aicore__ inline void CopyGmToA1()
    {
        AscendC::LocalTensor<T> leftMatrix = qidA1_.template AllocTensor<T>();
        AscendC::DataCopy(leftMatrix, aGlobal_, mLength * kLength);
        qidA1_.EnQue(leftMatrix);
    }

    __aicore__ inline void CopyGmToB1()
    {
        AscendC::LocalTensor<U> rightMatrix = qidB1_.template AllocTensor<U>();
        AscendC::DataCopy(rightMatrix, bGlobal_, kLength * nLength);
        qidB1_.EnQue(rightMatrix);
    }

    __aicore__ inline void Compute()
    {
        AscendC::MmadParams mmadParams;
        mmadParams.m = mLength;
        mmadParams.n = nLength;
        mmadParams.k = kLength;
        mmadParams.isBias = enBias;
        auto co1Local = qidCO1_.AllocTensor<V>();
        auto a2 = qidA2_.DeQue<T>();
        auto b2 = qidB2_.DeQue<U>();
        AscendC::Mmad(co1Local, a2, b2, mmadParams);
        qidA2_.FreeTensor(a2);
        qidB2_.FreeTensor(b2);
        qidCO1_.EnQue(co1Local);
    }

    __aicore__ inline void Load3DA1ToL0A()
    {
        auto leftMatrix = qidA1_.template DeQue<T>();
        AscendC::LocalTensor<T> a2 = qidA2_.AllocTensor<T>();
        uint16_t dstStride = AscendC::DivCeil(mLength, 16);
        AscendC::LoadData3DParamsV2Pro loadData3dParamsPro;
        loadData3dParamsPro.channelSize = kLength;
        loadData3dParamsPro.enTranspose = false;
        loadData3dParamsPro.enSmallK = false;
        loadData3dParamsPro.filterSizeW = false;
        loadData3dParamsPro.filterSizeH = false;
        loadData3dParamsPro.fMatrixCtrl = false;
        loadData3dParamsPro.extConfig =
            ((uint64_t)0 << 48) | ((uint64_t)0 << 32) | ((uint64_t)mLength << 16) | (uint64_t)(kLength);
        const uint8_t padList[4] = {0, 0, 0, 0};
        AscendC::SetFmatrix(mLength, 1, padList, AscendC::FmatrixMode::FMATRIX_LEFT);
        AscendC::SetLoadDataRepeat({0, 1, 0});
        // 单位字节
        AscendC::SetLoadDataBoundary(1024);
        AscendC::LoadData(a2, leftMatrix, loadData3dParamsPro);
        qidA2_.EnQue(a2);
        qidA1_.FreeTensor(leftMatrix);
    }

    __aicore__ inline void Load3DB1ToL0B()
    {
        auto rightMatrix = qidB1_.template DeQue<U>();
        AscendC::LocalTensor<U> b2 = qidB2_.AllocTensor<U>();
        AscendC::LoadData3DParamsV2<U> loadData3dParams;
        loadData3dParams.l1W = 1;
        loadData3dParams.l1H = kLength;
        loadData3dParams.channelSize = nLength;
        loadData3dParams.kExtension = nLength;
        loadData3dParams.mExtension = kLength;
        loadData3dParams.kStartPt = 0;
        loadData3dParams.mStartPt = 0;
        loadData3dParams.strideW = 1;
        loadData3dParams.strideH = 1;
        loadData3dParams.filterW = 1;
        loadData3dParams.filterH = 1;
        loadData3dParams.dilationFilterW = 1;
        loadData3dParams.dilationFilterH = 1;
        loadData3dParams.enTranspose = true;
        loadData3dParams.enSmallK = false;
        loadData3dParams.padValue = 0;
        loadData3dParams.filterSizeW = 0;
        loadData3dParams.filterSizeH = 0;
        loadData3dParams.fMatrixCtrl = false;
        uint8_t padList[AscendC::PAD_SIZE] = {0, 0, 0, 0};
        uint16_t dstStride = AscendC::DivCeil(nLength, 16);
        AscendC::SetFmatrix(nLength, 1, padList, AscendC::FmatrixMode::FMATRIX_LEFT);
        AscendC::SetLoadDataRepeat({0, 1, 0});
        AscendC::SetLoadDataBoundary(0);
        AscendC::SetLoadDataPaddingValue(0);
        static constexpr AscendC::IsResetLoad3dConfig LOAD3D_CONFIG = {false, false};
        AscendC::LoadData<U, LOAD3D_CONFIG>(b2, rightMatrix, loadData3dParams);
        qidB2_.EnQue(b2);
        qidB1_.FreeTensor(rightMatrix);
    }

    __aicore__ inline void CopyL0CToGm(const AscendC::GlobalTensor<S>& gm)
    {
        auto co1Local = qidCO1_.DeQue<V>();
        AscendC::FixpipeParamsV220 fixpipeParams(nLength, static_cast<uint16_t>(mLength),
                                        AscendC::DivCeil(mLength, AscendC::BLOCK_CUBE) * AscendC::BLOCK_CUBE, static_cast<uint16_t>(nLength), 0);
        fixpipeParams.ndNum = 1;
        fixpipeParams.srcNdStride = 0;
        fixpipeParams.dstNdStride = 0;
        if (AscendC::IsSameType<S, half>::value) {
            fixpipeParams.quantPre = QuantMode_t::F322F16;
        } else if (AscendC::IsSameType<S, bfloat16_t>::value) {
            fixpipeParams.quantPre = QuantMode_t::F322BF16;
        }
        AscendC::Fixpipe<S, V, AscendC::CFG_ROW_MAJOR>(gm, co1Local, fixpipeParams);
        qidCO1_.FreeTensor(co1Local);
    }

    __aicore__ inline void IterateAll(const AscendC::GlobalTensor<S>& gm)
    {
        CopyGmToA1Nd2Nz();
        CopyGmToB1Nd2Nz();
        Load3DA1ToL0A();
        Load3DB1ToL0B();
        Compute();
        CopyL0CToGm(gm);
    }

private:
    AscendC::TPipe* pipe = nullptr;
    int32_t mLength = 0;
    int32_t nLength = 0;
    int32_t kLength = 0;
    int32_t enBias = 0;
    AscendC::TQue<AscendC::TPosition::A1, 1, GetNdNzMask(CubeFormat::NZ, A_TYPE::format)> qidA1_;
    AscendC::TQue<AscendC::TPosition::B1, 1, GetNdNzMask(CubeFormat::NZ, B_TYPE::format)> qidB1_;
    AscendC::TQue<AscendC::TPosition::A2, 1> qidA2_;
    AscendC::TQue<AscendC::TPosition::B2, 1> qidB2_;
    AscendC::TQue<AscendC::TPosition::CO1, 1> qidCO1_;
    AscendC::TQue<AscendC::TPosition::C1, 1> inQueueC1;
    AscendC::TQue<AscendC::TPosition::C2, 1> outQueueC2;
    AscendC::LocalTensor<T> leftMatrix_;
    AscendC::LocalTensor<U> rightMatrix_;
    AscendC::GlobalTensor<T> aGlobal_;
    AscendC::GlobalTensor<U> bGlobal_;
};

template <class A_TYPE, class B_TYPE, class L0CType, class C_TYPE, class BIAS_TYPE, bool HAS_BIAS>
__aicore__ inline void E2eKernel(GM_ADDR aGM, GM_ADDR bGM, GM_ADDR cGM, int32_t m, int32_t n, int32_t k,
                                 int32_t usedCoreNum, int hasBias)
{
    if ASCEND_IS_AIV {
        return;
    }
    using T = typename A_TYPE::T;
    using U = typename B_TYPE::T;
    using S = typename L0CType::T;
    using V = typename C_TYPE::T;
    if (block_idx >= usedCoreNum) {
        return;
    }
    AscendC::GlobalTensor<T> aGlobal;
    AscendC::GlobalTensor<U> bGlobal;
    AscendC::GlobalTensor<V> cGlobal;
    aGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ T*>(aGM), m * k);
    bGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ U*>(bGM), k * n);
    cGlobal.SetGlobalBuffer(reinterpret_cast<__gm__ V*>(cGM), m * n);
    int offsetA = 0;
    int offsetB = 0;
    int offsetC = 0;
    int offsetBias = 0;
    auto gmA = aGlobal[offsetA];
    auto gmB = bGlobal[offsetB];
    auto gmC = cGlobal[offsetC];
    AscendC::TPipe que;
    E2eCase<A_TYPE, B_TYPE, L0CType, C_TYPE> ins;
    ins.Init(&que, m, n, k);
    ins.SetTensorA(gmA);
    ins.SetTensorB(gmB);
    ins.IterateAll(gmC);
}

__global__ __aicore__ void demo(GM_ADDR aGM, GM_ADDR bGM, GM_ADDR cGM, int32_t m, int32_t n, int32_t k)
{
    KERNEL_TASK_TYPE_DEFAULT(KERNEL_TYPE_AIC_ONLY);
    typedef InputInfo<AscendC::TPosition::GM, CubeFormat::ND, half> aType;
    typedef InputInfo<AscendC::TPosition::GM, CubeFormat::ND, half> bType;
    typedef InputInfo<AscendC::TPosition::CO1, CubeFormat::ND, float> l0cType;
    typedef InputInfo<AscendC::TPosition::GM, CubeFormat::ND, float> cType;
    typedef InputInfo<AscendC::TPosition::GM, CubeFormat::ND, float> biasType;
    E2eKernel<aType, bType, l0cType, cType, biasType, 0>(aGM, bGM, cGM, m, n, k, 1, 0);
}

int32_t main(int32_t argc, char* argv[])
{
    uint32_t blockDim = 1;

    aclInit(nullptr);
    int32_t deviceId = 0;
    aclrtSetDevice(deviceId);
    aclrtStream stream = nullptr;
    aclrtCreateStream(&stream);

    int32_t m = 32, n = 32, k = 32;
    size_t aInputByteSize = static_cast<size_t>(1) * m * k * sizeof(half);
    size_t bInputByteSize = static_cast<size_t>(1) * k * n * sizeof(half);
    size_t outputByteSize = static_cast<size_t>(1) * m * n * sizeof(float);

    uint8_t *xHost, *yHost, *zHost;
    uint8_t *xDevice, *yDevice, *zDevice;

    aclrtMallocHost((void**)(&xHost), aInputByteSize);
    aclrtMallocHost((void**)(&yHost), bInputByteSize);
    aclrtMallocHost((void**)(&zHost), outputByteSize);
    aclrtMalloc((void**)&xDevice, aInputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&yDevice, bInputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);
    aclrtMalloc((void**)&zDevice, outputByteSize, ACL_MEM_MALLOC_HUGE_FIRST);

    ReadFile("./input/input_x.bin", aInputByteSize, xHost, aInputByteSize);
    ReadFile("./input/input_y.bin", bInputByteSize, yHost, bInputByteSize);

    aclrtMemcpy(xDevice, aInputByteSize, xHost, aInputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);
    aclrtMemcpy(yDevice, bInputByteSize, yHost, bInputByteSize, ACL_MEMCPY_HOST_TO_DEVICE);

    demo<<<blockDim, nullptr, stream>>>(xDevice, yDevice, zDevice, m, n, k);
    aclrtSynchronizeStream(stream);

    aclrtMemcpy(zHost, outputByteSize, zDevice, outputByteSize, ACL_MEMCPY_DEVICE_TO_HOST);
    WriteFile("./output/output.bin", zHost, outputByteSize);

    aclrtFree(xDevice);
    aclrtFree(yDevice);
    aclrtFree(zDevice);
    aclrtFreeHost(xHost);
    aclrtFreeHost(yHost);
    aclrtFreeHost(zHost);

    aclrtDestroyStream(stream);
    aclrtResetDevice(deviceId);
    aclFinalize();

    return 0;
}