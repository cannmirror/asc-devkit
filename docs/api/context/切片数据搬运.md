# 切片数据搬运<a name="ZH-CN_TOPIC_0000002349027556"></a>

## AI处理器支持情况<a name="section1550532418810"></a>

<a name="table38301303189"></a>
<table><thead align="left"><tr id="row20831180131817"><th class="cellrowborder" valign="top" width="57.99999999999999%" id="mcps1.1.3.1.1"><p id="p1883113061818"><a name="p1883113061818"></a><a name="p1883113061818"></a><span id="ph20833205312295"><a name="ph20833205312295"></a><a name="ph20833205312295"></a>AI处理器类型</span></p>
</th>
<th class="cellrowborder" align="center" valign="top" width="42%" id="mcps1.1.3.1.2"><p id="p783113012187"><a name="p783113012187"></a><a name="p783113012187"></a>是否支持</p>
</th>
</tr>
</thead>
<tbody><tr id="row220181016240"><td class="cellrowborder" valign="top" width="57.99999999999999%" headers="mcps1.1.3.1.1 "><p id="p48327011813"><a name="p48327011813"></a><a name="p48327011813"></a><span id="ph583230201815"><a name="ph583230201815"></a><a name="ph583230201815"></a><term id="zh-cn_topic_0000001312391781_term1253731311225"><a name="zh-cn_topic_0000001312391781_term1253731311225"></a><a name="zh-cn_topic_0000001312391781_term1253731311225"></a>Ascend 910C</term></span></p>
</td>
<td class="cellrowborder" align="center" valign="top" width="42%" headers="mcps1.1.3.1.2 "><p id="p7948163910184"><a name="p7948163910184"></a><a name="p7948163910184"></a>√</p>
</td>
</tr>
<tr id="row173226882415"><td class="cellrowborder" valign="top" width="57.99999999999999%" headers="mcps1.1.3.1.1 "><p id="p14832120181815"><a name="p14832120181815"></a><a name="p14832120181815"></a><span id="ph1483216010188"><a name="ph1483216010188"></a><a name="ph1483216010188"></a><term id="zh-cn_topic_0000001312391781_term11962195213215"><a name="zh-cn_topic_0000001312391781_term11962195213215"></a><a name="zh-cn_topic_0000001312391781_term11962195213215"></a>Ascend 910B</term></span></p>
</td>
<td class="cellrowborder" align="center" valign="top" width="42%" headers="mcps1.1.3.1.2 "><p id="p19948143911820"><a name="p19948143911820"></a><a name="p19948143911820"></a>√</p>
</td>
</tr>
</tbody>
</table>

## 功能说明<a name="section474617392321"></a>

支持数据的切片搬运，提取多维Tensor数据的子集进行搬运。

## 函数原型<a name="section1954364615315"></a>

-   Global Memory -\> Local Memory

    ```
    template <typename T>
    __aicore__ inline void DataCopy(const LocalTensor<T>& dst, const GlobalTensor<T>& src, const SliceInfo dstSliceInfo[], const SliceInfo srcSliceInfo[], const uint32_t dimValue = 1)
    ```

-   Local Memory -\> Global Memory

    ```
    template <typename T>
    __aicore__ inline void DataCopy(const GlobalTensor<T> &dst, const LocalTensor<T> &src, const SliceInfo dstSliceInfo[], const SliceInfo srcSliceInfo[], const uint32_t dimValue = 1)
    ```

>![](public_sys-resources/icon-note.gif) **说明：** 
>各原型支持的具体数据通路和数据类型，请参考[支持的通路和数据类型](#section186352046151419)。

## 参数说明<a name="section19248104211347"></a>

**表 1**  模板参数说明

<a name="table4835205712588"></a>
<table><thead align="left"><tr id="zh-cn_topic_0000001429830437_row118356578583"><th class="cellrowborder" valign="top" width="14.729999999999999%" id="mcps1.2.3.1.1"><p id="zh-cn_topic_0000001429830437_p48354572582"><a name="zh-cn_topic_0000001429830437_p48354572582"></a><a name="zh-cn_topic_0000001429830437_p48354572582"></a>参数名</p>
</th>
<th class="cellrowborder" valign="top" width="85.27%" id="mcps1.2.3.1.2"><p id="zh-cn_topic_0000001429830437_p583535795817"><a name="zh-cn_topic_0000001429830437_p583535795817"></a><a name="zh-cn_topic_0000001429830437_p583535795817"></a>描述</p>
</th>
</tr>
</thead>
<tbody><tr id="zh-cn_topic_0000001429830437_row1835857145817"><td class="cellrowborder" valign="top" width="14.729999999999999%" headers="mcps1.2.3.1.1 "><p id="zh-cn_topic_0000001429830437_p5835457165816"><a name="zh-cn_topic_0000001429830437_p5835457165816"></a><a name="zh-cn_topic_0000001429830437_p5835457165816"></a>T</p>
</td>
<td class="cellrowborder" valign="top" width="85.27%" headers="mcps1.2.3.1.2 "><p id="zh-cn_topic_0000001429830437_p168351657155818"><a name="zh-cn_topic_0000001429830437_p168351657155818"></a><a name="zh-cn_topic_0000001429830437_p168351657155818"></a>源操作数和目的操作数的数据类型。支持的数据类型请参考<a href="#section186352046151419">支持的通路和数据类型</a>。</p>
</td>
</tr>
</tbody>
</table>

**表 2**  切片数据搬运接口参数说明

<a name="table6814164910156"></a>
<table><thead align="left"><tr id="row16814184910153"><th class="cellrowborder" valign="top" width="15.02%" id="mcps1.2.4.1.1"><p id="p108141649191519"><a name="p108141649191519"></a><a name="p108141649191519"></a>参数名称</p>
</th>
<th class="cellrowborder" valign="top" width="10%" id="mcps1.2.4.1.2"><p id="p1981464919158"><a name="p1981464919158"></a><a name="p1981464919158"></a>输入/输出</p>
</th>
<th class="cellrowborder" valign="top" width="74.98%" id="mcps1.2.4.1.3"><p id="p281411496157"><a name="p281411496157"></a><a name="p281411496157"></a>含义</p>
</th>
</tr>
</thead>
<tbody><tr id="row2081444915158"><td class="cellrowborder" valign="top" width="15.02%" headers="mcps1.2.4.1.1 "><p id="p14814204941519"><a name="p14814204941519"></a><a name="p14814204941519"></a>dst</p>
</td>
<td class="cellrowborder" valign="top" width="10%" headers="mcps1.2.4.1.2 "><p id="p1181417494157"><a name="p1181417494157"></a><a name="p1181417494157"></a>输出</p>
</td>
<td class="cellrowborder" valign="top" width="74.98%" headers="mcps1.2.4.1.3 "><p id="p5814149181517"><a name="p5814149181517"></a><a name="p5814149181517"></a>目的操作数，类型为LocalTensor或GlobalTensor。</p>
</td>
</tr>
<tr id="row11814549161519"><td class="cellrowborder" valign="top" width="15.02%" headers="mcps1.2.4.1.1 "><p id="p19814184911519"><a name="p19814184911519"></a><a name="p19814184911519"></a>src</p>
</td>
<td class="cellrowborder" valign="top" width="10%" headers="mcps1.2.4.1.2 "><p id="p2815114911152"><a name="p2815114911152"></a><a name="p2815114911152"></a>输入</p>
</td>
<td class="cellrowborder" valign="top" width="74.98%" headers="mcps1.2.4.1.3 "><p id="p8815114971510"><a name="p8815114971510"></a><a name="p8815114971510"></a>源操作数，类型为LocalTensor或GlobalTensor。</p>
</td>
</tr>
<tr id="row19815194911156"><td class="cellrowborder" valign="top" width="15.02%" headers="mcps1.2.4.1.1 "><p id="p108159496151"><a name="p108159496151"></a><a name="p108159496151"></a>srcSliceInfo/dstSliceInfo</p>
</td>
<td class="cellrowborder" valign="top" width="10%" headers="mcps1.2.4.1.2 "><p id="p18815849191517"><a name="p18815849191517"></a><a name="p18815849191517"></a>输入</p>
</td>
<td class="cellrowborder" valign="top" width="74.98%" headers="mcps1.2.4.1.3 "><p id="p6354242155319"><a name="p6354242155319"></a><a name="p6354242155319"></a>目的操作数/源操作数切片信息，<a href="#table1388517394167">SliceInfo</a>类型。</p>
<p id="p115152440530"><a name="p115152440530"></a><a name="p115152440530"></a>具体定义请参考<span id="ph10562197165916"><a name="ph10562197165916"></a><a name="ph10562197165916"></a>${INSTALL_DIR}</span>/include/ascendc/basic_api/interface/kernel_struct_data_copy.h，<span id="ph14322531015"><a name="ph14322531015"></a><a name="ph14322531015"></a>${INSTALL_DIR}</span>请替换为CANN软件安装后文件存储路径。</p>
</td>
</tr>
<tr id="row15111165921619"><td class="cellrowborder" valign="top" width="15.02%" headers="mcps1.2.4.1.1 "><p id="p18112759151615"><a name="p18112759151615"></a><a name="p18112759151615"></a>dimValue</p>
</td>
<td class="cellrowborder" valign="top" width="10%" headers="mcps1.2.4.1.2 "><p id="p1112105918167"><a name="p1112105918167"></a><a name="p1112105918167"></a>输入</p>
</td>
<td class="cellrowborder" valign="top" width="74.98%" headers="mcps1.2.4.1.3 "><p id="p7112125913161"><a name="p7112125913161"></a><a name="p7112125913161"></a>操作数维度信息，默认值为1。</p>
</td>
</tr>
</tbody>
</table>

**表 3**  SliceInfo结构参数说明

<a name="table1388517394167"></a>
<table><thead align="left"><tr id="row38851239111611"><th class="cellrowborder" valign="top" width="14.52%" id="mcps1.2.3.1.1"><p id="p088583917164"><a name="p088583917164"></a><a name="p088583917164"></a>参数名称</p>
</th>
<th class="cellrowborder" valign="top" width="85.48%" id="mcps1.2.3.1.2"><p id="p988523971620"><a name="p988523971620"></a><a name="p988523971620"></a>含义</p>
</th>
</tr>
</thead>
<tbody><tr id="row1788543901616"><td class="cellrowborder" valign="top" width="14.52%" headers="mcps1.2.3.1.1 "><p id="p42771239121712"><a name="p42771239121712"></a><a name="p42771239121712"></a>startIndex</p>
</td>
<td class="cellrowborder" valign="top" width="85.48%" headers="mcps1.2.3.1.2 "><p id="p113258476173"><a name="p113258476173"></a><a name="p113258476173"></a>切片的起始元素位置。</p>
</td>
</tr>
<tr id="row1588511392162"><td class="cellrowborder" valign="top" width="14.52%" headers="mcps1.2.3.1.1 "><p id="p12778396171"><a name="p12778396171"></a><a name="p12778396171"></a>endIndex</p>
</td>
<td class="cellrowborder" valign="top" width="85.48%" headers="mcps1.2.3.1.2 "><p id="p1632634715178"><a name="p1632634715178"></a><a name="p1632634715178"></a>切片的终止元素位置。</p>
</td>
</tr>
<tr id="row688553918166"><td class="cellrowborder" valign="top" width="14.52%" headers="mcps1.2.3.1.1 "><p id="p6277143991716"><a name="p6277143991716"></a><a name="p6277143991716"></a>stride</p>
</td>
<td class="cellrowborder" valign="top" width="85.48%" headers="mcps1.2.3.1.2 "><p id="p432674771713"><a name="p432674771713"></a><a name="p432674771713"></a>切片的间隔元素个数。</p>
</td>
</tr>
<tr id="row288513921613"><td class="cellrowborder" valign="top" width="14.52%" headers="mcps1.2.3.1.1 "><p id="p17277123915179"><a name="p17277123915179"></a><a name="p17277123915179"></a>burstLen</p>
</td>
<td class="cellrowborder" valign="top" width="85.48%" headers="mcps1.2.3.1.2 "><p id="p1490419231327"><a name="p1490419231327"></a><a name="p1490419231327"></a>横向切片，每一片数据的长度，仅在维度为1时生效，超出1维的情况下，必须配置为1，不支持配置成其他值。单位为datablock（32B）。比如，srcSliceInfo的List为 {{16, 70, 7, 3, 87},  {0, 2, 1, 1, 3}}，{16, 70, 7, 3, 87}表示第一维的切片信息，burstLen设置为3，表示一个切片数据段大小为3个datablock； {0, 2, 1, 1, 3}为第二维的切片信息，burstLen仅能设置为1。</p>
</td>
</tr>
<tr id="row1826031743111"><td class="cellrowborder" valign="top" width="14.52%" headers="mcps1.2.3.1.1 "><p id="p72601617193111"><a name="p72601617193111"></a><a name="p72601617193111"></a>shapeValue</p>
</td>
<td class="cellrowborder" valign="top" width="85.48%" headers="mcps1.2.3.1.2 "><p id="p426051714315"><a name="p426051714315"></a><a name="p426051714315"></a>当前维度的原始长度。单位为元素个数。</p>
</td>
</tr>
</tbody>
</table>

通过具体的示例对上述参数进行解析，示意图如下：

**图 1**  参数解析示意图<a name="fig1196816115710"></a>  
![](figures/参数解析示意图.png "参数解析示意图")

-   dimValue为2，表示操作数有2维。
-   srcSliceInfo为 \{\{16, 70, 7, 3, 87\},  \{0, 2, 1, 1, 3\}\}
    -   \{16, 70, 7, 3, 87\}是针对单独一行， 即从一维的角度来配置，每个元素代表一个数：

        **startIndex**  = 16，表示有效数据段从第16个数开始；

        **endIndex**  = 70，表示有效数据段到第70个数结束；

        **stride**  = 7，单位为元素个数，表示相邻的2个切片数据段间隔的元素个数，为7个0的间距；

        **burstLen**  = 3，单位为32B，表示在这一个有效数据段中，一个切片数据段大小为3个datablock；

        **shapeValue**  = 87，表示单独一行的长度，单位为元素个数，即 8 \* 10 + 7 = 87个元素。

    -   \{0, 2, 1, 1, 3\}是针对多行，即从二维的角度来配置，每个元素代表一行：

        **startIndex**  = 0，表示有效数据段从第0行开始；

        **endIndex**  = 2，表示有效数据段到第2行结束；

        **stride**  = 1，表示相邻的2个切片数据段中间隔元素为1行；

        **burstLen**  = 1，在dimValue \> 1时必须填为1；

        **shapeValue**  = 3，表明一共有3行。

-   dstSliceInfo为\{\{0, 47, 0, 3, 48\}, \{0, 1, 0, 1, 2\}\}
    -   \{0, 47, 0, 3, 48\}是针对单独一行， 即从一维的角度来配置，每个元素代表一个数：

        **startIndex**  = 0，表示有效数据段从第0个数开始；

        **endIndex**  = 47，表示有效数据段到第47个数结束；

        **stride**  = 0，单位为元素个数，表示相邻的2个切片数据段间隔的元素个数，为0表示两个切片数据段没有间距；

        **burstLen**  = 3，单位为32B，表示在这一个有效数据段中，一个切片数据段大小为3个datablock；

        **shapeValue**  = 48，表示单独一行的长度，单位为元素个数，即8 \* 6 = 48个元素。

    -   \{0, 1, 0, 1, 2\} 是针对多行，即从二维的角度来配置，每个元素代表1行：

        **startIndex **= 0，表示有效数据段从第0行开始；

        **endIndex **= 1，表示有效数据段到第1行结束；

        **stride **= 0，表示相邻的2个切片数据段没有间隔；

        **burstLen**  = 1，在dimValue \> 1时必须填为1；

        **shapeValue **= 2，表示一共有2行。

## 返回值说明<a name="section148101742102720"></a>

无

## 约束说明<a name="section912264510410"></a>

-   切片数据搬运中的横向burstLen大小设置，需要用户自己通过计算：横向切片元素个数\* sizeof\(T\)/32byte。横向切片元素个数\* sizeof\(T\)的大小必须是32byte的倍数。
-   切片数据搬运中的SliceInfo结构体数组大小和dimValue需要保持一致，并且不超过8。
-   切片数据搬运中的srcSliceInfo数组大小的和dstSliceInfo的大小需要保持一致，两者的结构体中的burstLen需要相等（srcSliceInfo\[i\].burstLen = dstSliceInfo\[i\].burstLen）。
-   切片数据搬运对参数有一定要求，建议使用者参考调用示例，并在CPU上仿真结果无误后，再到NPU侧执行。

## 支持的通路和数据类型<a name="section186352046151419"></a>

下文的数据通路均通过逻辑位置[TPosition](TPosition.md#table5376122715308)来表达，并注明了对应的物理通路。TPosition与物理内存的映射关系见[表1](通用说明和约束.md#table07372185712)。

**表 4**  Global Memory -\> Local Memory具体通路和支持的数据类型

<a name="table14255161718545"></a>
<table><thead align="left"><tr id="row3255181710543"><th class="cellrowborder" valign="top" width="11.03%" id="mcps1.2.4.1.1"><p id="p52550177546"><a name="p52550177546"></a><a name="p52550177546"></a>产品型号</p>
</th>
<th class="cellrowborder" valign="top" width="23.97%" id="mcps1.2.4.1.2"><p id="p13255191735420"><a name="p13255191735420"></a><a name="p13255191735420"></a>数据通路</p>
</th>
<th class="cellrowborder" valign="top" width="65%" id="mcps1.2.4.1.3"><p id="p6255617175419"><a name="p6255617175419"></a><a name="p6255617175419"></a>源操作数和目的操作数的数据类型（两者保持一致）</p>
</th>
</tr>
</thead>
<tbody><tr id="row5426164114556"><td class="cellrowborder" valign="top" width="11.03%" headers="mcps1.2.4.1.1 "><p id="p44261641165518"><a name="p44261641165518"></a><a name="p44261641165518"></a><span id="ph14504143371016"><a name="ph14504143371016"></a><a name="ph14504143371016"></a><term id="zh-cn_topic_0000001312391781_term11962195213215_1"><a name="zh-cn_topic_0000001312391781_term11962195213215_1"></a><a name="zh-cn_topic_0000001312391781_term11962195213215_1"></a>Ascend 910B</term></span></p>
</td>
<td class="cellrowborder" valign="top" width="23.97%" headers="mcps1.2.4.1.2 "><p id="p1660661115618"><a name="p1660661115618"></a><a name="p1660661115618"></a>GM -&gt; VECIN（GM -&gt; UB）</p>
</td>
<td class="cellrowborder" valign="top" width="65%" headers="mcps1.2.4.1.3 "><p id="p18212105716448"><a name="p18212105716448"></a><a name="p18212105716448"></a>int8_t、uint8_t、int16_t、uint16_t、int32_t、uint32_t、half、bfloat16_t、float</p>
</td>
</tr>
<tr id="row17657174622912"><td class="cellrowborder" valign="top" width="11.03%" headers="mcps1.2.4.1.1 "><p id="p965744612913"><a name="p965744612913"></a><a name="p965744612913"></a><span id="ph16239174011416"><a name="ph16239174011416"></a><a name="ph16239174011416"></a><term id="zh-cn_topic_0000001312391781_term1253731311225_1"><a name="zh-cn_topic_0000001312391781_term1253731311225_1"></a><a name="zh-cn_topic_0000001312391781_term1253731311225_1"></a>Ascend 910C</term></span></p>
</td>
<td class="cellrowborder" valign="top" width="23.97%" headers="mcps1.2.4.1.2 "><p id="p78493535291"><a name="p78493535291"></a><a name="p78493535291"></a>GM -&gt; VECIN（GM -&gt; UB）</p>
</td>
<td class="cellrowborder" valign="top" width="65%" headers="mcps1.2.4.1.3 "><p id="p173802011458"><a name="p173802011458"></a><a name="p173802011458"></a>int8_t、uint8_t、int16_t、uint16_t、int32_t、uint32_t、half、bfloat16_t、float</p>
</td>
</tr>
</tbody>
</table>

**表 5**  Local Memory -\> Global Memory具体通路和支持的数据类型

<a name="table471056133314"></a>
<table><thead align="left"><tr id="row771046193311"><th class="cellrowborder" valign="top" width="11.04%" id="mcps1.2.4.1.1"><p id="p571110613315"><a name="p571110613315"></a><a name="p571110613315"></a>产品型号</p>
</th>
<th class="cellrowborder" valign="top" width="23.96%" id="mcps1.2.4.1.2"><p id="p11711267333"><a name="p11711267333"></a><a name="p11711267333"></a>数据通路</p>
</th>
<th class="cellrowborder" valign="top" width="65%" id="mcps1.2.4.1.3"><p id="p8711466338"><a name="p8711466338"></a><a name="p8711466338"></a>源操作数和目的操作数的数据类型（两者保持一致）</p>
</th>
</tr>
</thead>
<tbody><tr id="row3711865330"><td class="cellrowborder" valign="top" width="11.04%" headers="mcps1.2.4.1.1 "><p id="p1771114683312"><a name="p1771114683312"></a><a name="p1771114683312"></a><span id="ph1971115613338"><a name="ph1971115613338"></a><a name="ph1971115613338"></a><term id="zh-cn_topic_0000001312391781_term11962195213215_2"><a name="zh-cn_topic_0000001312391781_term11962195213215_2"></a><a name="zh-cn_topic_0000001312391781_term11962195213215_2"></a>Ascend 910B</term></span></p>
</td>
<td class="cellrowborder" valign="top" width="23.96%" headers="mcps1.2.4.1.2 "><p id="p1771117612335"><a name="p1771117612335"></a><a name="p1771117612335"></a>VECOUT -&gt; GM（UB -&gt; GM）</p>
</td>
<td class="cellrowborder" valign="top" width="65%" headers="mcps1.2.4.1.3 "><p id="p18302352154819"><a name="p18302352154819"></a><a name="p18302352154819"></a>int8_t、uint8_t、int16_t、uint16_t、int32_t、uint32_t、half、bfloat16_t、float</p>
</td>
</tr>
<tr id="row838539203014"><td class="cellrowborder" valign="top" width="11.04%" headers="mcps1.2.4.1.1 "><p id="p339183923018"><a name="p339183923018"></a><a name="p339183923018"></a><span id="ph285155133017"><a name="ph285155133017"></a><a name="ph285155133017"></a><term id="zh-cn_topic_0000001312391781_term1253731311225_2"><a name="zh-cn_topic_0000001312391781_term1253731311225_2"></a><a name="zh-cn_topic_0000001312391781_term1253731311225_2"></a>Ascend 910C</term></span></p>
</td>
<td class="cellrowborder" valign="top" width="23.96%" headers="mcps1.2.4.1.2 "><p id="p13207343203015"><a name="p13207343203015"></a><a name="p13207343203015"></a>VECOUT -&gt; GM（UB -&gt; GM）</p>
</td>
<td class="cellrowborder" valign="top" width="65%" headers="mcps1.2.4.1.3 "><p id="p113915548489"><a name="p113915548489"></a><a name="p113915548489"></a>int8_t、uint8_t、int16_t、uint16_t、int32_t、uint32_t、half、bfloat16_t、float</p>
</td>
</tr>
</tbody>
</table>

## 调用示例<a name="section642mcpsimp"></a>

```
#include "kernel_operator.h"
// 本样例中tensor数据类型为float
template <typename T>
class KernelDataCopySliceGM2UB {
public:
    __aicore__ inline KernelDataCopySliceGM2UB()
    {}
    __aicore__ inline void Init(__gm__ uint8_t* dstGm, __gm__ uint8_t* srcGm)
    {
        AscendC::SliceInfo srcSliceInfoIn[] = {{16, 70, 7, 3, 87}, {0, 2, 1, 1, 3}};// 如输入数据示例：startIndex为16，endIndex为70，burstLen为3，stride为7, shapeValue为87。
        AscendC::SliceInfo dstSliceInfoIn[] = {{0, 47, 0, 3, 48}, {0, 1, 0, 1, 2}};// UB空间相对紧张，建议设置stride为0。
        uint32_t dimValueIn = 2;
        uint32_t dstDataSize = 96;
        uint32_t srcDataSize = 261;
        dimValue = dimValueIn;
        for (uint32_t i = 0; i < dimValueIn; i++) {
            srcSliceInfo[i].startIndex = srcSliceInfoIn[i].startIndex;
            srcSliceInfo[i].endIndex = srcSliceInfoIn[i].endIndex;
            srcSliceInfo[i].stride = srcSliceInfoIn[i].stride;
            srcSliceInfo[i].burstLen = srcSliceInfoIn[i].burstLen;
            srcSliceInfo[i].shapeValue = srcSliceInfoIn[i].shapeValue;
            dstSliceInfo[i].startIndex = dstSliceInfoIn[i].startIndex;
            dstSliceInfo[i].endIndex = dstSliceInfoIn[i].endIndex;
            dstSliceInfo[i].stride = dstSliceInfoIn[i].stride;
            dstSliceInfo[i].burstLen = dstSliceInfoIn[i].burstLen;
            dstSliceInfo[i].shapeValue = dstSliceInfoIn[i].shapeValue;
        }
        srcGlobal.SetGlobalBuffer((__gm__ T *)srcGm);
        dstGlobal.SetGlobalBuffer((__gm__ T *)dstGm);
        pipe.InitBuffer(inQueueSrcVecIn, 1, dstDataSize * sizeof(T));
    }
    __aicore__ inline void Process()
    {
        CopyIn();
        CopyOut();
    }
private:
    __aicore__ inline void CopyIn()
    {
        AscendC::LocalTensor<T> srcLocal = inQueueSrcVecIn.AllocTensor<T>();
        AscendC::DataCopy(srcLocal, srcGlobal,  dstSliceInfo, srcSliceInfo, dimValue);
        inQueueSrcVecIn.EnQue(srcLocal);
    }
    __aicore__ inline void CopyOut()
    {
        AscendC::LocalTensor<T> srcOutLocal = inQueueSrcVecIn.DeQue<T>();
        AscendC::DataCopy(dstGlobal, srcOutLocal, dstSliceInfo, dstSliceInfo, dimValue);
        inQueueSrcVecIn.FreeTensor(srcOutLocal);
    }
private:
    AscendC::TPipe pipe;
    AscendC::TQue<AscendC::TPosition::VECIN, 1> inQueueSrcVecIn;
    AscendC::GlobalTensor<T> srcGlobal;
    AscendC::GlobalTensor<T> dstGlobal;
    AscendC::SliceInfo dstSliceInfo[K_MAX_DIM];
    AscendC::SliceInfo srcSliceInfo[K_MAX_DIM]; // K_MAX_DIM = 8
    uint32_t dimValue;
};
extern "C" __global__ __aicore__ void kernel_data_copy_slice_out2ub(__gm__ uint8_t* src_gm, __gm__ uint8_t* dst_gm)
{
    KernelDataCopySliceGM2UB<TYPE> op;
    op.Init(dst_gm, src_gm);
    op.Process();
}
```

结果示例请参考[图1](#fig1196816115710)。

