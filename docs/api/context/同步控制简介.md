# 同步控制简介<a name="ZH-CN_TOPIC_0000001911280732"></a>

开发者可以使用同步控制接口来自行完成同步控制。需要注意的是，通常情况下，开发者基于编程模型中介绍的编程模型和范式进行编程时不需要关注同步，编程模型帮助开发者完成了同步控制；使用编程模型和范式是我们推荐的编程方式，自行同步控制可能会带来一定的编程复杂度，不建议开发者使用。[TQueSync](TQueSync.md)类接口和[SetFlag/WaitFlag\(ISASI\)](SetFlag-WaitFlag(ISASI).md)中提供的同步控制接口的区别在于，[SetFlag/WaitFlag\(ISASI\)](SetFlag-WaitFlag(ISASI).md)中的接口标注为ISASI类别，不能保证跨硬件版本兼容；TQueSync类接口可以保证跨硬件版本兼容。

## 同步控制简介<a name="section186621716446"></a>

介绍同步控制之前需要先回顾一下[图1](#fig758422819442)。

AI Core内部的异步并行计算过程：Scalar计算单元读取指令序列，并把向量计算、矩阵计算、数据搬运指令发射给对应单元的指令队列，向量计算单元、矩阵计算单元、数据搬运单元异步的并行执行接收到的指令。该过程可以参考[图1](#fig758422819442)中蓝色箭头所示的指令流。

不同的指令间有可能存在依赖关系，为了保证不同指令队列间的指令按照正确的逻辑关系执行，Scalar计算单元也会给对应单元下发同步指令。各单元之间的同步过程可以参考[图1](#fig758422819442)中的绿色箭头所示的同步信号流。

AI Core内部数据处理的基本过程：DMA搬入单元把数据搬运到Local Memory，Vector/Cube计算单元完成数据计算，并把计算结果写回Local Memory，DMA搬出单元把处理好的数据搬运回Global Memory。该过程可以参考[图1](#fig758422819442)中的红色箭头所示的数据流。

**图 1**  AI Core内部并行计算架构抽象<a name="fig758422819442"></a>  
![](figures/AI-Core内部并行计算架构抽象.png "AI-Core内部并行计算架构抽象")

从上图可以了解到AI Core内部的执行单元是异步并行的，在读写Local Memory内存时，可能存在依赖，需要进行同步控制。

下图示例描述了一个常见的Vector计算数据流：

1.  先通过DMA执行单元将数据从Global Memory搬入到Local Memory；
2.  进行计算；
3.  然后再通过DMA执行单元将计算结果从Local Memory搬出到Global Memory。

![](figures/图1-AI-Core内部并行计算架构抽象示意图.png)

四个执行单元Scalar、Vector、DMA\(VECIN\)、DMA\(VECOUT\)并行执行，若访问同一片Local Memory，需要同步机制来控制他们的访问时序：保证先搬入Local Memory后再计算，计算完成后再搬出。

![](figures/Iterate_flase.png)

## 硬件流水类型<a name="section1272612276459"></a>

AI Core内部并行的指令流水类型和解释如下所示，硬件流水的详细介绍请参考[硬件实现](zh-cn_topic_0000002380398225.md)章节。

**表 1**  指令流水类型和相关说明

<a name="table122172503915"></a>
<table><thead align="left"><tr id="row82178506918"><th class="cellrowborder" valign="top" width="23.03%" id="mcps1.2.3.1.1"><p id="p1821725011911"><a name="p1821725011911"></a><a name="p1821725011911"></a>流水类型</p>
</th>
<th class="cellrowborder" valign="top" width="76.97%" id="mcps1.2.3.1.2"><p id="p8217145014917"><a name="p8217145014917"></a><a name="p8217145014917"></a>含义</p>
</th>
</tr>
</thead>
<tbody><tr id="row621713504920"><td class="cellrowborder" valign="top" width="23.03%" headers="mcps1.2.3.1.1 "><p id="p202175501295"><a name="p202175501295"></a><a name="p202175501295"></a>PIPE_S</p>
</td>
<td class="cellrowborder" valign="top" width="76.97%" headers="mcps1.2.3.1.2 "><p id="p5217650394"><a name="p5217650394"></a><a name="p5217650394"></a>标量流水线，使用Tensor GetValue函数时为此流水</p>
</td>
</tr>
<tr id="row721710502092"><td class="cellrowborder" valign="top" width="23.03%" headers="mcps1.2.3.1.1 "><p id="p82170501916"><a name="p82170501916"></a><a name="p82170501916"></a>PIPE_V</p>
</td>
<td class="cellrowborder" valign="top" width="76.97%" headers="mcps1.2.3.1.2 "><p id="p1921716505917"><a name="p1921716505917"></a><a name="p1921716505917"></a>矢量计算流水及L0C-&gt;UB数据搬运流水</p>
</td>
</tr>
<tr id="row1883183712359"><td class="cellrowborder" valign="top" width="23.03%" headers="mcps1.2.3.1.1 "><p id="p138319375357"><a name="p138319375357"></a><a name="p138319375357"></a>PIPE_M</p>
</td>
<td class="cellrowborder" valign="top" width="76.97%" headers="mcps1.2.3.1.2 "><p id="p7832377352"><a name="p7832377352"></a><a name="p7832377352"></a>矩阵计算流水</p>
</td>
</tr>
<tr id="row148311377357"><td class="cellrowborder" valign="top" width="23.03%" headers="mcps1.2.3.1.1 "><p id="p1583537163515"><a name="p1583537163515"></a><a name="p1583537163515"></a>PIPE_MTE1</p>
</td>
<td class="cellrowborder" valign="top" width="76.97%" headers="mcps1.2.3.1.2 "><p id="p168333753515"><a name="p168333753515"></a><a name="p168333753515"></a>L1-&gt;L0A、L1-&gt;L0B数据搬运流水</p>
</td>
</tr>
<tr id="row1721716501098"><td class="cellrowborder" valign="top" width="23.03%" headers="mcps1.2.3.1.1 "><p id="p112181650399"><a name="p112181650399"></a><a name="p112181650399"></a>PIPE_MTE2</p>
</td>
<td class="cellrowborder" valign="top" width="76.97%" headers="mcps1.2.3.1.2 "><p id="p1821811501298"><a name="p1821811501298"></a><a name="p1821811501298"></a>GM-&gt;L1、GM-&gt;L0A、GM-&gt;L0B、GM-&gt;UB数据搬运流水</p>
</td>
</tr>
<tr id="row112183501492"><td class="cellrowborder" valign="top" width="23.03%" headers="mcps1.2.3.1.1 "><p id="p921865017916"><a name="p921865017916"></a><a name="p921865017916"></a>PIPE_MTE3</p>
</td>
<td class="cellrowborder" valign="top" width="76.97%" headers="mcps1.2.3.1.2 "><p id="p1221865012914"><a name="p1221865012914"></a><a name="p1221865012914"></a>UB-&gt;GM、UB-&gt;L1数据搬运流水</p>
</td>
</tr>
<tr id="row142181150993"><td class="cellrowborder" valign="top" width="23.03%" headers="mcps1.2.3.1.1 "><p id="p132180506918"><a name="p132180506918"></a><a name="p132180506918"></a>PIPE_FIX</p>
</td>
<td class="cellrowborder" valign="top" width="76.97%" headers="mcps1.2.3.1.2 "><p id="p11218050091"><a name="p11218050091"></a><a name="p11218050091"></a>L0C-&gt;GM、L0C-&gt;L1数据搬运流水。</p>
</td>
</tr>
</tbody>
</table>

## 同步控制分类<a name="section2167161594419"></a>

对上述并行流水的同步控制分为两种：

-   多流水同步：通过[TQueSync](TQueSync.md)的SetFlag/WaitFlag或者[SetFlag/WaitFlag\(ISASI\)](SetFlag-WaitFlag(ISASI).md)接口进行不同流水线间的同步控制。
    -   SetFlag：当前序指令的所有读写操作都完成之后，当前指令开始执行，并将硬件中的对应标志位设置为1。
    -   WaitFlag：当执行到该指令时，如果发现对应标志位为0，该队列的后续指令将一直被阻塞；如果发现对应标志位为1，则将对应标志位设置为0，同时后续指令开始执行。

-   单流水同步：通过[PipeBarrier\(ISASI\)](PipeBarrier(ISASI).md)完成同一流水线内的同步控制，用于在同一流水线内部约束执行顺序。其作用是，保证前序指令中所有数据的读写工作全部完成，后序指令才能执行。

## 什么时候需要开发者手动插入同步<a name="section14375133724414"></a>

-   Vector计算单元
    -   单流水同步：PIPE\_V由编译器自动完成同步插入，PIPE\_MTE2/PIPE\_MTE3在搬运地址有重叠的情况下需要开发者插入同步（具体示例请参考[注意事项](基础数据搬运.md#li71531626153617)）。
    -   多流水同步：PIPE\_V、PIPE\_MTE2、PIPE\_MTE3、PIPE\_S之间的多流水同步，都是双向的，如下图所示，黄色线条表示的同步由编译器自动完成同步插入，剩余的同步由Ascend C框架完成。

        ![](figures/图1-AI-Core内部并行计算架构抽象示意图-10.png)

-   Cube计算单元

    Cube侧所有流水同步都由Ascend C框架完成，不需要算子开发者插入同步。

    >![](public_sys-resources/icon-note.gif) **说明：** 
    >上文描述的编译器自动完成同步插入强依赖于LocalTensor间依赖关系，部分场景下需要开发者手动完成同步，具体的约束说明请参考。

